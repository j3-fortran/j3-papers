##############################################################################
#                                                                            #
#                                X3J3/93-006                                 #
#                                                                            #
#                               February 1993                                #
#                                                                            #
##############################################################################


Number Title                                                            Status
000000 Minor edits and corrections to ISO/IEC 1539:1991 (E)                  3
000000 Minor edits and corrections to ISO/IEC 1539:1991 (E)                  2
000001 Equivalence of expression evaluations                                 3
000002 Default main program name                                             3
000003 Preconnected units and UNIT=*                                         3
000004 Blanks in format specifications in free form source                   2
000005 Namelist output of zero length character strings                      3
000006 Procedure specifications in a scoping unit                            3
000007 Duplicate module procedures in interface blocks                       1
000008 subsumed by item 7                                                   **
000009 Generic interfaces with the same name in a program                    3
000010 Generic interfaces with the same name in a scoping unit               3
000011 Multiple accessible defined assignment interfaces                     2
000012 Type of a named constant when there is IMPLICIT mapping               2
000013 Implicit mapping of an interface block                                3
000014 Interface for a character function with a variable length result      3
000015 Error in fourth constraint for R429                                   3
000016 Character length specification                                        3
000017 Creation of entities by local names in rename-list                    3
000018 Valid characters for indicating fixed form statement continuation     3
000019 Correctness of last example in section 4.5                            3
000020 References to the same derived type by different names                3
000021 References to different derived types with the same name              3
000022 Use of derived type name in host scoping unit                         3
000023 subsumed by item 12                                                  **
000024 IMPLICIT NONE and the type of a  function result                      3
000025 Resolution of internal procedure references                           3
000026 Bounds of array expressions                                           3
000027 Requirements for pointers and target association                     **
000028 Precedence of use or host association                                 1
000029 Class of a defined operator                                           2
000030 Length of character literals in array constructors                    2
000031 Overloaded implied-DO variable names  KEYWORD: implied-Do variable, D 3
000032 Implicit declaration of a derived type                                3
000033 Interface blocks with the same name in a program                      3
000034 subsumed by item 33                                                  **
000035 subsumed by item 33                                                  **
000036 Pointer to an assumed-size array                                      3
000037 Use of array sections in pointer assignment statements                3
000038 Same interface body in multiple generic interface blocks              3
000039 Association of a pointer actual argument with a dummy argument        2
000040 Allocation of arrays of pointers                                      3
000041 Procedure with target dummy argument requires explicit interface      2
000042 KIND parameter value                                                  3
000043 List-directed character input                                         3
000044 END statement and fixed form source                                   3
000045 Array intrinsics with arrays of derived-type arguments                3
000046 RESULT clause for RECURSIVE functions                                 3
000047 Automatic data object in initialization expressions                   3
000048 Pointer-valued statement functions                                    3
000049 Characteristics of function results                                   1
000050 Repeat counts on edit descriptors                                     3
000051 On unambiguous generic procedure references                           3
000052 Expressions in statement function definitions                         3
000053 Optional intrinsic function arguments                                 3
000054 Resolving generic procedure references                                0
000055 Characteristics of character function results                         3
000056 TRANSFER intrinsic function description                               3
000057 Prohibition against multiple explicit specific interfaces             3
000058 Ambiguous use of "keyword"                                            2
000059 SEQUENCE derived type and component bounds                            3
000060 Statement function argument references                                3
000061 G edit descriptor with "d" = 0                                        3
000062 Statement function constraints                                        3
000063 Interfaces and dummy procedure arguments                              3
000064 SPACING result for 0.0                                                3
000065 Block and nonblock DO construct                                       3
000066 Declaration of FUNCTION type                                          3
000067 Output of negative signed zero                                        3
000068 Pointer association status                                            3
000069 I/O implied DO variable                                               3
000070 Characteristics specified by interface bodies                         2
000071 USE association and COMMON block names                                2
000072 Missing constraint for SIZE=                                          3
000073 Description of the MERGE intrinsic function                           2
000074 Meaning of "referenced" in 11.3.2                                     3
000075 Interface blocks in block data                                        2
000076 Attributes, properties, characteristics                               1
000077 Misc. questions                                                       1
000078 Intrinsic functions in MODULE specification statements                3
000079 Automatic character and ALLOCATABLE, POINTER and TARGET attributes    2
000080 Vector subscripts in masked array assignment statements               3
000081 Pointer actual argument overlap                                       1
000082 Host association and generic names                                    2
000083 Generic override of intrinsic procedure                              **
000084 Change masked array assignment constraint to prose                    3
000085 Nondefault integer data type for UNIT=, RECL=, and REC= specifiers    3
000086 USE and host association                                              2
000087 PARAMETER statements and SAVE statements                              2
000088 Common block names and local names                                    1
000089 Errors in the DATA statement description                              2
000090 Subroutine and function names in nested scopes                        1
000091 Constraint diagnosis for PRIVATE attribute                            2
000092 Pointer and storage association                                       2
000093 Scalar pointer function results                                       2
000094 Functions in WRITE statement implied-DO loops                         3
000095 Functions in IOLENGTH implied-DO loops                                3
000096 Definition of "Declaration"                                           1
000097 Specification expression                                              2
000098 KIND param and list directed I/O                                      2
000099 Generic interfaces                                                    1
000100 ASSOCIATED intrinsic and zero-sized objects                           2
000101 Specification statements                                              1
000102 Returned value for INQUIRE POSITION= on an empty file                 2
000103 Statement Function with unreferenced dummy argument                   3
000104 Rounding formatted output                                             3
000105 Parallel evaluation of operands and arguments                         2
000106 Multiple USE of modules; renaming rules                               2
000107 USE renaming of generic and specific interfaces                       3
000108 Referencing disassociated pointers                                    2
000109 Intrinsic function ASSOCIATED                                         3
000110 Named constant shape specification                                    3
000111 Array constructors in masked assignment statements                    1
000112 Sequence derived type external functions                              2
000113 Ordering of array specification and initialization                    2
000114 Named constant attribute specification                                3
000115 Multiple dummy arguments DEFECT TYPE: Interpretation                  3
000116 Scoping units and statement labels                                    3
000117 Use of MODULE PROCEDURE statement in internal procedures              2
000118 Named constructs and host association                                 3
000119 Rank of assumed-shape array                                           3
000120 PRESENT intrinsic and host association                                3
000121 ";" As a Statement Separator                                          1
000122 Intrinsic procedures in modules                                       1
000123 Result of INT(A) not equal to A for non-default integers              2
000124 Result of LBOUND for assumed-size arrays                              1
000125 Copy in/copy out of target dummy arguments                            2
000126 Character entry statements and partial association                    1
000127 Is a module a global entity?                                          1
000128 Use associated generic names and renaming                             1
000129 Array constructors in initialization expressions                      2
000130 Multiple statements on line with END statement                        2



INTRODUCTION

This document is an internal working document of X3J3, the Fortran
Technical Committee of the American National Standards Association, and
contains the committee's responses to the defect reports received
against ISO/IEC 1539:1991 (E).

The status of each item in this document is tracked with the STATUS
field, the six values of which are:

   1. X3J3 consideration in progress

   Submitted via the hardcopy route or via the RFI or RFC email route
   and being processed by X3J3, but as yet no response has been adopted
   by an X3J3 formal vote.

   2. X3J3 draft response

   A response (ANSWER field) has been approved by a formal X3J3 vote but
   not yet approved by subsequent letter ballot.

   3. X3J3 approved; ready for WG5

   Approved by an X3J3 letter ballot. This vote will be taken only on
   items having a STATUS of "X3J3 draft response".

   4. WG5 approved; ready for SC22

   Approved by WG5 for further processing within ISO as a corrigendum
   item. WG5 will advise X3J3 when an item reaches this status.

   5. Returned by WG5 for X3J3 reconsideration

   Returned to X3J3 after the item had been forwarded to WG5 but failed
   to gain WG5 approval. This status is equivalent to "X3J3 consideration
   in progress".

   6. Published

   Published as an item in an approved corrigenda report, or
   incorporated into the next draft revision of the standard. In either
   case the item must have previously attained the status of "WG5
   approved; ready for SC22".

Each entry is categorized by its defect type of which there are three
kinds (these definitions are taken from the X3/SD-2 of February 1992):

   1. Erratum

   The standard may be modified with corrigenda to:

     a) Correct a typographical error.

     b) Insert a missing word, sentence, paragraph, figure, example,
       table, or clause.

     c) Delete a extraneous word, sentence, paragraph, figure, example,
        table, or clause.

   Any such modification of the standard shall not introduce technical
   changes or changes in what it means to conform to the standard.

   2. Amendment

   Any modification of the standard that introduces technical changes or
   changes in what it means to conform to the standard shall be treated
   as an amendment to the standard.

   3. Interpretation

   An interpretation is a clarifying commentary on the standard that
   does not introduce either a technical change or a change in what it
   means to conform to the standard.

The first entry, which has the number 000000-a, contains details of
X3J3-approved minor edits and corrections to the standard. The second
entry, which has the number 000000-b, is similar but is only in X3J3-
draft status.

================================================================================

NUMBER: 000000-a
TITLE: Minor edits and corrections to ISO/IEC 1539:1991 (E)
KEYWORDS: edits, typos, typographical errors
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

   1. Introduction, Overview, Data Concepts, last sentence [xvi:1-2];
      Delete the sentence "The section concludes ... names."

   2. 2.4.6, third sentence [15:25]; Change "of" to "or".

   3. 12.4.1.1, first paragraph, last line [172:41]; Change "of the the
      dummy" to "of the dummy"

   4. 12.5.2.4, at end of first paragraph [177:29]; Add new sentence
      "When a statement function is invoked, an instance of that statement
      function is created."

   5. 13.13.25, Result Value, Case (ii), at beginning of the third line
      [203:23]; Change "1,sh" to "sh,1".

   6. 13.13.66, Result Value, Case (iii) [220:25]; Change",[" to "["
      (i.e. delete comma).

   7. Annex A, conformable [255:27]; Change "2.4.7" to "2.4.5".

   8. Annex A, constant [255:38]; Change "2.4.4" to "2.4.3.1.2".

   9. Annex A, derived type [256:23]; Change "2," to "2)".

  10. Annex A, extent [257:8]; Change "2.4.7" to " 2.4.5".

  11. Annex A, literal constant [258:19]; Change "2.4.4" to "2.4.3.1.2".

  12. Annex A, main program [258:22]; Change "2," to "2)".

  13. Annex A, module [258:25]; Change "4," to "4)".

  14. Annex A, named constant [258:34]; Change "2.4.4" to "2.4.3.1.2".

  15. Annex A, procedure [259:19]; Change "3," to "3)".

  16. Annex A, rank [259:31]; Change "2.4.7" to "2.4.5".

  17. Annex A, shape [ 260:12]; Change "2.4.7" to "2.4.5".

  18. Annex A, size [260:14]; Change "2.4.7" to "2.4.5".

  19. Annex A, subobject [260:35]; Change "2.4.3.2" to "2.4.3.1".

  20. Annex A, target [261:9];  Change "specified in a" to "specified in
      a TARGET statement or".

  21. Annex A, variable [261:30]; Change "2.4.5" to "2.4.3.1.1".

HISTORY:  The initial set of 20 items, all except item 3, prepared at
WG5 (Victoria, BC) and submitted to X3J3 122, July 1992.  Item 3
submitted at X3J3 meeting 123, November 1992.  Approved in X3J3 letter
ballots 92-182 and 930-016.

--------------------------------------------------------------------------------

NUMBER: 000000-b
TITLE: Minor edits and corrections to ISO/IEC 1539:1991 (E)
KEYWORDS: edits, typos, typographical errors
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

   1. 11.3.3.7, in the second sentence, change "C.11.5" to "C.11.4"

   2. Annex A, host association [257:29]; Change "11.2.2" to
      "12.1.2.2.1".

   3. Annex C, first example [273:14]; change "ENDTYPE" to "END TYPE".

HISTORY: Submitted at X3J3 meeting 124, Feb 1993, papers 93-036, 93-078,
93-081

--------------------------------------------------------------------------------

NUMBER: 000001
TITLE: Equivalence of expression evaluations
KEYWORDS: arithmetic expressions, mathematical equivalence, numeric
operations
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  In the following code fragments must the values of D be the
same for all legal values of A, B, and C?

          TEMP=A+B
          D=C+TEMP
and
          D=C+(A+B)

ANSWER: No.

Discussion: Section 7.1.7.3 "Evaluation of numeric operations",
specifies that processors may evaluate any mathematically equivalent
expression and notes, for example, that X+Y can be evaluated as Y+X.
Thus, the statements in the question could legitimately be evaluated as:

          TEMP=A+B
          D=C+TEMP
and
          D=C+(B+A)

Consequently, there is no requirement that the computational result be
the same.

REFERENCE: ISO/IEC 1539:1991 (E) section 7.1.7.3

EDITS: None.

SUBMITTED BY: J.C.Adams 119-JCA-2 (119.002)
HISTORY: 119-RL-1 (119.047)
         92-044   (S20.120A)
         92-104   (Interpretation)
         Approved as 92-147 at meeting 122 by a vote of 21-1
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000002
TITLE: Default main program name
KEYWORDS: main program, default name
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Some implementations of Fortran supply a default PROGRAM
statement and program name when it is omitted from the main program. If
the default program name conflicts with a global name  in the program is
the processor standard conforming or not?
For example:

          COMMON /MAIN/ A(1000)
          READ *,N
          CALL SUB(N)
          END

          SUBROUTINE SUB(N)
          COMMON /MAIN/ A(1000)
          DO 100 I=1,N
            A(I)=0.0
   100    CONTINUE
          END

If a processor supplies a PROGRAM statement with a default name MAIN,
this will conflict with the common block name MAIN. Is such a processor
standard conforming?

If the processor supplied a name which could never conflict with a
Fortran name, would it be standard conforming? Would the processor in
the example above be standard conforming if it used $MAIN, for  example,
instead of MAIN?

ANSWER: This situation is covered by the third paragraph of sections 1.4
and C.11.1 of  ISO/IEC 1539:1991.  Specifically, section 1.4, item (1),
of ISO/IEC 1539:1991 states:

A processor conforms to this International Standard if:

  (1) It executes any standard-conforming  program in a manner that
      fulfills the interpretations herein, subject to any limits that the
      processor may impose on the size and complexity of the program.

If, as in the example provided, the processor supplies a PROGRAM
statement with a symbolic name that conflicts with  another global name
in the program such that the program fails to  execute, then the
processor does not conform to the standard. The  processor may supply a
default name which does not conflict with another  global name and be
standard conforming.

REFERENCES: ISO/IEC 1539:1991 (E) sections 1.4 and C.11.1
            ANSI X3.9-1978 section 1.4 (page 1-2, lines 25-27)

EDITS: None.

SUBMITTED BY: A. D. Tait, 117-ADT-5 (117.035), 118-ADT-3 (118.045)
HISTORY: 119-ADT-1 (119.012), 119-RL-2 (119.048)
         X3J3 draft response at meetings 120, 123

--------------------------------------------------------------------------------

NUMBER: 000003
TITLE: Preconnected units and UNIT=*
KEYWORDS: preconnected units, identifying a unit, UNIT=*
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is a processor which associates preconnected units with the
files identified by the * in READ and WRITE statements standard
conforming?

ANSWER: Yes.

Discussion: This situation is covered by sections 9.3and 9.4.4.2 of
ISO/IEC 1539:1991. These sections state that the asterisk identifies a
particular processor-determined unit which is the same for a PRINT
statement and a WRITE statement which contains an asterisk. The
processor-determined unit is different for a READ statement which
contains an asterisk.

REFERENCES: ISO/IEC 1539:1991 (E) sections 9.3 and 9.4.4.2
            ANSI X3.9-1978 section 12.9.2

EDITS: None.

SUBMITTED BY: A. D. Tait, 118-ADT-2 (118.024)
HISTORY: Approved as 119-ADT-2 (119.013) at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000004
TITLE: Blanks in format specifications in free form source
KEYWORDS: free form source, format specification, blanks
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Is the following format specification valid in free form
source?

                 FORMAT (B  N)

ANSWER: Yes.

Discussion: Sections of Fortran 90 are not consistent.

   3.3.1: In free form, blank characters must not appear within lexical
          tokens other than in a character context.

      and

          A blank must be used to separate names, constants, or labels
          from adjacent keywords, names, constants, ...

  10.1.1: Additional blank characters may appear at any point within the
          format specification, with no effect on the interpretation of
          the format specification, except within a character string
          edit descriptor.

It can be seen that the text in chapter 3 does not consider edit
descriptors.  The text will be revised so that:

     -- edit descriptors are not in the category "keywords" and need not
        be delimited by blanks.

     -- blanks are allowed in edit descriptors.

Note that the first edit below depends on a change made in item 58 which
moves the line from section 3.2.1 to 2.5.2

REFERENCES: ISO/IEC 1539:1991 (E) sections 3.3.1, 10.1.1

EDITS:

   1. Section 2.5.2 following the sentence "Keywords appear ... through
      12." add the following:

      "Note that in addition to keywords, upper-case letters may also
       appear in various other lexical tokens.  Examples include
       operators such as .EQ., edit descriptors such as BN or Iw[.m],
       and literal constants such as B'digit[digit]...'."

   2. Section 3.2 page 19 last sentence [19:35-36] insert ", edit
      descriptors" following "... , labels".

   3. Section 3.3.1, page 22, second paragraph, change "... character
      context."  to "... character context or in a format specification."

SUBMITTED BY: J.T. Martin 119-JTM-2 (119.015)
HISTORY: 119-JTM-2
         119-RPK-1
         X3J3/92-044        S20.120, number 4
         X3J3/92-075
         X3J3/92-145        Draft Interpretation by CIO, withdrawn
         Approved as X3J3/92-176 at meeting 122 by unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000005
TITLE: Namelist output of zero length character strings
KEYWORDS: namelist output, zero length, character string
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Given the program:

          PROGRAM P
            CHARACTER*0 CH
            NAMELIST/OUT/CH
            OPEN(UNIT=8,DELIM='NONE')
            WRITE(UNIT=8,NML=OUT)
          END

The namelist output record would be:

          &OUT CH= /

Does not this conflict with the statement in section 10.9.2.2 that:

          A null value is not produced by namelist formatting.

ANSWER: No.

Discussion: Although the output produced by this program appears to
contain a null value (to namelist input), actually a zero-length
character string was written by the namelist output statement. Note that
this is different from a null value (section 10.9.1.4) which has no
meaning on output. The statement:

          A null value is not produced by namelist formatting.

indicates that since all namelist group objects have a value, that value
(in this case a zero-length string) is output.

REFERENCES: ISO/IEC 1539:1991 (E) sections 10.9.1.4, & 10.9.2.2,

EDITS: None.

SUBMITTED BY: J. T. Martin, 119-JTM-3 (119.016)
HISTORY: 119-RPK-2 (119.064), & 119-JTM-6 (119.041)
                   Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000006
TITLE: Procedure specifications in a scoping unit
KEYWORDS: procedure specification, scoping unit, interface body
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Which of the following procedure related specifications may
jointly occur within a scoping unit?

 a. An interface body for the procedure and the appearance of the
    procedure name in a type statement
 b. A module procedure definition and the appearance of the procedure
    name in a type statement
 c. A module procedure definition and an interface body for the
    procedure
 d. An interface body for the procedure and the appearance of the
    procedure name in an EXTERNAL statement

ANSWER: None of the above.

Discussion: Section 5.1 states the generally applicable constraint:

     An entity must not be given explicitly any attribute more than once
     in a scoping unit.

An interface body provides an explicit interface to the procedure. This
interface includes the characteristics of the procedure: these
characteristics include, for a function, the type of the value returned.
Thus, the interface body is an explicit declaration of the function
result type, and this must not also be declared in a type statement (a).

Similarly, a module procedure definition includes a declaration of its
interface, so its presence precludes the presence of either a type
statement declaring function result (b) or an interface body declaring
its characteristics (c). The case of the module procedure definition and
interface body is also covered by the statement in 12.3.2.1 that

     A procedure must not have more than one explicit specific interface
     in a given scoping unit.

and by the fact that the statement (also in 12.3.2.1):

     An interface body in an interface block specifies an explicit
     interface for an existing external procedure or a dummy procedure,

does not include module procedures.

The latter statement in conjunction with the sentence which follows it
also implies that the interface body declares the same attributes as the
EXTERNAL statement, so this combination is similarly prohibited (d).

This last case may be less than obvious. This deficiency is remedied by
an edit to provide an explicit prohibition to cover this case.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1, & 12.3.2.1

EDIT: At the end of the fourth paragraph following R1207 in 12.3.2.2, add

     A name that appears in an EXTERNAL statement must not also appear
     as a specific procedure name in an interface block in the scoping
     unit.

SUBMITTED BY: S. M. Lammers, 119-SML-1 (119.019) items 1 through 4
HISTORY: Approved as X3J3/92-170 at meeting 122 by unanimous consent
         Revised following letter ballot at meeting 123, in 92-312.
         Revision approved by unanimous consent at meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000007
TITLE: Duplicate module procedures in interface blocks
KEYWORDS: module procedure name, interface block, generic
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION: May a module procedure name be referenced on more than one
MODULE PROCEDURE statement for a given generic name in a scoping unit,
either in a single interface block or in multiple interface blocks
specifying that generic name?

ANSWER: No.

Discussion: The standard routinely disallows such redundant
specifications within a scoping unit.  The prohibition for this case was
inadvertently overlooked. This deficiency is remedied by the supplied
edit.

Example:
          INTERFACE INT_1
            MODULE PROCEDURE FOO, FOO   ! second FOO is illegal
            MODULE PROCEDURE FOO1
            MODULE PROCEDURE FOO1       ! FOO1 is illegal here
          END INTERFACE INT_1

          INTERFACE INT_2
            MODULE PROCEDURE FOO2A, FOO2B
          END INTERFACE INT_2

          INTERFACE INT_2
            MODULE PROCEDURE FOO2B, FOO2C  ! FOO2B is illegal here
          END INTERFACE INT_2

Note, however, that if the two interface blocks for INT_2 were placed in
separate modules, the second appearance of FOO2B would have been
permitted, as would a scoping unit which used both modules.

For example:

        MODULE MOD1
          USE SOME_OTHER_MODULE      ! the source of FOO2B
            INTERFACE INT_2
              MODULE PROCEDURE FOO2A, FOO2B
            END INTERFACE INT_2
           ...
        END MODULE MOD1

        MODULE MOD2
          USE SOME_OTHER_MODULE    ! the source of FOO2B
            INTERFACE INT_2
              MODULE PROCEDURE FOO2B, FOO2C !FOO2B is legal here
            END INTERFACE INT_2
           ...
        END MODULE MOD2

The following USE statements would be allowed:

                    USE MOD1
                    USE MOD2        ! no problem using both modules here

REFERENCES: ISO/IEC 1539:1991(E) Section 12.3.2.1

EDIT: The following additional constraint should be added to section
12.3.2.1:

     Constraint: A <procedure-name> in a <module-procedure-stmt> must
     not be one which previously had been established to be associated
     with the <generic-spec> of the <interface-block> in which it
     appears, either by a previous appearance in an <interface-block> or
     by use or host association.

SUBMITTED BY: S.M.Lammers, 119-SML-1 (119.019)
HISTORY: Original interpretation was 120-MBSH-4A (120.096A)
         Modified based on X3J3/92-039 arguments. Adopted because this
         interpretation is more consistent with requirements concerning
         duplication of other specification statements in a given
         scoping unit.

         Interpretation modification presented in X3J3/92-095
         Commented on by N786A from WG5 Victoria meeting in item marked
         1167/36+.

         Approved as X3J3/92-155A at meeting 122 by unanimous consent.

--------------------------------------------------------------------------------

NUMBER: 000008
TITLE: Module procedure name in multiple interface blocks
KEYWORDS: module procedure name, interface block
DEFECT TYPE: Interpretation
STATUS: subsumed by item 7

QUESTION:  May a module procedure name be referred to on more than one
MODULE PROCEDURE statement in multiple interface blocks specifying the
same generic name?

ANSWER:

REFERENCES: 120-MBSH-4A (120.096A)

EDITS: None.

SUBMITTED BY: S. M. Lammers, 119-SML-1 (119.019) item 5, question 4
HISTORY: Interpretation questioned in X3J3/92-039
         Resolved by X3J3/92-155A (approved by unanimous consent as the
         response to NUMBER 000007)

--------------------------------------------------------------------------------

NUMBER: 000009
TITLE: Generic interfaces with the same name in a program
KEYWORDS: generic, interface
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: May two generic interfaces of the same name be accessed by use
association in the same scoping unit?

Discussion: Can the following program fragment be part of a standard
conforming program?

          MODULE MOD1
            INTERFACE INT1
              ...
            END INTERFACE
          END MODULE MOD1
          MODULE MOD2
            INTERFACE INT1
              ...
            END INTERFACE
            ...
          END MODULE MOD2
          PROGRAM EXAMPLE_1
            USE MOD1
            USE MOD2

ANSWER: Yes.  As can be seen in section 11.3.2:

     If two or more generic interfaces that are accessible in a scoping
     unit ... they are interpreted as a single generic interface.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2 (paragraph 5 after last
            constraint).

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-4 (120.029), question 1
HISTORY: Proposed as 120-MBSH-1A (120.084A) at meeting 120
         Questioned in X3J3/92-040 (121-JKR-8)
         Approved as X3J3/92-099
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000010
TITLE: Generic interfaces with the same name in a scoping unit
KEYWORDS: generic, interface, scoping unit
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Are two generic interfaces with the same name allowed in the
same scoping unit?

For example can this program fragment be part of a standard conforming
program?

          PROGRAM EXAMPLE_1
            INTERFACE INT1
            ...
            END INTERFACE
            ...
            INTERFACE INT1
            ...
            END INTERFACE

ANSWER: Yes.  As can be seen in section 11.3.2:

     If two or more generic interfaces that are accessible in a scoping
     unit ... they are interpreted as a single generic interface.


REFERENCES: 120-MBSH-1A (120.084A)

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-4 (120.029), question 2
HISTORY: Proposed as 120-MBSH-1A (120.084A) at meeting 120
         Questioned in X3J3/92-040 (121-JKR-8)
         Approved as X3J3/92-100
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000011
TITLE: Multiple accessible defined assignment interfaces
KEYWORDS: interfaces, defined assignment
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Consider the following excerpts from section 14.1.2 [241]:

Excerpt (a): Within a scoping unit, entities in the following classes:

       (1) Named variables that are not statement entities (14.1.3),...,
           generic identifiers, derived types, and namelist group names
           ... are local entities of that scoping unit.

Excerpt (b):  Within a scoping unit, a name that identifies a local
entity of one class must not be used to identify another local entity of
the same class, except in the case of generic names (12.3.2.1). A name
that identifies a local entity of one class may be used to identify a
local entity of another class.

The standard defines both the terms "generic identifier" and "generic
name" in section 12.3.2.1 [168]. "Generic identifier" is defined to
encompass the three concepts of a generic name, a defined operator, or
an equals symbol on a generic specification.  "Generic name" refers to
the BNF term for the name that may appear on an interface specification.

The text from section 14 cited in (a) uses the term "Generic identifier"
but the text cited in (b) uses the term "generic name".  Is the intent
behind the choice of different words in section 14 to prohibit a program
from containing multiple interface blocks for the same operator and
multiple accessible defined assignment interfaces?

ANSWER: No.

Discussion: Section 11.3.2 states:

"If two or more generic interfaces that are accessible in a scoping unit
have the same name, the same operator, or are both assignments, they are
interpreted as a single generic interface"

Thus, two or more interfaces that have the same name, the same operator,
or are assignment interfaces are not only permitted but the interfaces
are considered to be a single generic interface.  The text cited in (b)
above was specifically discussing "names" and hence "generic names" were
singled out. The text cited in (a) above was discussing all entities
that are local to a scoping unit, not just named entities.

REFERENCES: ISO/IEC 1539:1991 (E) sections 11.3.2, 12.3.2.1, & 14.1.2

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-4 (120.029), question 3
LAST SIGNIFICANT CHANGE: before meeting 123	000011
HISTORY: Originally passed as 120-MBSH-1A (120.084A)
         Revised in response to ballot comments at meeting 123,
         but no vote taken - withheld for further consideration
         Slight rewording for clarification in 93-029
         Approved by unanimous consent at meeting 124.
--------------------------------------------------------------------------------

NUMBER: 000012
TITLE: Type of a named constant when there is IMPLICIT mapping
KEYWORDS: named constant, parameter statement, IMPLICIT mapping,
internal procedure, host
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:

1. Is the following code fragment valid Fortran 90?

      PARAMETER (A=1)
      IMPLICIT INTEGER (A)

2. Is the following code fragment valid?

      PROGRAM MAIN
      IMPLICIT INTEGER (Z)      ! Z is mapped to type integer
      ...
      CONTAINS
      SUBROUTINE INNER
        PARAMETER (ZERO = (0.0, 0.0))  ! Name starts with Z
        IMPLICIT COMPLEX (Z)           ! Z is mapped to type complex
        ...
      END SUBROUTINE
      END PROGRAM

ANSWER: No in both cases.

Discussion: In any scoping unit there is only one (possibly null)
implicit typing map (5.3).  Section 5.2.10 states that a named constant
either must have its type, shape, and any type parameters specified
previously or determined by the implicit typing rules currently in
effect for the scoping unit.  The word "currently" is intended to mean
that any IMPLICIT statement which would affect the named constant must
occur previously in the scoping unit.  A subsequent IMPLICIT statement
may specify the type of a named constant appearing in a PARAMETER
statement, but in that case, it must confirm the type of the named
constant.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.2.10 & 5.3

EDITS: None.

SUBMITTED BY: (Question 1) J. T. Martin, 120-JTM-9 (120.046), question 3
              (Question 2) J. L. Steidel, 120-JLS-2 (120.020) case 3
LAST SIGNIFICANT CHANGE:  1993-02-11	000012
HISTORY: 120-LJM-5 (120-093)
         X3J3/92-172, as modified, passed at meeting 122
         Items 000012 and 000023 combined following letter ballot as
         X3J3/93-73r2 and adopted at meeting 124 by unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000013
TITLE: Implicit mapping of an interface block
KEYWORDS: implicit mapping, interface block
DEFECT TYPE: Amendment
STATUS: X3J3 approved; ready for WG5

QUESTION: Is the implicit mapping of the host inherited by an interface
block?

ANSWER: No.

Discussion: Unlike other scoping units that are contained within a host
scoping unit, an interface body does not access entities from its host
by host association.  This was intended to allow the initial statements
of an external procedure to be used without modification in an interface
body describing that procedure.  The possibility of there being
different implicit mappings was inadvertently overlooked.  If not
corrected, this would mean that:

          FUNCTION F(X,I)
            F = X**I/I
          END FUNCTION F

would be properly described by:

          INTERFACE
            FUNCTION F(X,I)
            END FUNCTION F
          END INTERFACE

if the interface block is contained in a host with default implicit
mapping, but not in one containing the statement:

          IMPLICIT INTEGER (A-Z)

The default implicit mapping in an interface body is made consistent
with that in an external procedure by the supplied edit.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.2 & 5.3

EDITS:

   1. In Section 5.3 in the second paragraph after the constraints, in
      the phrase: "the default is the mapping ...", after "default" add
      "for a program unit or an interface body is default integer if the
      letter is I,J, ... , or N and default real otherwise, and the
      default for an internal or module procedure".

      Delete "A program ... O-Z)"

   2. In the example in section 5.3 for FUNCTION FUN in the interface
      block the comment should be changed from:

          ! All data entities must
          ! be declared explicitly

      to

          ! Not all entities need be
          ! declared explicitly

   3. In the first example in section 5.3, change "INTEGER FUN, I" to be
      "INTEGER FUN".

SUBMITTED BY: L.R.Rolison 120-LRR-3 (120.028)
HISTORY: Draft response in 92-102A, questioned in N786A of the Victoria
         WG5 meeting.
         Revised edit approved as 92-154A at meeting 122 by a vote of
         21-1.
         Edit approved in 92-267r at meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000014
TITLE: Interface for a character function with a variable length result
KEYWORDS: character function, variable length, interface
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:   Given a definition of an external function such as the
following where the function result is variable length, must the
characteristics of the function be described by an interface block
accessible to the calling scoping unit?

          FUNCTION F(I)
            INTEGER I,N
            CHARACTER*(N) F
            COMMON /B/ N
            ...
          END

ANSWER: Yes.

Discussion: Section 12.3.1.1 states:

     A procedure must have an explicit interface if ...
     (2) The procedure has ...
         (d) A result whose length type parameter value is neither assumed
             nor constant."

That provision applies to this function. Section 12.3.1 indicates that
an external procedure has an explicit interface only if an interface
block is provided.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.1 & 12.3.1.1

EDITS: None.

SUBMITTED BY: L. R. Rolison, 119-LRR-1, part II
HISTORY: 119-KWH-3A (119-70A)
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000015
TITLE: Error in fourth constraint for R429
KEYWORDS: constraints, R429, <component-decl>
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Should the fourth constraint for R429 also apply to a <char-
selector> in the <type-spec>?

ANSWER: Yes.

Discussion: A nonconstant specification expression specifies an
automatic character object that may be declared only in a procedure or
procedure interface. It was never the intention to permit the
specification of automatic objects in type definitions. The fifth
constraint for R429 prohibits the only other automatic object, an
automatic array.  The length specified in a character <type-spec> should
be similarly restricted.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.1, 5.1, 5.1.1.5, &
            7.1.6.2

EDIT: Replace the fourth constraint after R429 with:

     The character length specified by the <char-length> in a
     <component-decl> or the <char-selector> in a <type-spec>
     (5.1, 5.1.1.5) must be a constant specification expression
     (7.1.6.2).

SUBMITTED BY: J. T. Martin, 119-JTM-7 (119.042) part 1
HISTORY: 119-JTM-11 (119.054)
         Approved at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000016
TITLE: Character length specification
KEYWORDS: character length specification, <char-length>, R508
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is there a similar interaction between a <char-length>
specified in both a <component-decl> and a <char-selector> as there is
between a <char-length> specified in both an <entity-decl> and a <char-
selector>?

ANSWER: Yes.

Discussion: It was intended that character declarations in type
definitions be symmetrical with character object declarations.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.1, 5.1, & 5.1.1.5

EDIT: Replace the text following the constraints for R508 with:

    The <char-selector> in a CHARACTER <type-spec> and the * <char-length>
    in an <entity-decl> or in a <component-decl> of a type definition
    specify character length. The * <char-length> in an <entity-decl> or
    <component-decl> specifies an individual length and overrides the
    length specified in the <char-selector>, if any. If a * <char-length>
    is not specified in an <entity-decl> or <component-decl>, the
    <length-selector> or <type-param-value> specified in the
    <char-selector> is the character length. If the length is not
    specified in a <char-selector> or a * <char-length>, the length is 1.

SUBMITTED BY: J. T. Martin, 119-JTM-7 (119.042) part 2
HISTORY: 119-JTM-12A (119.055A)
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000017
TITLE: Creation of entities by local names in rename-list
KEYWORDS: local names, data entity
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Does a local-name on a rename-list create a new data-entity?
For example, is the local name Q a new data entity or is Q a rename of
the entity P in the following example?

          MODULE UTIL
            PUBLIC P
            CONTAINS
                 SUBROUTINE P
                 END
          END MODULE UTIL

          MODULE MID1
            USE UTIL, Q=>P    ! Is Q a new data entity or merely a
                              ! renaming of P?
            PUBLIC Q
          END MODULE MID1

          MODULE MID2
            USE UTIL, Q=>P    ! Another renaming of the same entity P?
            PUBLIC Q
          END MODULE MID2

          SUBROUTINE ENDUSER
            USE MID1
            USE MID2
            CALL Q                 ! Is this legal? Does it refer to P?
          END SUBROUTINE ENDUSER

ANSWER:

Multiple renames of the same <use-name> do not constitute separate
entities. Subsequent appearances of the <local-name> refer to the single
entity. In the example, Q does not create a new entity.  Thus "CALL Q"
in the subroutine is legal.

Discussion: In section 11.3.2 [158:15-16], the standard states that a
local name in the rename list is a "local name for the entity"  which is
intended to mean that a new entity is not created.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2

EDITS:   None.

SUBMITTED BY: E. A. Johnson, 119-EAJ-1 (119.057)
HISTORY: 120-LF-1 (120.089)
         Response proposed in 92-296, approved by unanimous consent at
         meeting 123

--------------------------------------------------------------------------------

NUMBER: 000018
TITLE: Valid characters for indicating fixed form statement continuation
KEYWORDS: fixed form source, statement continuation, character set
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Line 3 of the first paragraph of 3.3.2.3 states:

     If character position 6 contains any character other than  blank or
     zero, character positions 7-72 of this line constitute a
     continuation of the preceding noncomment line.

Can the character in character position 6 be a character outside the
Fortran character set (for example, newline)?

ANSWER: No.  Section 3.1.5 specifies where additional characters not in
the Fortran character set may be used.

REFERENCES: ISO/IEC 1539:1991 (E) sections 3.1 & 3.3.2.3

EDITS: None.

SUBMITTED BY: J. C. Adams, 120-JCA-13 (120.013)
HISTORY: Originally proposed as 120-RL-1 (120.058)
         Approved as X3J3/92-105 at meeting 121 by a vote of 20-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000019
TITLE: Correctness of last example in section 4.5
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is the order of the coordinates correct in the last example
of 4.5, considering the type definition of LINE in 4.4.1?

ANSWER: Yes.

Discussion: The line is drawn between points X and Y where the
coordinates of X are X1 and X2 and the coordinates of Y are Y1 and Y2.
Admittedly, this is not the traditional naming scheme for the
coordinates of two points that determine a line. Traditionally, a line
would be drawn between points 1 and 2 where each point had an X and Y
coordinate, but  it is merely a matter of naming.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.1 and 4.5

EDITS: None.

SUBMITTED BY: J. C. Adams, 120-JCA-14 (120.014)
HISTORY: 120-JTM-10 (120.057)
         Approved at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000020
TITLE: References to the same derived type by different names
KEYWORDS: derived types, derived type definition
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: How does changing the name by which a derived type is
referenced affect its use? For example, is the code below standard
conforming and, if so, which specific procedure is invoked by the
reference to GEN?

          MODULE MOD
            TYPE T1
              SEQUENCE
              INTEGER I,J
            END TYPE T1
          END MODULE MOD

          USE MOD, T2=>T1

          TYPE (T2) X

          INTERFACE GEN
            SUBROUTINE SPEC1(A1)
              TYPE T1
                SEQUENCE
                INTEGER I,J
              END TYPE T1
              TYPE (T1) A1
            END SUBROUTINE SPEC1

            SUBROUTINE SPEC2(A2)
              TYPE T2
                SEQUENCE
                INTEGER I,J
              END TYPE T2
              TYPE (T2) A2
            END SUBROUTINE SPEC2
          END INTERFACE GEN

          INTERFACE
            SUBROUTINE SPEC3(A3)
              USE MOD
              TYPE (T1) A3
            END SUBROUTINE SPEC3
          END INTERFACE
          ...
          CALL SPEC3(X)
          CALL GEN(X)
          END

ANSWER: Yes, the code is standard conforming. The reference to GEN
should invoke the specific procedure SPEC1.

Discussion: The rules governing these questions are stated in 4.4.2. Two
alternatives are provide for entities to have the same type. The first
alternative applies to the reference to SPEC3:

     Two data entities have the same type if they are declared with
     reference to the same derived-type definition.

In this case, both the actual argument X and the dummy argument A3 are
declared with reference to the type definition T1 in MOD.

The second alternative applies to the analysis of the procedures in
generic interface GEN:

     Data entities in different scoping units also have the same type if
     they are declared with reference to different derived-type
     definitions that have the same name, have the SEQUENCE property,
     and have structure components that do not have PRIVATE
     accessibility and agree in order, name, and attributes.

The type definition in SPEC1 agrees in all these respects with the type
definition in MOD, so X and A1 have the same type. The definition in
SPEC2 has a different name, so X and A2 have different types. Thus the
reference to GEN invokes SPEC1.

Note the fact that type T1 in MOD was accessible using a different name
in the main program was irrelevant in both these analyses.

REFERENCES: ISO/IEC 1539:1991 (E) section 4.4.2

EDITS: None.

SUBMITTED BY: J. C. Adams, 120-JCA-15 (120.015), 120-JLS-5 (120.023)
HISTORY: 120-KWH-1 (120.078)
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000021
TITLE: References to different derived types with the same name
KEYWORDS: derived type definition
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  In the following example, to which type T1 does the FUNCTION
statement refer?

          SUBROUTINE FRED
            TYPE T1
              REAL :: X,Y
            END TYPE
            ...
            CONTAINS
              TYPE (T1) FUNCTION WILMA()
                TYPE T1
                  INTEGER I,J
                END TYPE
                ...
              END FUNCTION WILMA
          END SUBROUTINE FRED

ANSWER: It is the type T1 defined in WILMA.

Discussion: Section 12.1.2.2.1 states:

A name that appears in the scoping unit as (1) a <type-name> in a
<derived-type-stmt> ... is the name of a local entity and any entity of
the host that has this as its nongeneric name is inaccessible.

Therefore, the type T1 defined in FRED is not accessible in WILMA and
cannot be the type referenced in the function statement.

Note that it is impossible to reference WILMA because its type T1 is not
known outside WILMA.  Were the SEQUENCE attribute added to the
definition of T1 and the component types of the two T1 declarations the
same so that the two T1 declarations met the requirements of being the
"same derived types" (4.4.2), then a reference to WILMA would be
possible.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.4.2, 5.3, 12.1.2.2.1,
12.5.2.2

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-1 (120.019)
HISTORY: Originally answered in 120-KWH-2A (120.083A)
         Modification requested by X3J3/92-037 (121-JKR-5)
         Discussed in X3J3/92-049 (121-ADT-9) p7 &
         X3J3/92-050 (121-ADT-10) p4
         Approved as X3J3/92-080 at meeting 121 by a vote of 20-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000022
TITLE: Use of derived type name in host scoping unit
KEYWORDS: derived type, <type-name>, host scoping unit, internal
procedure
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Consider the following code fragment:

          SUBROUTINE HOST
            TYPE T1
              INTEGER I,J
            END TYPE
            ...
            CONTAINS
              FUNCTION CONTAINED ()
                IMPLICIT TYPE (T1) C
                TYPE T1
                  INTEGER I,J
                END TYPE
              END FUNCTION CONTAINED
          END SUBROUTINE HOST

Is it standard conforming to redefine T1 following the IMPLICIT
statement that maps to T1?  Does the fact that the function name begins
with the letter being mapped have any significance in that
determination?  If an argument named C were added to the dummy argument
list of CONTAINED, would that have any effect?

ANSWER: The redefinition is permitted.  The fact that the type of
CONTAINED is implicitly mapped has no significance.  The inclusion of an
argument named C would have no significance in the redefinition of T1,
but would render the program unit nonstandard conforming for other
reasons.

Discussion: Section 12.1.2.2.1 states:

A name that appears in the scoping unit as (1) a <type-name> in a
<derived-type-stmt> ... is the name of a local entity and any entity of
the host that has this as its nongeneric name is inaccessible.

Therefore the type T1 of HOST is inaccessible in the scoping unit of
CONTAINED.

The function statement is part of the scoping unit of CONTAINED since
R1215 says that a function statement is part of its subprogram and it is
not excluded in item (3) of the definition of a scoping unit in section
2.2.

It follows that the type must be the local type.

Note that although this is legal, it is not very useful.  Since the type
of CONTAINED is local to CONTAINED, CONTAINED cannot be referenced.  To
be useful, when the type of a procedure is of  nonsequence derived type,
the derived-type definition must be accessible in the scoping unit of
the procedure by either host association or use association.

If a dummy argument is of nonsequence derived type, this principle is
mandated in 5.1.1.7:

A declaration for a nonsequence derived-type dummy argument must specify
a derived type that is accessed by use association or host association
because the same definition must be used to declare both the actual and
dummy arguments to ensure that both are of the same derived type.  This
restriction does not apply to arguments of sequence type (4.4.2).

If the SEQUENCE attribute were present, and the types were the same as
mandated by 4.4.2, then the program would be legal and the function with
the dummy argument could be referenced in the host.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.2, 4.4.2, 12.1.2.2.1,
12.5.2.2

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) cases 1 and 2
HISTORY: Proposed as 120-RPK-1A (120.092A)
         Questioned by X3J3/92-038 (121-JKR-6)
         Approved as X3J3/92-097 at meeting 121 by a vote of 20-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000023
TITLE: Type of a named constant in an internal procedure
KEYWORDS: named constant, internal procedure, parameter statement, host
DEFECT TYPE: Interpretation
STATUS: subsumed by item 12

NOTE:   THIS ITEM HAS BEEN SUBSUMED BY ITEM 12

QUESTION:  Given that an implicit mapping is established for a letter in
a host scoping unit. An internal procedure of that host scoping unit
contains a PARAMETER statement which defines a named constant whose name
begins with the letter in question. This is followed by an IMPLICIT
statement which defines a different mapping for this letter. Is this
legal?

ANSWER: No.

Discussion: In any scoping unit there is only one (possibly null)
implicit typing map (5.3).  Thus, in the statement (5.2.10),

The named constant must have its type, shape, and any type parameters
specified either by a previous occurrence in a type declaration
statement in the same scoping unit, or by the implicit typing rules
currently in effect for the scoping unit.

the implicit mapping currently in effect for a scoping unit is affected
by all IMPLICIT statements in the scoping unit even those appearing
subsequent to PARAMETER statements. A subsequent IMPLICIT statement may
specify the type of a named constant appearing in a PARAMETER statement,
but in that case, it must confirm the type of the named constant.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.2.10 and 5.3

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) case 3
HISTORY: 120-LJM-5 (120-093)
         Response in X3J3/92-172, must be identical to response to
         NUMBER 000012

--------------------------------------------------------------------------------

NUMBER: 000024
TITLE: IMPLICIT NONE and the type of a  function result
KEYWORDS: IMPLICIT NONE, internal procedure, function result type
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  An internal function contains an IMPLICIT NONE statement and
does not contain a type specification for the function result. Is this
legal?

ANSWER: No.

Discussion: 12.5.2.2 states if the type of the function result is not
explicitly specified:

     ... it is determined by the implicit typing rules in force within
     the function subprogram.

As the null mapping has been specified for all letters within the
internal function, the type of the result must be explicitly specified
within the function.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.2

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) case 4
HISTORY: 120-RPK-3A (120-094A)
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000025
TITLE: Resolution of internal procedure references
KEYWORDS: host, internal procedure, IMPLICIT NONE, procedure references
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  A host scoping unit contains two internal functions, F1 and
F2.  If F1 contains an IMPLICIT NONE and references F2, must F1 contain
an explicit type declaration for F2?

ANSWER: No. In fact if it did contain an explicit type specification for
F2, F1 would be referencing an external function F2 and not the internal
one contained in its host scoping unit.

Discussion: 12.3.1 states:

     If a procedure is accessible in a scoping unit, its interface is
     either explicit or implicit in that scoping unit. The interface of
     an internal procedure ... is always explicit in such a scoping unit.

Therefore, the interface of F2 is explicit in the host scoping unit.

The function F2 is established to be specific in the host scoping unit
by (2)(b) of 14.1.2.4 which states that a procedure name is specific:

     if that scoping unit contains a ... an internal procedure ... with
     that name;

Furthermore, the function name F2 is established to be specific in the
internal procedure F1 by (2)(f) of 14.1.2.4 which states that a name is
specific:

     if that scoping unit contains no declarations of that name, that
     scoping unit is contained in the host scoping unit, and that name is
     established to be specific in the host scoping unit.

As F2 is established to be specific within F1 by the above, 14.1.2.4.2
indicates that the F2 referenced by F1 is to the internal function F2
contained in the host scoping unit.

Note that if F1 contains an explicit declaration for F2, by the rules of
14.1.2.4, F2 is not established to be either generic or specific in F1.
Therefore, to resolve the procedure reference, the rules in 14.1.2.4.3
apply and the reference to F2 within F1 is to an external procedure with
the name F2.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.1, 14.1.2.4, 14.1.2.4.2,
            14.1.2.4.3

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-2 (120.020) case 5
HISTORY: Proposed meeting 120 120-RPK-4 (120-095)
         Questioned X3J3/92-050 (121-ADT-10) page 4
         X3J3 draft response at meeting 121
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000026
TITLE: Bounds of array expressions
KEYWORDS: lower bound, upper bound, array expression
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is it the intent of the standard to state that the lower
bound of an array expression is always 1, and the upper bound is equal
to the number of elements in a given dimension, for all dimensions?
That is, given:

          REAL,TARGET,DIMENSION(5:10) :: A
          REAL,DIMENSION(:),POINTER :: P

          P => A(5:10)
          PRINT *, LBOUND (P)

Does the PRINT statement result in the value 1 being written?  Previous
versions of the draft standard stated that the lower bounds of array
expressions were 1.  Where are those words in the standard?

Reading chapter 7 indicates that an expression may be simply a primary,
and a primary may be an array variable.

Question 1:  Does this mean, given the above declarations that

          P => A
          PRINT *, LBOUND (P)

would also result in the value 1 being written (since A is an array
expression), or should this print the value 5?

Question 2: Is the intent of the standard that given an array with a
declared  lower bound other than one, the following relational
expressions are false?

            REAL,TARGET,DIMENSION(5:10) :: A
            REAL,DIMENSION(:),POINTER :: P1, P2
            INTERFACE
              SUBROUTINE FRED (X, Y)
                REAL,INTENT (IN),DIMENSION(:) :: X, Y
              END SUBROUTINE
            END INTERFACE
            P1 => A
            P2 => A(:)
            PRINT *, LBOUND (A) .EQ. LBOUND (A(:))
            PRINT *, LBOUND (P1).EQ. LBOUND (P2)
            CALL FRED (A, A(:))
          END

          SUBROUTINE FRED (X, Y)
            REAL,INTENT(IN),DIMENSION(:) :: X, Y
            PRINT *, LBOUND (X) .EQ. LBOUND (Y)
          END SUBROUTINE

Question 3:  If the above three PRINT statements result in the values
.FALSE.,  in what cases does the appearance of an array name constitute
an array  (carrying with it its dimension attributes), and in what cases
does it  constitute an expression (implying the lower bound is one)?
That is, in cases where bounds information may be transmitted (pointer
assignment and actual argument association at subprogram calls), does
the appearance of an   array or pointer name *without* a subscript
following cause the bounds of  the array or pointer to be transmitted,
and does the appearance of the same array or pointer name followed by a
subscript triplet with no lower or  upper bound or stride (i.e. (:,:))
constitute an expression with a lower  bound of one transmitted?

In summary:

  (a) What are the bounds of an array pointer which has been pointer
      assigned to an array section?
  (b) What are the bounds of an array pointer which has been pointer
      assigned to a whole array?
  (c) What are the bounds of an assumed-shape array?
  (d) What are the bounds of a pointer dummy argument?

ANSWER: The output of the three example programs would be:
     1) 1
     2) 5
     3) F
        F
        T

  (a) Each lower bound is 1, and each upper bound is the size of the
      corresponding dimension of the array section.
  (b) The declared bounds of the whole array.
  (c) Each lower bound is the declared lower bound of the assumed-shape
      corresponding dimension of the array section plus the lower bound
      minus one.
  (d) The bounds of the target associated with the pointer actual
      argument.

Discussion: Cases (a) and (b) are determined from the statements
(5.1.2.4.3),

     ...The lower bound of each dimension is the result of the LBOUND
     function (13.13.52) applied to the corresponding dimension of the
     target.  The upper bound of each dimension is the result of the
     UBOUND function (13.13.111) applied to the corresponding dimension
     of the target.

Case (c) is described in section 5.1.2.4.2.

Case (d) is determined from these statements in conjunction with the
statement, "If the actual argument is currently associated, the dummy
argument becomes associated with the same target" (12.4.1.1).

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1.2.4.2, 5.1.2.4.3,
            12.4.1.1, 13.13.52, & 13.13.111

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-3 (120.021)
HISTORY: 120-LJM-4A (120.088A)
         Approved at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000027
TITLE: Requirements for pointers and target association
KEYWORDS: POINTER attribute, TARGET attribute, pointer association
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: If PTR has the POINTER attribute and TGT has the TARGET or
POINTER attribute, under which of the following other conditions are PTR
and TGT considered to be pointer associated, i.e., under which of the
following conditions does ASSOCIATED(PTR, TGT) return a value of .TRUE.:

   a) PTR and TGT have different types?
   b) PTR and TGT have different type parameters?
   c) PTR and TGT have different ranks?
   d) PTR and TGT have different sizes?
   e) PTR and TGT have different shapes?
   f) PTR and TGT have different bounds?
   g) PTR and TGT refer to the same set of array elements/storage units,
      but not in the same array element order?
   h) PTR and TGT have array elements/storage units whose range of
      memory addresses overlap, but they have no identical array
      elements/storage units?
   i) PTR and TGT have at least one but not all identical array
      elements/storage units and all the identical elements have the
      same subscript order value in both PTR and TGT?
   j) PTR and TGT have at least one but not all identical array
elements/storage units but
       not all the identical elements have the same subscript order
value in both PTR and
       TGT?

ANSWER: Except under conditions where the value of ASSOCIATED is
undefined, any of the above conditions except for f) are sufficient for
ASSOCIATED (PTR, TGT) to return a value of .false..  In determining
whether a pointer and a target are associated, the bounds are not
relevant, but the extents are.  The extents of each dimension of PTR and
TGT must be the same, thus their shapes must match which is covered by
condition (e).

Discussion: There are only three means by which a pointer may become
pointer associated: via the ALLOCATE statement (6.3.1), via pointer
assignment (7.5.2), or via argument association (12.4.1.1).  In an
ALLOCATE statement, the object created inherits its type, type
parameters, rank, shape, size and bounds from those declared for, or
specified with, the pointer name.  In a pointer assignment, the type,
type parameters, and rank of the pointer and target must conform, and
the shape and size of the target determine those of the pointer.  When a
pointer actual argument is passed to a pointer dummy argument, the
pointer dummy argument becomes pointer associated with the same target
as the pointer actual argument.  In all three of these cases, array
elements of the pointer and the target correspond with one another in
array element order.  Thus, since there is no other way for two objects
to become pointer associated, all these properties must be the same.

The result of the two-argument form of ASSOCIATED is undefined if either
argument is a pointer that is currently associated with a target that is
zero sized, or the second argument is not a pointer but is zero sized.

Note that other forms of association (name association and storage
association) are distinct from, and orthogonal to, pointer association
(14.6).

REFERENCES: ISO/IEC 1539:1991 (E) 5.1.2.4.3, 6.3.1, 7.5.2, 12.4.1.1, &
14.6

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-4 (120.022)
LAST SIGNIFICANT CHANGE: 1993-02-12	000027
HISTORY: 120-LJM-3A (120.081A)
	 Original response proposed at meeting 121
	 Questioned in X3J3/92-061 (121-ADT-9) p9 & X3J3/92-061
         (121-ADT-13)  item 27
	 Approved as X3J3/92-093A at meeting 121
	 Approval rescinded at meeting 123 (uc)
	 Revised response in X3J3/93-099r1 adopted at meeting 124 by a
         vote of (15-2)

--------------------------------------------------------------------------------

NUMBER: 000028
TITLE: Precedence of use or host association
KEYWORDS: use association, host association
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  Is an implicitly typed entity with the same name as a host or
use associated entity a reference to a local entity or the host or use
associated entity?

ANSWER: It is a reference to the host or use associated entity. 5.3, in
the fourth paragraph beginning "Any data entity ...", states that use or
host association takes precedence over implicit typing.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.3

EDITS: None.

SUBMITTED BY: J. L. Steidel, 120-JLS-6 (120.024))
HISTORY: 120-RL-3 (120.060)

--------------------------------------------------------------------------------

NUMBER: 000029
TITLE: Class of a defined operator
KEYWORDS: defined operator, generic identifier, classes of local
entities
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is a defined operator name a generic identifier?  Thus is it
illegal for a defined operator name to be the same as another class 1
entity within the same scoping unit (as defined in 14.1.2)?

ANSWER: No.  The word 'name' is used in a technical way throughout the
standard. It is defined by R304 on page 19 and is not used in the
definition of defined-operator by R311, R704, R724 on page 21. A defined
operator is a generic identifier (see page 168, lines 12 and 11 from the
bottom), but it does not have a name.  Therefore the rule in 14.1.2 does
not apply. This is analogous to the situation for intrinsic operators,
where it is permissible to have local variables named AND, OR, etc.

REFERENCES: ISO/IEC 1539:1991 (E) sections 3.2.2, 3.2.4, 12.3.2.1,
14.1.2

EDIT:  None.

SUBMITTED BY: J. L. Steidel, 120-JLS-7 (120.025)
HISTORY: 120-RL-2A (120.059A)
         121-LRR-8 Opposed to 121-JKR-2
         121-JKR-2 Opposed to S20/29 (120-59a)
         X3J3/92-106 Interpretation based on 121-JKR-2
         Approved as X3J3/92-148A at meeting 122 by unanimous consent
         Approved as X3J3/92-252 by unanimous consent at meeting 124

--------------------------------------------------------------------------------

NUMBER: 000030
TITLE: Length of character literals in array constructors
KEYWORDS: array constructor, character literal, character length,
substring
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Consider the following example:

          CHARACTER :: NAMES  (3) * 20
          NAMES = (/  'TOM', 'DICK', 'HARRY'  /)

This appears to be invalid due to a constraint in section 4.5,
"Construction of array values":

Constraint: Each <ac-value> expression in the <array-constructor> must
have the same type and type parameters.

The length of the string is a type parameter.  Thus the array
constructor sample above is invalid because the strings have different
lengths.

Consider another example:

          CALL SUB ( (/  'TOM', 'DICK', 'HARRY'  /) )
          ...
          SUBROUTINE SUB (NAMES)
            CHARACTER :: NAMES(:) * (*)
            WRITE(*,*) LEN(NAMES)
            ...

This also appears invalid.

 1. Must each character string literal constant in an array constructor
    be the same length?

 2. If the answer to 1 is "No", what values are printed by the second
    example?

 3. If the answer to 1 is "Yes", another question arises.  The syntax of
    an array constructor is described in section 4.5.  In rule R432, ac-
    value is defined to be an expr or an ac-implied-do.  Since an ac-value
    may be an expression, a substring is a valid ac-value.  Therefore each
    substring in an array constructor must have the same length and that
    length must be the same as the length of every other ac-value in the
    constructor.  But a substring can contain nonconstant expressions as
    the starting point and ending point, or the starting point and ending
    point can be omitted (signaling the use of a default value).  Since a
    substring can contain nonconstant starting and ending points, the
    constraint cited above cannot be detected at compile time and thus
    cannot be a constraint.  Should this restriction be rephrased as prose
    in the text of the standard?

ANSWER: The answer to question 1. is yes.  Each character literal
constant in an array constructor must be the same length.  Both examples
are nonstandard conforming.  The answer to question 3. is yes.  The
following edits move the equal-length requirement from a constraint to
prose in the text.

Discussion: The awkwardness resulting from the requirement that each ac-
value be the same length was noted by X3J3, but the committee could not
reach agreement on an acceptable way to allow character literal
constants of differing lengths in an array constructor.  Since the
length cannot always be determined at compile time, the constraint must
be changed to prose.

REFERENCES: ISO/IEC 1539:1991 (E) section 4.5

EDITS:  Delete the second constraint following R435.  Add the following
paragraph after the constraints in 4.5.

Each <ac-value> expression in the <array-constructor> must have the same
type and type parameters.

SUBMITTED BY: (Questions 1 and 2) L. R. Rolison in 120-LRR-1 (120.026)
	      (Question 3) L. R. Rolison in X3J3/93-070
LAST SIGNIFICANT CHANGE:  1993-02-11	000030
HISTORY: Response to Questions 1 and 2 - 120-LJO-1 (120.074)
	 Question 3. submitted as X3J3/93-070 at meeting 124
	 Complete proposed response in X3J3/93-100 adopted at meeting 124
         by unanimous consent

--------------------------------------------------------------------------------

 NUMBER: 000031
 TITLE: Overloaded implied-DO variable names
 KEYWORD: implied-Do variable, DATA statement
 DEFECT TYPE: Erratum
 STATUS: X3J3 approved; ready for WG5

 QUESTION: Section 14.1.3. states:

The name of the variable that appears as the DO variable of an implied-
DO in a DATA statement or an array constructor has a scope of the
implied-DO list.  It has the type and type parameter that it would have
if it were the name of a variable in the scoping unit that includes the
DATA statement or array constructor and this type must be integer.

Is the following in error since J has type character and therefore does
not have type integer?

       CHARACTER J
       INTEGER A(10)
       DATA (A(J), J=1,10) /10*5/

Is the following valid because, although J is a named constant, it has
type integer?

       INTEGER J
       PARAMETER (J=5)
       INTEGER A(10)
       DATA (A(J), J=1,10) /10*5/

 Is the following valid?

       TYPE (ITYPE)
         CHARACTER FIELD1
         INTEGER   FIELD2
       END TYPE
       INTEGER A(10)
       DATA (A(ITYPE), ITYPE=1,10) /10*5/

If ITYPE were a variable it would have type integer and this would be
valid.  Does the fact that it is the name of a derived type cause a
conflict?

 The second sentence cited above appears to allow

       EXTERNAL J
       INTEGER A(10)
       DATA (A(J), J=1,10) /10*5/

The EXTERNAL statement declares J to be a global name.  If J is a
subroutine it has no type, so the presence of the EXTERNAL statement is
irrelevant.  If J were a function, then it must be type integer for the
presence of J in the DATA statement to be valid.

Question 1:  Is the Fortran 90 standard intentionally extending the
FORTRAN 77 standard with respect to implied-DO variables in DATA
statements?  Did the Fortran 90 standard intentionally delete the
material about COMMON block names in section 18.2.7 of X3.9-1978?

Question 2:  Are the conclusions and interpretations above correct or
incorrect?  If incorrect, for what specific reasons are they incorrect?

Question 3:  Are the examples above standard conforming program
fragments?  If not, what are the specific reasons?

Question 4:  Are the rules for implied-DO variables in DATA statements
and array constructors the same?  If they are not exactly the same,
provide examples which illustrate the differences.

ANSWER: It was intended that the rules for implied-DO variables be
similar to those in X3.9-1978.  An edit to section 14.1.3 of ISO/IEC
1539:1991 clarifies these rules.

The answers to your questions are:

  1. Fortran 90 extended the rules for implied-DO variables in DATA
     statements in two ways:

     a) The type of an implied-DO variable must be integer but need not
        be default integer.

     b) FORTRAN 77 allowed the name of the statement entity also to be
        the name of a (scalar) variable or COMMON block (X3.9-1978,
        section 18.2.7) in (i.e. appearing in) the program unit containing
        the DATA statement or statement function statement.  Fortran 90
        allows the name of the statement entity also to be the name of a
        scalar variable or COMMON block appearing in or accessible from
        the enclosing scope (section 14.1.3 of ISO/IEC 1539-1991,
        with the changes in the EDITS section, below).

  2. The detailing of the conclusions and justifications given below in
     (3) answer this.

  3. The first example is in error because J is of type character and
     R537 requires integer type.

     The second example is in error.  J is of type integer as required by
     R537, but the edit to section 14.1.3 prohibits the name of a
     statement entity also being the name of a constant in the same
     scoping unit.

     The third example is in error.  The edit to section 14.1.3 prohibits
     the name of a of a statement entity also being the name of a derived
     type.

     The fourth example is in error.  The edit to section 14.1.3 prohibits
     the name of a statement entity also being the name of an external
     function or subroutine.

  4. The rules for implied-DO variables in DATA statements and in array
     constructors, with respect to typing and scope, are the same.

REFERENCES: ISO/IEC 1539:1991, sections 5.2.9, 6.2.1, 14.1.2, 14.1.3.
            X3.9-1978, section 18.2.7

EDIT: Replace the last paragraph of section 14.1.3 with the following
two paragraphs:

     Except for a common block name or a scalar variable name, a name that
     identifies a global entity or local entity of class 1 (14.1.2)
     accessible in the scoping unit of a statement must not be the name of
     a statement entity of that statement.  Within the scope of a
     statement entity, another statement entity must not have the same
     name.

     If the name of a global or local entity accessible in the scoping
     unit of a statement is the same as the name of a statement entity in
     that statement, the name is interpreted within the scope of the
     statement entity as that of the statement entity.  Elsewhere in the
     scoping unit, including parts of the statement outside the scope of
     the statement entity, the name is interpreted as that of the global
     or local entity.

SUBMITTED BY: L. R. ROLISON, 120-LRR-2 (120.027)
LAST SIGNIFICANT CHANGE: 92-11-10, new response 	000031
HISTORY: 1st response - 120-RRR-1A (92.069a) -- all prohibited
         Griffiths' complaint (92.49, p. 11ff)
         2nd response (92.112) -- all allowed
         Email discussion (92.132, #4, 5, 32, 33, 38, 39, 49)
         WG5 suggests F77 restrictions (92.136, N815-7)
         3rd response (92.167a) drafted by DATA subgroup at
         meeting 122; final action deferred due to 2 week rule
         Improved edits suggested by Janice Shepherd (private
         communication)
         4th response (92-229b) approved at meeting 123 (22-1)

--------------------------------------------------------------------------------

NUMBER: 000032
TITLE: Implicit declaration of a derived type
KEYWORDS: derived type, IMPLICIT statement
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: Is the following program standard conforming?

          IMPLICIT TYPE(T1) (A-D)   ! Note IMPLICIT range is A-D.
          TYPE T1
            SEQUENCE
            CHARACTER*10 NAME
            INTEGER EMP_NUMBER
          END TYPE T1
          A1%NAME='FRED'    ! A1 is implicitly declared to be of type T1
          ...
          CONTAINS
            SUBROUTINE INNER
              IMPLICIT TYPE(T1) (D) ! D now overrides IMPLICIT for D in
                                    !host
              TYPE T1
                INTEGER WIDTH
                INTEGER HEIGHT
              END TYPE T1
              D%WIDTH = 10            ! No problem here, D is implicitly
                                      ! declared with the T1 that is
                                      ! defined in INNER.
              CALL OUTSIDE(C)         ! Is this an error?
              ...

Is a reference to A1 (declared in the host) from inside INNER permitted
in this example?

ANSWER: Yes, the example is standard conforming.

Discussion: Components of A1 can also be referred to from inside INNER.
While the derived type T1 from the host scoping unit is inaccessible
inside the internal routine INNER, there is no reason why data entities
of this derived type that are accessible cannot be referred to.  The
implicit mapping for the letter C is not specified within the internal
routine INNER.  So, the implicit mapping is that of the host routine.
In the host routine the letter C is mapped to derived type T1 of the
host.  Therefore the variable C is implicitly declared to be of type T1
from the host.  The components of the variable C, C%NAME and
C%EMP_NUMBER, can also be referred to in INNER.  The following edits
clarify the standard with regard to these questions.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.1.1.7, 5.3, 12.1.2.2.1

EDITS:

  1. In the first paragraph of 5.1.1.7, change "is specified" to "is
     explicitly declared".
  2. In paragraph 5 of 5.3 after "provided the mapping is not null.",
     insert the new sentence: "Note that the mapping can be to a derived
     type that is inaccessible in the local scope if the derived type is
     accessible to the host scope."
  3. In paragraph 3 of 12.1.2.2.1 after "prior to the DATA statement.",
     insert a new paragraph:

     "If a derived type name of a host is inaccessible, data entities of
      that type or subobjects of such data entities still can be
      accessible."

SUBMITTED BY: L. R. Rolison, 120-LRR-5 (120.030)
LAST SIGNIFICANT CHANGE: 1992 11 10, revised content	000032
HISTORY: 120-TMRE-2 (120.075)
         Questioned by 92-035, 92-049(p14), 92-050(p4)
         Revised at meeting 121 but rejected
         Revised response proposed in 92-280,
         approved by unanimous consent at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000033
TITLE: Interface blocks with the same name in a program
KEYWORDS: generic interface blocks, module, USE statement
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:

Question 1: In the following program, both interface blocks  have the
same generic name and thus might be considered to be merged  into a
single generic interface block. Is function F1 (from  module MOD_1)
accessible to the program but function F2 (from  module MOD_2) hidden?

          MODULE MOD_1
            PUBLIC INT_1
              INTERFACE INT_1               ! Generic interface - PUBLIC.
               INTEGER FUNCTION F1(K)
                INTEGER K
              END FUNCTION
            END INTERFACE
            ...
          END MODULE MOD_1

          MODULE MOD_2
            PRIVATE INT_1
            INTERFACE INT_1       ! Generic interface, same name - PRIVATE
              INTEGER FUNCTION F2(L)
                LOGICAL L
              END FUNCTION
            END INTERFACE
          ...
          END MODULE MOD_2

          PROGRAM EXAMPLE_1
            USE MOD_1; USE MOD_2      ! Program accesses both modules.
            ...
          END

Question 2: If the following module is added to the above example and
the USE statement in the main program is changed to "USE MOD_1; USE
MOD_2; USE MOD_3", is the resulting program standard  conforming?

          MODULE MOD_3
            PUBLIC INT_1
            INTERFACE INT_1     ! Generic interface, same name - PUBLIC.
              INTEGER FUNCTION F3(L)
                LOGICAL L
              END FUNCTION
            END INTERFACE
            ...
          END MODULE MOD_3

Question 3: If the program and modules shown above are altered so that
module MOD_2 USEs MOD_1 and the program EXAMPLE_1 only  USEs MOD_2
directly, is this an example of a standard conforming  program? If it is
standard conforming, does the program have access to  function F1 but
not F2?

ANSWER 1: No. Function F2 is still accessible but only by its specific
name.

ANSWER 2: Yes, but not for the reason implied by the question.

ANSWER 3: Yes, the program is standard conforming.

Discussion: Because the name INT_1 is private in the module MOD_2, the
interface for the function F2 is accessible in the program EXAMPLE_1,
but NOT the generic name INT_1. Therefore, the two interface blocks are
NOT merged into a single generic interface block.

The function F1 is, therefore, accessible in the program EXAMPLE_1 by
either its specific name F1 or the generic name INT_1; the function F2,
on the other hand is accessible only by its specific name F2.

This shows that the function F2 (from module MOD_2) does not share  the
same generic name, INT_1, as the function F1 (from module MOD_1).

When the example is modified as specified by Question 2, the new module
MOD_3 defines a new interface block INT_1, which will be combined with
the identically named interface block from module MOD_1.  In the program
EXAMPLE_1 the generic name INT_1 has the two specific names F1 and F3.
However, since F2 is not part of the combined generic interface block
the fact that F2 and F3 have the same dummy argument and  result
characteristics is of no significance, and the program is standard
conforming.

When the example is modified as specified by Question 3, within module
MOD_2 the two generic interface blocks are combined into a single
interface block. However, since INT_1 is declared to be private within
module MOD_2 only the specific names of the functions F1 and F2 are
accessible to program units using MOD_2.

Therefore, both the function F1 and F2 are accessible within the program
EXAMPLE_1, but only by their specific names.


REFERENCES: ISO/IEC 1539:1991 (E) sections 5.2.3, 11.3.2

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-6 (120.031)
HISTORY: 120-TMRE-3 (120.076)
         Included into S20 as three items (33-35).  Recombined in 92-308.
         Revised in response to ballot comments in 93-082.
         Approved by unanimous consent at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000034
TITLE: Interface blocks with the same name in a program - II
KEYWORDS: generic interface blocks, module, USE statement
DEFECT TYPE: Interpretation
STATUS: subsumed by item 33

QUESTION:  If the following module is added to the example given in
NUMBER 000033, and the USE statement in the main program is changed to
"USE MOD_1, MOD_2, MOD_3", is the resulting program standard
conforming?

          MODULE MOD_3
            PUBLIC INT_1
            INTERFACE INT_1     ! Generic interface, same name - PUBLIC.
              INTEGER FUNCTION F3(L)
                LOGICAL L
              END FUNCTION
            END INTERFACE
            ...
          END MODULE MOD_3

ANSWER: Yes, but not for the reason implied by the question.

Discussion: The answer in NUMBER 000033 shows that the function F2 (from
MODULE MOD_2) does not share the same generic name, INT_1, as the
function F1 (from MODULE MOD_1).

The new module MOD_3 defines a new interface block INT_1, which will be
combined with the identically named interface block from module MOD_1.
In the program EXAMPLE_1 the generic name INT_1 has the two specific
names F1 and F3. However, since F2 is not part of the combined generic
interface block the fact that F2 and F3 have the same dummy argument and
result characteristics is of no significance, and the program is
standard conforming.

REFERENCES:

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-6 (120.031) Part 2
HISTORY: 120-TMRE-3 (120.076)

--------------------------------------------------------------------------------

NUMBER: 000035
TITLE: Interface blocks with the same name in a program - III
KEYWORDS: generic interface block, module, USE statement
DEFECT TYPE: Interpretation
STATUS: subsumed by item 33

QUESTION:  If the program and modules shown in NUMBER 000033 are altered
so that module MOD_2 USEs MOD_1 and the program EXAMPLE_1 only USEs
MOD_2 directly, is this an example of a standard conforming program? If
it is standard conforming, does the program have access to function F1
but not F2?

ANSWER: Yes, the program is standard conforming.

Discussion: Within module MOD_2 the two generic interface blocks are
combined into a single interface block. However, since INT_1 is declared
to be private within module MOD_2 only the specific names of the
functions F1 and F2 are accessible to program units using MOD_2 (c.f.
NUMBER 000033).

Therefore, both the function F1 and F2 are accessible within the program
EXAMPLE_1, but only by their specific names.

REFERENCES:

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-6 (120.031) Part 3
HISTORY: 120-TMRE-3 (120.076)

--------------------------------------------------------------------------------

NUMBER: 000036
TITLE: Pointer to an assumed-size array
KEYWORDS: pointer, assumed-size array, pointer assignment statement
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is a pointer assignment statement of the form:

          PTR => A

where A is an assumed-size array, standard conforming?

ANSWER: No.  This is prohibited by section 6.2.1, second paragraph,
second sentence.

REFERENCES: ISO/IEC 1539:1991 (E) section 6.2.1

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-7 (120.032)
HISTORY: 120-RRR-2A (120.087A)
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000037
TITLE: Use of array sections in pointer assignment statements
KEYWORDS: pointer assignment statement, array sections, pointer
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: If A is an assumed-size array:

   Is "PTR => A(:N)" standard conforming?
   Are "PTR => A(:)" and "PTR => A(N:)" standard conforming?

ANSWER: "PTR => A(:N)" is standard conforming because A(:N) is a valid
array section.

Forms "PTR => A(:)" and "PTR => A(N:)" are not standard conforming
because the array sections are prohibited by the second constraint after
R621.

REFERENCES: ISO/IEC 1539:1991 (E) section 6.2.2

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-7 (120.032)
HISTORY: 120-RRR-2A (120.087A)
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000038
TITLE: Same interface body in multiple generic interface blocks
KEYWORDS: interface body, generic interface blocks, scoping unit
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:

Part 1. Is the following example standard conforming? That is, can the
same interface body exist in multiple generic interface blocks that are
all accessible from a single scoping unit?

         MODULE MOD_1
           INTERFACE RED
              SUBROUTINE CMN(K)
                INTEGER K
              END SUBROUTINE
              SUBROUTINE S(X)
                REAL X
              END SUBROUTINE
            END INTERFACE
          END MODULE

          MODULE MOD_2
            INTERFACE BLUE
              SUBROUTINE SS(Y)
                REAL Y
              END SUBROUTINE
              SUBROUTINE CMN(K)
                INTEGER K
              END SUBROUTINE
            END INTERFACE
          END MODULE

          PROGRAM EXAMPLE_1
            USE MOD_1;  USE MOD_2
            INTEGER M
            ...
            CALL RED(M)
            ...
            CALL BLUE(M)
            ...
          END PROGRAM

Part 2. If the names are removed from the interface blocks in both
modules, thus making them nongeneric, and the subroutine calls in
program EXAMPLE_1 replaced by "CALL CMN(M)", is the resulting program
standard conforming? That is, may a procedure interface description
occur in multiple nongeneric interface blocks that are accessible to a
given scoping unit and may the program unit reference that procedure?

ANSWER:

Part 1. No. The example is not standard conforming.
Part 2. No.

Discussion: The last sentence of the second paragraph of 12.3.2.1 states

A procedure must not have more than one explicit specific interface in a
given scoping unit.

In the example the subroutine CMN has two specific interfaces, one from
each module in the program EXAMPLE_1 which is forbidden.

The program could be made standard conforming by making the name CMN
private in one or both modules or by adding a rename or only option to
one of the USE statements.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.2.1

EDITS: None.

SUBMITTED BY: L. R. Rolison, 120-LRR-8 (120.033)
HISTORY: Original interpretation in 120-TMRE-4 (120.077)
         Questioned in X3J3/92-131
         Approved as X3J3/92-174 at meeting 122 by unanimous consent
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000039
TITLE: Association of a pointer actual argument with a dummy argument
KEYWORDS: pointer, actual argument, dummy argument, argument association
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: When a pointer is passed as an actual argument, is the intent
of the standard as follows:  Dereferencing of the pointer is dependent
on the interface of the called procedure. That is, if the dummy argument
is known to be a pointer (with matching type, etc.)  then the pointer
actual argument is NOT dereferenced - the pointer itself is passed.
Conversely, if the dummy argument is unknown or is known to not be a
pointer then the pointer dummy argument is dereferenced so that its
target is passed (possibly through a temporary)?  If yes, please quote
the text that specifies the meaning of passing a pointer as an actual
argument.

ANSWER: Section 5.1.2.4.3 indicates that a pointer actual argument may
be associated with either a pointer dummy argument or a nonpointer dummy
argument.  The semantics of a pointer actual argument associated with a
pointer dummy argument are specified in section 12.4.1.1.  When a
pointer actual argument is associated with a nonpointer dummy argument,
the actual argument's associated target object becomes associated with
the dummy argument.  Section 7.1.4.1 states

If a pointer appears as a primary in an intrinsic operation or a defined
operation in which it corresponds to a nonpointer dummy argument, the
associated target object is referenced.

Discussion: The standard does not specify implementation details.  A
valid implementation would allow passing a descriptor when a pointer
actual argument is associated with a pointer dummy argument and a
temporary when the dummy argument is a nonpointer.  Another valid
implementation would be to pass a descriptor in both cases.  Since the
notion of referencing and dereferencing pointers is implementation
dependent, the standard does not use these terms when discussing
pointers and targets.

The standard does state when a pointer's association status may change
(pointer assignment, allocation, deallocation, nullification, and
association with a dummy argument which is a pointer) and several cases
where a pointer name refers to the associated target object (assignment
as primary in an expression, and an I/O list). There is also an example
of a pointer actual argument associated with a nonpointer dummy argument
in section 12.5.2.9.

The corrections indicated below clarify the rules and meaning of
associating a pointer actual argument with a nonpointer dummy argument.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1.2.4.3, 7.1.41, 7.5.1.5,
            9.4.4.4, 12.4.1.1, & 12.5.2.9

EDITS:

   1. Delete the penultimate (tenth) paragraph of 5.1.2.4.3, "A pointer
      dummy argument ... argument." [46:41-42]

   2. Add the following new paragraph following the current fifth
      paragraph of section 12.4.1.1: [173:13+]

      If the dummy argument is not a pointer and the corresponding actual
      argument is, the actual argument must be currently associated with a
      target and the dummy argument becomes argument associated with that
      target.

SUBMITTED BY: L. R. Rolison, 120-LRR-9 (120.034)
LAST SIGNIFICANT CHANGE:  1993-02-12	000039
HISTORY: 120-JLS-9 (120.079)
	 Passed letter ballot to move to "Ready for WG5" status
	 Revised response in 93-102 adopted at meeting 124 by unanimous
         consent

--------------------------------------------------------------------------------

NUMBER: 000040
TITLE: Allocation of arrays of pointers
KEYWORDS: arrays, pointer allocation, structures
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Consider the following code fragment:

          TYPE DEF
            INTEGER I
            INTEGER, POINTER :: PTR
          END TYPE

          TYPE (DEF) :: STRUCT (5)
          ...
          ALLOCATE (STRUCT%PTR)

Are the following quotations from the standard sufficient to declare
this code fragment to be nonstandard-conforming?

The constraint immediately following R628 "Each <allocate-object> must
be a pointer or an allocatable array."

The second sentence of the fourth constraint after R613 "A <part-name>
to the right of a <part-ref> with nonzero rank must not have the POINTER
attribute."

ANSWER: The ALLOCATE statement in the example is not permitted by the
syntax rules and constraints of the standard:

  R625 <allocate-object>     is <variable-name>
                             or <structure-component>

  R614 <structure-component> is <data-ref>

  R612 <data-ref>            is <part-ref>[%<part-ref>]...

  R613 <part-ref>            is <part-name>[(<section-subscript-list>)]

Constraint:  A <part-name> to the right of a <part-ref> with nonzero
rank must not have the POINTER attribute.

REFERENCES: ISO/IEC 1539:1991 (E) sections 6.1.2 and 6.3.1

EDITS: None.

SUBMITTED BY: Larry Rolison, X3J3/92-056
HISTORY: Approved as X3J3/92-069 at meeting 121
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000041
TITLE: Procedure with target dummy argument requires explicit interface
KEYWORDS: dummy argument, explicit interface, TARGET attribute
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: If a procedure has a dummy argument that has the TARGET
attribute, it must have an explicit interface (section 12.3.1.1).  The
TARGET attribute is defined solely for the purpose of aiding
optimization (C.5.3).  Why must such a procedure have an explicit
interface?

ANSWER: Section C.5.3 is in error by stating the TARGET attribute is
solely to aid optimization.  It is true that requiring an explicit
interface for a procedure with a dummy argument that has the TARGET
attribute aids optimization of the subprogram that calls the procedure.
Such an explicit interface also allows a processor to diagnose when an
actual argument which does not have the TARGET attribute becomes
associated with a dummy argument that has the TARGET attribute.  The
supplied edit corrects the error.

Discussion: Section 6.3.3.2 states that upon execution of a RETURN or
END statement, some pointers declared or accessed in the procedure
retain their association status.  For example, if a pointer is
accessible to both the subprogram which references the procedure and the
referenced procedure, or if the  procedure is a function whose result
has the POINTER attribute, such a pointer cannot become associated with
an actual argument during execution of the procedure if the target
actual argument becomes associated with a  nontarget dummy argument.  If
a procedure does not have an explicit  interface, a processor may assume
any actual argument with the target  attribute cannot become associated
with such a pointer during execution of the procedure.  Requiring an
explicit interface for a procedure with a  target dummy argument also
allows the processor to diagnose association of a nontarget actual
argument, such as an expression, with the target dummy argument.

Note that edits in defect item 125 make the need for the explicit
interface mandatory.

REFERENCES: ISO/IEC 1539:1991 sections 6.3.3.2, 12.3.1.1, and C.5.3

EDIT:  Section C.5.3, second sentence, change "solely" to "primarily".

SUBMITTED BY: K. Kazumura, X3J3/92-048 (121-ADT-8) page 23
LAST SIGNIFICANT CHANGE: 1993-02-12	000041
HISTORY: Posted request to f90 interp e-mail
         Approved as X3J3/92-070 meeting 121
         Approval rescinded at meeting 123 (uc)
	 Revised response in X3J3/93-101 adopted at meeting 124 by
         unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000042
TITLE: KIND parameter value
KEYWORDS: kind parameter value, representation of constants
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  It is stated in section 5.1.1.2 that:

An entity declared with type specifier REAL(KIND(0.0)) is of the same
kind as one declared with the type specifier REAL.

There are similar statements about INTEGER, DOUBLE PRECISION, and
COMPLEX type specifiers in sections 5.1.1.1, 5.1.1.3, and 5.1.1.4.

In section 5.1.1.2, for example, must the constant be exactly the
characters "0.0" to cause the declared entity to be the same as the
default real entity?  Could the result be different if the constant were
expressed, for example, as "0."?

It appears that the committee chose the value 0 in these statements
because it exists on every machine on which a Fortran 90 processor will
be run.  Further, a specific value was chosen so that machine
architecture differences would be factored out.  For example,
KIND(10000000.) might have the same kind parameter value as default real
on one machine but not on another.

ANSWER: No, the constant need not be exactly "0.0".  The constant "0.0"
is used only as an example.

Discussion: The KIND intrinsic is defined in section 13.13.51 of the
standard to return a value equal to the kind type parameter of its
argument; the argument may be of any intrinsic type.  In section 13.5.5
it is stated that the value of the argument to this function need not be
defined.  It is only the kind type of the argument that is relevant.
Nowhere in the standard is there a restriction that the argument to the
KIND intrinsic be a constant at all, much less the specific constant
0.0.  The <kind-selector> is specified in section 5.1, R505 to be a
<scalar-int-initialization-expr>.  The definition of an <initialization-
expression> is given in section 7.1.6.1, and the restrictions on the
argument of the KIND intrinsic in an <initialization-expression> are
detailed in item (6) of that definition.

The question makes the assertion that KIND(10000000.) might not have the
same kind parameter value as default real on all machines.  This
assertion is false.  Possibly the requestor believed that a literal real
constant could assume a kind parameter value based on the number of
digits in the constant or some other implicit criterion.  This is not
allowed in Fortran 90.  In section 4.3.1.2, it is explicitly stated
that:

A literal real constant without a kind type parameter is a default real
constant if it is without an exponent part..."

Similar arguments apply to the corresponding questions about INTEGER,
DOUBLE PRECISION, and COMPLEX type specifiers.

REFERENCES: ISO/IEC 1539:1991, sections 4.3.1.2, 5.1, 5.1.1, 7.1.6.1,
            13.5.5, 13.13.51

EDITS: None.

SUBMITTED BY: L.R.Rolison, X3J3/92-060
HISTORY: Approved as X3J3/92-084 at meeting 121 by a vote of 19-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000043
TITLE: List-directed character input
KEYWORDS: list-directed, input, character, zero length, null value
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  For list directed input of character items, how does the
standard distinguish between the input of an undelimited zero-length
character string and a null value?  If the input is a zero-length
character string, the corresponding list item must be set to blank,
whereas if the input is a null value, the definition status of the
corresponding list item must be left unchanged.  However, there appears
to be no way to distinguish these two possibilities.

ANSWER: The ambiguity between undelimited zero length character values
and the null value should be resolved by requiring that zero-length
character values always be delimited in list-directed input.

Discussion: Several other potential ambiguities with undelimited
character items in list-directed input were resolved in section 10.8.1
by requiring delimiters in those cases.  However, the case of a zero-
length string was  omitted from this list.

EDITS: The following changes should be made to section 10.8.1,

   1. Add " and" to the end of item (4), and

   2. Add an additional item to the list after item (4):

     "(5)  The character constant contains at least one character,"

REFERENCES: ISO/IEC 1539:1991, sections 10.8.1, 10.8.1.1

SUBMITTED BY: Richard E. Maine, X3J3/92-087
HISTORY: Approved as X3J3/92-116 at meeting 121 by a vote of 19-0
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000044
TITLE: END statement and fixed form source
KEYWORDS: end statement, fixed form source, initial line
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Consider the following:

   1. Section 3.3.2.4 "Fixed Form Statements", page 24, requires that no
statement, except the program unit END statement, have an initial line
that appears to be a program unit END statement.

   2. Other statements, for example, <end-function-statement>, R1218
page 175, may consist of only the keywords "END" or "END FUNCTION".

While these do not conflict, the combined requirements are not obvious
and complicate the situation for users.  Consider, for example, ending
an <interface-body> for a function subprogram:

    1.     END             ! wrong, appears to be a program unit END

    2.     EN              ! END continued to 2nd line. OK
         & D

    3.     END FUNCTION   ! OK in main PROGRAM unit and SUBROUTINE
                          ! subprogram, wrong in FUNCTION subprogram

    4.     EN             ! OK
         & D FUNCTION

    5.     END F          ! OK


    6.     END FUNCTION A ! OK in main program, OK in SUBROUTINE
         &       BC       !subprogram, OK in function if name is not "A"

ANSWER: Section 3.3.2.4 was brought forward from FORTRAN 77 without
modification for new Fortran 90 constructs.  The resulting usability
characteristics, as seen in the examples above, are regrettable enough
that a repair should be made.

REFERENCES: ISO/IEC 1539:1991 (E) section 3.3.2.4

EDIT:

In 3.3.2.4 replace the text "and no other statement in  the program unit
may have an initial line that appears to be a program unit END
statement" with ". A statement whose initial line appears to be a
program unit END statement must not be continued."

SUBMITTED BY: J.C.Shepherd, X3J3/92-012, X3J3/92-013, X3J3/92-014
HISTORY: Approved as X3J3/92-088A at meeting 122 by a vote of 24-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000045
TITLE: Array intrinsics with arrays of derived-type arguments
KEYWORDS: array intrinsics, derived-types, operations, interface blocks
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION: The intrinsic functions ALLOCATED, ASSOCIATED, LBOUND, UBOUND,
PRESENT, SHAPE, SIZE, MERGE, PACK, SPREAD, UNPACK, CSHIFT, EOSHIFT,
TRANSPOSE, RESHAPE, and TRANSFER are documented as accepting arrays of
any type.  Does this include arrays of derived-type, and if so, does
this conflict with  section 4.4.5 which states:

Any operation on derived-type entities or nonintrinsic assignment for
derived-type entities  must be defined explicitly by a function or
subroutine and a procedure interface block.

ANSWER: The intrinsics in question can accept arguments which are arrays
of derived-types.  This does not conflict with section 4.4.5.

Discussion: The term "operation" in section 4.4.5 refers to user defined
unary and binary operations in expressions and nonintrinsic assignments.
Such operators are defined by means of interface blocks which define
operators and nonintrinsic assignment.  Using an object as an actual
argument in a procedure reference is not considered an operation on that
object in this sense.

REFERENCES: ISO/IEC 1539:1991 section 4.4.5 and 13.13
            X3J3/92-051 pages 13-14

EDITS: None.

SUBMITTED BY: H.Funaki, X3J3/92-051 (121-ADT-11) pp13-14
HISTORY: Posted request to f90 interp e-mail
         Approved as X3J3/92-092A meeting 121 by a vote of 19-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000046
TITLE: RESULT clause for RECURSIVE functions
KEYWORDS: result clause, recursive functions
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:

   1. Does RECURSIVE require RESULT?

   2. Assuming (1), is a <type-spec> permitted on the function name when
      RECURSIVE is present?

ANSWER: The RESULT clause is not required for all RECURSIVE functions;
it is required for those that are directly recursive.  That is, the
RESULT clause is necessary to make the function visible in its own body
so that direct recursion can take place.

It should be noted that the prohibition against typing the function name
when a result variable name is specified was not intended to prohibit
putting the function type into the header.  In other words:

          FUNCTION F() RESULT (FVAR)
          INTEGER FVAR

and

          INTEGER FUNCTION F() RESULT (FVAR)

are both allowed.  The case prohibited is:

          FUNCTION F() RESULT (FVAR)
          INTEGER F

It is possible for both a <type-spec> and RECURSIVE to appear in a
single function header.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.2

EDITS: None.

SUBMITTED BY: L.Meissner, X3J3/92-045 (121-ADT-5) p17.
HISTORY: For discussion see X3J3/92-45 (121-ADT-5) pp 18, 26-27
         Approved as X3J3/92-101 at meeting 121 by a vote of 20-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000047
TITLE: Automatic data object in initialization expressions
KEYWORDS: automatic data object, initialization expressions
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Can an automatic data object be used as the argument to the
LEN function in the initialization expression of a PARAMETER statement
or an item given the PARAMETER attribute?

ANSWER: It was the intent of the committee to include objects with
nonconstant lengths in the restrictions on the LEN function in section
7.1.6.1 (pages 77 and 78).

REFERENCES: ISO/IEC 1539:1991 (E) section 7.1.6.1

EDITS:

   1. Section 7.1.6.1, page 77, item (6) change "not assumed or" to "not
      assumed, are not defined by an expression that is not a constant
      expression, and are not"

   2. Section 7.1.6.1, page 78, item (6) change "not assumed or" to "not
      assumed, are not defined by an expression that is not a constant
      expression, and are not"

SUBMITTED BY: 120.042
HISTORY: For discussion see 120.073A and X3J3/92-036 (121-JKR-4)
         Approved as X3J3/92-107 at meeting 121 by a vote of 20-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000048
TITLE: Pointer-valued statement functions
KEYWORDS: statement function, pointer
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Can a statement function be pointer-valued?  There appears to
be nothing in section 12.5.4 to prohibit this.

ANSWER: No, a statement function cannot be pointer-valued.

Discussion: From section 12.3.1:

     The interface of a statement function is always implicit.

>From section 12.3.1.1:

     A procedure must have an explicit interface if...
     (2) The procedure has:
         (e) A result that is a pointer (functions only)

Therefore, a statement function cannot have a result that is a pointer.

REFERENCES: ISO/IEC 1539:1991 sections 12.3.1, 12.3.1.1, 12.5.4

EDITS: None.

SUBMITTED BY: L.Meissner, X3J3/92-45 (121-ADT-5) p37
HISTORY: Approved as X3J3/92-108 at meeting 121 by a vote of 19-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000049
TITLE: Characteristics of function results
KEYWORDS: characteristics, function result, ENTRY, exact dependence,
partially associated
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  Given a character function with an ENTRY statement, both
results must have the same characteristics or be scalars without the
POINTER attribute and have identical length.  Therefore:

          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN,ENT
            ...
            ENTRY ENT(M,N)
            ...
          END FUNCTION

is standard conforming.

Question 1:
          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN
            CHARACTER (LEN=M+N)::ENT
            ...
            ENTRY ENT(M,N)
            ...
          END FUNCTION

Is the code above standard conforming?

Question 2:
          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN
            CHARACTER (LEN=N+M)::ENT
            ...
            ENTRY ENT(M,N)
            ...
          END

Is the code above standard conforming?

Question 3:
          FUNCTION FUN(M)
            CHARACTER (LEN=M+M)::FUN
            CHARACTER (LEN=M*2)::ENT
            ...
            ENTRY ENT(M)
            ...
          END

Is the code above standard conforming?

Question 4:  What is the meaning of the phrase "the exact dependence on
the entities" in section 12.2.2?

ANSWER:

Answer 1. Yes
Answer 2. Yes
Answer 3. Yes
Answer 4. The sentence containing the phrase "the exact dependence on
the entities" in section 12.2.2 is intended to convey that in those
cases where the shape or character length type parameter is not
constant, the corresponding characteristic of the function result is not
a value but the way the value is determined when the procedure is
invoked.

Discussion: It was intended that only the mapping from program state to
value be of significance, not the particular form in which that mapping
is expressed.  An edit to make this clear has been included.

In question 3, for example, it is a characteristic of FUN and ENT that
their lengths are twice the value of M.  It is not required that the
expressions of this mapping be identical, only that they yield the same
results.  Thus, twice the value of M could be expressed as M+M for FUN
and as M*2 for ENT.

Clearly, it can be extremely difficult to determine on a static basis
whether two expressions of a mapping are consistent, and there is no
requirement in the standard that this be done.  It would be possible to
check during execution that the values expressed are identical each time
such a procedure is invoked, but it is expected that a more typical
application of this requirement would be to assume that it has been met
and use one expression of this mapping as the basis for computing
attributes of all of the result variables.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.2.2 & 14.6.3.3

EDITS:

   1. Replace the last two sentences in 12.2.2 [166:14-16] with the
      following:

      If the shape or character length type parameter is not constant, the
      corresponding characteristic is the method by which the value is to
      be determined when the function is invoked. This includes the
      possibility that the value is assumed or that it is given by
      evaluating a specification expression.  Two such methods are
      considered to be the same if they yield the same value under all
      possible conditions in which they might be applied; they need not be
      expressed identically.

   2. Replace the last two sentences in 12.2.1.1 [166:4-6] with the
      following:

      If the shape or character length type parameter is not constant, the
      corresponding characteristic is the method by which the value is
      to be determined when the procedure is invoked.  This includes the
      possibility that the value is assumed or that it is given by
      evaluating a specification expression.  Two such methods are
      considered to be the same if they yield the same value under all
      possible conditions in which they might be applied; they need not
      be expressed identically.

SUBMITTED BY: Y. Yoshida, X3J3/92-051 (121-ADT-11) pp.-13
LAST SIGNIFICANT CHANGE: 1993-02-11, item split	000049
HISTORY: Approved as X3J3/92-109A at meeting 121 by a vote of 19-0
         resubmitted in 92-313 in response to ballot comments and
         approved by unanimous consent at meeting 123.
         Revised in response to ballot comments in 92-105

--------------------------------------------------------------------------------

NUMBER: 000050
TITLE: Repeat counts on edit descriptors
KEYWORDS: edit descriptor, repeat count
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is the repeat specification part of the edit descriptor?

In section 10.1.1 the second constraint states that the comma separating
the <format-items> in a <format-item-list> is optional between certain
combinations of edit descriptors.

In section 10.2 a format-item is defined as, amongst other things,
"[r]<data-edit-desc>" and in 10.2.1 an edit-descriptor can be a data-
edit-desc. However, <data-edit-desc> does not contain the repeat count.
This implies that:

    100   FORMAT(1PE20.10)       ! is legal
    200   FORMAT(1P3E20.10)      ! is not legal
    300   FORMAT(1P,3E20.10)     ! is legal

ANSWER: The repeat count is not part of any edit descriptor except the
"[r]/" edit descriptor.

The comments in the examples are correct.

REFERENCES: ISO/IEC 1539:1991, sections 10.1.1, 10.2, & 10.2.1

EDITS: None.

SUBMITTED BY: A.D.Tait, X3J3/92-041 (121-ADT-1)
HISTORY: X3J3/92-041, X3J3/92-042

This problem appears to stem from an incompatibility between FORTRAN 66
and FORTRAN 77. In FORTRAN 66 a FORMAT statement is of the form:

               FORMAT(list)

where the list consists of a series of field descriptors separated by
field separators and optionally preceded and succeeded by slashes. The
field descriptors for real or double precision values consisted of the
now familiar Dw.d, Ew.d, Fw.d, and Gw.d edit descriptors (a term
introduced in FORTRAN 77) preceded by an optional scale factor and
repeat count. For example, in FORTRAN 66 a valid field descriptor is
1P3E17.10, where 1P is the scale factor, 3 the repeat count for a field
containing 10 digits in the fractional part of the number and having a E
exponent.

In FORTRAN 77 the scale factor is an edit descriptor and thus is a list
element in the format specification. While FORTRAN 77 specifies places
where the commas separating list elements in a format specification are
optional, it fails to make a comma between the scale factor and an
immediately succeeding repeated D, E, F, or G edit descriptor optional.
This situation has been carried over to Fortran 90. Thus:

    100   FORMAT(1PE20.10)   ! is legal in F66, F77, and F90
    200   FORMAT(1P3E20.10)  ! is legal in F66, and illegal in F77 & F90
    300   FORMAT(1P,3E20.10) ! is illegal in F66, and legal in F77 & F90

Edit approved in 92-267r at meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000051
TITLE: On unambiguous generic procedure references
KEYWORDS: generic procedure
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Should the rules in 14.1.2.3 include a rule that uses the
fact that a dummy argument is either a subroutine or a function to
disambiguate a generic procedure reference?  For example, such a rule
could be in section 14.1.2.3, in the sentence that is preceded by "(1)",
after "with a different type" adding "present as a subroutine instead of
a function".

ANSWER: No.

The intent of the committee was to keep the rules as simple as possible
in order that they would be easy to understand and to use.  It is not
always possible for the processor to tell whether an actual argument
that is a procedure is a subroutine or an implicitly typed function.

REFERENCES: ISO/IEC 1539:1991 (E) section 14.1.2.3

EDITS: None.

SUBMITTED BY: John Reid, SC22/WG5 N786A
HISTORY: X3J3/92-017 at meeting 121 - RFI: generic interfaces and dummy
         procedure arguments
         Approved as X3J3/92-151 at meeting 122 by a vote of 25-0

--------------------------------------------------------------------------------

NUMBER: 000052
TITLE: Expressions in statement function definitions
KEYWORDS: statement functions, array, variable, intrinsic operator,
expression
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Section 12.5.4 appears to prohibit whole array names
appearing as actual arguments to functions within the <scalar-expr> of a
statement function.  The first constraint states:

The <scalar-expr> may be composed only of constants (literal and named),
references to scalar variables and array elements, references to
functions and function dummy procedures, and intrinsic operators.

A defined operator may be an extended intrinsic operator, as well as a
defined unary  or binary operator.

Question 1:  Is the legal FORTRAN 77 program fragment,

          EXTERNAL FCN
          REAL A(2)
          STFN(X) = FCN(A) + X

where FCN is some function and STFN is a statement function, a legal
Fortran 90 program fragment?

Question 2:  Is it intended that a defined operator which is an extended
intrinsic  operator be allowed in a statement function definition but
other defined operators  not be allowed?

ANSWER: The intent is that the program fragment in question one should
bea valid  Fortran 90 program fragment, and that no defined operators be
allowed in a statement function definition. The standard is in error.
The edits below should be applied to correct the standard.

Discussion: The intent of the standard was to retain the FORTRAN 77
definition of  statement functions without extending it to include
defined operators or array  expressions.  In FORTRAN 77, "expression"
and "variable" referred only to scalar expressions and variables; there
were no defined operators.  In Fortran 90 these  terms also refer to
array expressions and arrays.  The Fortran 90 definition of  statement
functions was intended to prohibit array expressions but overlooked the
use of an array name as an actual argument to a function in the
definition of a statement function.

REFERENCES: ISO/IEC 1539:1991 section 12.5.4

EDITS:  Section 12.5.4

   1. First constraint, first sentence
      change "references to scalar variables and array elements"
      to     "references to variables"

      change "intrinsic operators"
      to     "intrinsic operations"

      after first sentence add

      If <scalar-expr> contains a reference to a function or a function
      dummy procedure the reference must not require  an explicit
      interface, the function must not require an explicit interface or
      be a transformational intrinsic, and the result must be scalar.
      If an argument to a function or a function dummy procedure is array
      valued, it must be an array name.

   2. Second constraint, third sentence
      change "scalar variable, array element"
      to     "variable"

   3. Fifth constraint, first sentence delete second word ("scalar")

SUBMITTED BY: A. D. Tait X3J3/92-064 item # 13 points to B. Smith e-mail
              in X3J3/92-045 pp. 50-52
HISTORY: Approved as X3J3/92-153A at meeting 122 by a vote of 17-2

--------------------------------------------------------------------------------

NUMBER: 000053
TITLE: Optional intrinsic function arguments
KEYWORDS: intrinsic functions, optional arguments
DEFECT TYPE: Amendment
STATUS: X3J3 approved; ready for WG5

QUESTION:  Should constraining text be added to the description of

               optional argument   Y    in CMPLX, and
               optional argument   BACK in INDEX, and
               optional argument   SIZE in ISHFTC, and
               optional argument   A3,... in MAX, and
               optional argument   A3,... in MIN, and
               optional argument   BACK in SCAN, and
               optional argument   BACK in VERIFY

to state that the argument must not be an optional argument of an
invoking procedure?

ANSWER: In principle yes; however it is more appropriate to add an
additional restriction on dummy arguments not present in section
12.5.2.8.

Discussion: The standard contains numerous restrictions intended to
ensure that the rank of a given expression never changes. The case of
elemental functions with optional arguments was inadvertently
overlooked.

Consider the following subprogram:

	  SUBROUTINE SUB (A,B,C)
	    INTEGER :: A ,B
	    INTEGER, OPTIONAL :: C (:)
	    PRINT *, MAX (A, B, C)
	  END

When C is present, the result of the elemental function MAX, is an array
of the same shape as C. However, if SUB were to be called with the third
argument omitted, the result would be a scalar. The supplied edit
remedies this deficiency.

REFERENCES: ISO/IEC 1539:1991 (E) 12.5.2.8, 13.13.20, 13.13.46,
            13.13.50, 13.13.52, 13.13.63, 13.13.68, 13.13.91, 13.13.111,
            13.13.113.

EDITS:

   1. Add the following point to the numbered list in section 12.5.2.8:

     (5) If it is an array, it must not be supplied as an actual
         argument to an elemental procedure unless an array of the same
         rank is supplied as an actual argument corresponding to a
         nonoptional dummy argument of that elemental procedure.

   2. In the paragraph following the numbered list, replace "It" with
      "Except as noted in (5) above, it"

SUBMITTED BY: response to X3J3/92-058 (121-LRR-5)
HISTORY: Submitted as question in 92-058, draft response prepared in
	 X3J3/92-094, and in N815A of the WG5 Victoria meeting based on
         John Reid's paper, N786A.
	 X3J3/92-156r approved at meeting 122

--------------------------------------------------------------------------------

NUMBER: 000054
TITLE: Resolving generic procedure references
KEYWORDS: generic, interface, intrinsic
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  Consider the following code fragment:

          PROGRAM HOST
            DIMENSION ABS(10)
            ...
            CONTAINS
               SUBROUTINE SUB()
                 INTERFACE ABS
                   FUNCTION IA1(I)
                     INTEGER IA1, I
                   END FUNCTION
                 END INTERFACE
                 R = ABS(1.5)

Do the rules for resolving references to names established to be generic
(14.1.2.4.1) imply that R will be assigned the value 1.5 as the result
of invoking the intrinsic ABS?

ANSWER: Yes.

Discussion: ABS is established to be generic in the scope of subroutine
SUB (14.1.2.4 item 1(a)).  The rules in section 14.1.2.4.1 can be used
to resolve the procedure reference. Rule (1) in 14.1.2.4.1 does not
apply, as the reference is not consistent with any specific interface in
the interface block with the name ABS.  Rule (2) does not apply as ABS
does not appear in an INTRINSIC statement.  Rule (3) does not apply as
ABS is not established to be generic in the host scope.  Therefore, rule
(4) is applied and the reference is resolved to the generic intrinsic
procedure ABS.

REFERENCES: ISO/IEC 1539:1991(E) Sections 14.1.2.4 and 14.1.2.4.1

EDITS: None.

SUBMITTED BY: J.C. Shepherd
HISTORY: One of the questions raised in X3J3/92-048 pg 29-30, 34-40,
         51, 52 and X3J3/92-052 pg 1-3.
         Initially drafted as X3J3/92-119
         X3J3/92-157 approved at meeting 122

--------------------------------------------------------------------------------

NUMBER: 000055
TITLE: Characteristics of character function results
KEYWORDS: character function, function result
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  In section 12.5.2.5 the second paragraph after the
constraints contains the text: "Otherwise, they are storage associated
and must all be scalars without the POINTER attribute and all be of type
default character with identical length".  Is some of this text
redundant?

ANSWER: Yes.

Discussion: The phrase referring to "identical length" was meant to
include the FORTRAN 77  character storage association case. FORTRAN 77
requires either that they all  be of assumed length or all be of the
same constant length; both are included as characteristics that agree in
section 12.5.2.5 in the second paragraph after the constraints that
starts with "If the ENTRY".  The phrase is redundant and is causing
confusion.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.5.

EDIT:  In Section 12.5.2.5 in the sentence that starts: "Otherwise,
they ... " delete: "all be scalars ... length or".

SUBMITTED BY: J.K.Reid in N786A at the WG5 Victoria Meeting, July 1992.
HISTORY: Drafted at the WG5 Victoria Meeting July, 1992 and submitted
         to X3J3 at meeting 122
         X3J3/92-158 approved at meeting 122

--------------------------------------------------------------------------------

NUMBER: 000056
TITLE: TRANSFER intrinsic function description
KEYWORDS: Intrinsic functions, examples
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Should the text of Case (iii) under Examples in the TRANSFER
intrinsic function be corrected so the example reads:

     Case (iii): TRANSFER((/1.1,2.2,3.3/),(/ (0.0,0.0) /),1) is a
                 complex rank-one array of length one whose sole element
                 has the value (1.1,2.2)."

ANSWER: No.

Discussion: The current format of the example, 1.1+2.2i, is valid
mathematical notation for complex type.

REFERENCES: ISO/IEC 1539:1991 (E) Section 13.13.108.

EDITS: None.

SUBMITTED BY: Larry Rolison in X3J3/92-059  (121-LRR-6)
LAST SIGNIFICANT CHANGE: 1992 11 11, opposite response	000056
HISTORY: Submitted as a request in X3J3/92-059
         Draft response first prepared in X3J3/92-091
         Subsequent draft in X3J3/92-159, rejected at meetings 121 and 122
         Revised response proposed in X3J3/92-294 - approved by unanimous
         consent at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000057
TITLE: Prohibition against multiple explicit specific interfaces
KEYWORDS: specific interfaces, interface body, interface block
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:   What is the meaning and/or intent of the following sentence
in 12.3.2.1?

A procedure must not have more than one explicit specific interface in a
given scoping unit."

Multiple SPECIFIC interfaces can not be produced by the existence of
interface blocks because the definition of an interface body states that
it only specifies an EXPLICIT interface, not a SPECIFIC interface.
According to the statement in 12.3.2.1: "An external or module
subprogram definition specifies a specific interface for the procedures
defined in that subprogram", only external or module subprograms have
specific interfaces and the specific interfaces are only specified by
the text of the subprogram itself.

Could an example of code be provided that is prohibited by the statement
"a procedure must not have more than one explicit specific interface in
a given scoping unit" in 12.3.2.1 and that would not be prohibited by
some other provision of ISO/IEC 1539:1991?

ANSWER: The statement in the question that "Multiple SPECIFIC interfaces
can not be produced by the existence of interface blocks" is incorrect.
An example follows.

Discussion: The paragraph following the constraints, in 12.3.2.1 is
concerned with "specific interfaces" and it was intended to be
understood from the context in that discussion that the interface
specified by an interface body should be both specific and explicit.
See also 14.1.2.4, (2), (a) which shows that it was intended that an
interface body define a specific interface.  The intention was to
disallow the same information being provided twice, as for other
specifications. An edit is supplied to make this clearer.

An example which illustrates what is prohibited follows:

Example:
          MODULE MOD
            INTERFACE
              SUBROUTINE SUB(I,J)
                INTEGER I,J
              END SUBROUTINE
              SUBROUTINE SUB(M,N)   ! duplication of SUB is illegal
                INTEGER M,N
              END SUBROUTINE
            END INTERFACE
          END MODULE

REFERENCES: ISO/IEC 1539:1991 (E) section 12.3.2.

EDITS:  Section 12.3.2.1, the sentence that begins "An interface
body..."  change "explicit interface" to "explicit specific interface".

SUBMITTED BY: L. Rolison
LAST SIGNIFICANT CHANGE: 1992-11-12	000057
HISTORY: 120.035, 120.090
         Approved as X3J3/92-162A at meeting 122 by unanimous consent
         Revised following letter ballot at meeting 123 in 92-314 to
         correct transcription errors in the recording of what was
         contained in 92-162A.

--------------------------------------------------------------------------------

NUMBER: 000058
TITLE: Ambiguous use of "keyword"
KEYWORDS: keyword, argument keyword
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Is the use of "keyword" in 12.4.1 page 172 1st paragraph
consistent with the definition of "keyword" in 3.2.1, page 19? Is the
definition of keyword in 3.2.1 consistent with the two definitions of
keyword in 2.5.2 page 16? In 13.10 page 188 is "keyword" the correct
term (or should it be "argument keyword")?

ANSWER: For each question, the answer is "NO".

There are two different definitions of "keyword", 2.5.2 page 16 and
3.2.1 page 19.  Neither definition is complete.

The edits below combine these two definitions into one and consistently
use "argument keyword" where appropriate.  Note that edits 3 and 6 are
related to edit 1 in item 4.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.5.2, 3.2.1, 12.4.1,& 13.10

EDITS:

   1. Page 5, section 1.5.3, (3) [5:9]
      delete "keyword actual arguments and"
      rationale: these are not specifiers and -spec is not used with
      them.

   2. Page 16, section 2.5.2, first paragraph, first occurrence [16:3]
      change "statement keyword"
              --------- -------
      to "statement keyword (often abbreviated to keyword)"
          --------- -------                       -------
      rationale: define "keyword", in a style similar to "object" in
      2.4.3.1.

   3. Page 16, section 2.5.2, first paragraph, end of [16:5]
      add "Keywords appear as upper-case words in the syntax rules
      in Sections 4 through 12".

   4. Page 16, section 2.5.2, second paragraph, first sentence [16:6]
      change "name." to "name (see 12.4.1)."

   5. Page 19, section 3.2 [19:35]
      change "keywords" to "statement keywords (2.5.2)"

   6. Page 19, section 3.2.1 [19:37-38]
      delete
      rationale: 2.5.2 is now the complete definition.

   7. Page 160, section 11.3.3.5, first paragraph, third line [160:29]
      change "keywords" to "argument keywords"

   8. Page 168, the pp following the line "END INTERFACE", second
      sentence [168:24] replace with "Invocations of these procedures may
      use argument keywords; for example:"
      rationale: "keyword calls" is not defined.  In general invocations
      can use both positional and argument keywords.

   9. Page 172, 1st paragraph following constraints, 3 occurrences
      [172:13,16,17] change "a keyword" to "an argument keyword", two
      occurrences, and change "the keyword" to "the argument keyword"

  10. Section 13.3, first sentence [183:37], set "positional arguments"
      and "keyword arguments" in regular font

  11. Page 183, section 13.3, first paragraph, third line, 2 occurrences
      [183:38]
      change "the keyword" to "the argument keyword" and
      change "A keyword" to "An argument keyword"

  12. Page 188, section 13.10, first paragraph, first two lines, 2
      occurrences [188:12,13]
      change "keyword" to "argument keyword" and
      change "keywords" to "argument keywords"

  13. Page 363, entry for "argument keywords 183" [363:37] delete
      rationale: odd to index both singular and plural.  "Keyword",
      and "statement keyword" are indexed to p16, as is the remaining
      entry for "argument keyword".

  14. Annex F, delete entry for "positional arguments" [368:13]

SUBMITTED BY: GEN
HISTORY: WG5/N808, Question 2.
         Approved as X3J3/92-164A at meeting 122 by a vote of 17-4

--------------------------------------------------------------------------------

NUMBER: 000059
TITLE: SEQUENCE derived type and component bounds
KEYWORDS: SEQUENCE, derived type
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Given two objects of SEQUENCE derived type, can the two
objects be of the same derived type if the only difference between the
two SEQUENCE derived type definitions is the value of the low bound and
high bound for one dimension of one of the components (assuming the
extent of the dimension of the array component matches the extent given
in the other; and there are no structure components that have PRIVATE
accessibility)?

The description of when two objects of SEQUENCE derived type have the
same type includes the words (2nd paragraph of 4.4.2 "Determination of
derived types") "have structure components that do not have PRIVATE
accessibility and agree in order, name, and attributes".

This text seems to imply that if the derived type includes an <array-
spec> then the individual low bounds and high bounds have to be the
same.

An example that corresponds to the question above:

          SUBROUTINE S()
            TYPE T
              SEQUENCE
              INTEGER A(1:10)
            END TYPE
            TYPE (T) X
            CALL S2(X)
            ...

          SUBROUTINE S2(Y)
            TYPE T
              SEQUENCE
              INTEGER A(2:11)
            END TYPE
           TYPE (T) Y
           ...

Do X and Y have the same type?

ANSWER: No.

Discussion: The attributes that a data object may have are enumerated in
section 5.1.2.  Included in these is the DIMENSION attribute (section
5.1.2.4).  In reference to the explicit shape arrays in the example
above, in order for the attributes to agree, the values of the
corresponding lower bounds and the corresponding upper bounds in
<explicit-shape-spec> must be equal.

REFERENCES: ISO/IEC 1539:1991(E) 5.1.2

EDITS: None.

SUBMITTED BY: Janice C. Shepherd  X3J3/92-129
HISTORY: X3J3/92-129
        Approved as X3J3/92-165A at meeting 122 by a vote of 19-2
        Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000060
TITLE: Statement function argument references
KEYWORDS: statement function arguments
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Consider the following program:

         PROGRAM TEST
            INTEGER AR
            EXTERNAL AR
            REAL A(2), FUN, X, Y
            DATA A/2*5./
            FUN(X) = X+X+X
            Y=FUN(A(AR(5)))
          END

          INTEGER FUNCTION AR(I)
            INTEGER I
            AR = 1
            PRINT *, I
            RETURN
          END

When the statement function is referenced, how many times is the
function AR called?  Or, to put it another way, how many times is the
PRINT statement in function AR executed during the statement function
reference?

ANSWER: In the program above, the function AR is called once unless the
value of the function "can be determined otherwise" than by evaluating
the function.  Therefore,  the PRINT statement in function AR is
executed at most once.

Discussion: When the statement function is referenced, the actual
arguments are evaluated and the resulting values are associated with the
corresponding dummy arguments.  The statement function FUN has only one
actual argument which contains only one reference to the external
function AR.  Therefore, the function AR is called once as part of the
evaluation of the  actual argument.  The value resulting from this
evaluation is associated with  the single dummy argument of the
statement function FUN.  Though the PRINT statement may be executed
once, note that 7.1.7.1 gives license to the processor to not execute
the PRINT statement at all.  Thus the statement in the answer is "the
PRINT statement in function AR is executed at most once".

REFERENCES: ISO/IEC 1539:1991 (E) sections 7.1.7.1 and 12.5.4, the
            fourth paragraph after the last constraint

EDITS: None.

SUBMITTED BY: Linda J. O'Gara
LAST SIGNIFICANT CHANGE:  1992 11 13	000060
HISTORY: 121-LJO-3, 121-ADT-11 pages 14-17
         Approved as X3J3/92-168 at meeting 122 by a vote of 17-0
         Revised after letter ballot at meeting 123, in paper 92-315.
         Revision approved by unanimous consent in meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000061
TITLE: G edit descriptor with "d" = 0
KEYWORDS: G edit descriptor
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is a value of 0 for "d" in a G edit descriptor (e.g. 1PG8.0)
permitted?

ANSWER: Yes. See R1008, R1005, and R404.

QUESTION:  Did the committee mean to change the definition of G format
in Fortran 90 (compared to FORTRAN 77)?

ANSWER: Yes. The form of output text produced by the G edit descriptor
for some values and particular edit descriptors was intentionally
changed. The changes require processors to give meaningful output
instead of "*"s for certain values and edit descriptors.

QUESTION:  What happens when N (the value to be printed) is zero and "d"
is zero?

ANSWER: The standard indicates a format of F(w-n).-1 is to be used. This
is an error in the standard.

REFERENCES: ISO/IEC 1539:1991 (E) Rules R404, R1005, and R1008

EDITS:

   1. In section 10.5.4.1.2 second paragraph, 3rd sentence, after "-
      0.5," add " or N is identically 0 and d is 0,".

   2. In section 10.5.4.1.2, second paragraph, fourth sentence, after "N
      is identically 0" add " and d is not zero".

   3. In section 1.4.1, add item (5) as follows:

      (5) A value of 0 for a list item in a formatted output statement
          will be formatted in a different form for some G edit
          descriptors. In addition, the Fortran 90 standard specifies how
          rounding of values will affect the output field form, but
          FORTRAN 77 did not address this issue: therefore, some
          FORTRAN 77 processors may produce a different output form than
          Fortran 90 processors for certain combinations of values and G
          edit descriptors.

SUBMITTED BY: J.Brixius, 121-JB-1
HISTORY: 121-ADT-7 pp 1-9, 92-076, 92-118
         Approved as X3J3/92-149A at meeting 122 by a vote of 20-3
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000062
TITLE: Statement function constraints
KEYWORDS: statement function, host association
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Does the last constraint under R1226 allow variables in a
<scalar-expr> of a statement function definition to be accessed via host
association or use association?

          PROGRAM HOST
            INTEGER I
            ...
            CONTAINS
              SUBROUTINE INNER()
                STMTFUNC()=I+1
                ...

ANSWER: Yes.

Discussion: It was the intent of the committee to allow variables made
accessible by use or host association to appear in a <scalar-expr> of a
statement function definition. The text of the last constraint under
R1226 needs clarification to better reflect that intent.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.4

EDITS:  In the last constraint after R1226 in section 12.5.4 replace
"local to" with "accessible in".

SUBMITTED BY: J.C.Shepherd X3J3/92-015
HISTORY: Discussed in X3J3/92-046 pp 28-29
         Initially drafted as X3J3/92-120
         Approved as X3J3/92-160 at meeting 122 by a vote of 23-0
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000063
TITLE: Interfaces and dummy procedure arguments
KEYWORDS: interface, dummy procedure
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Given a procedure that has a dummy argument, must an explicit
interface for the procedure show sufficient information to indicate that
its dummy argument is a dummy procedure?

ANSWER: Yes.

Discussion: The first sentence of the second paragraph in 12.3.2.1
indicates that an interface body must specify all of the procedures
characteristics. Section 12.2 indicates that a procedure's
characteristics include the characteristics of its arguments. Therefore,
an interface body must include an EXTERNAL statement or a nested
interface block for each dummy argument that is a dummy procedure, even
though this may not be necessary in the procedure definition.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 12.2 and 12.3.2.1

EDITS: None.

SUBMITTED BY: J.C.Shepherd, X3J3/92-016
HISTORY: Approved as X3J3/92-161 at meeting 122 by a vote of 24-0
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000064
TITLE: SPACING result for 0.0
KEYWORDS: SPACING intrinsic
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Is the SPACING intrinsic function intended to return absolute
spacing of model numbers about 0.0 when its argument is 0.0?

Section 13.12.100 under Result Value specifies that the result should be
b**(e-p); this is not equal to the absolute spacing of model numbers
around zero because zero has e == 0, so b**(e-p) provides a much larger
value than expected.

ANSWER: Yes.

Discussion: Since the smallest magnitude model numbers are TINY(X) and
-TINY(X), the absolute spacing around zero is TINY(X). It was intended
that the "otherwise" clause of the SPACING definition apply to this
case.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 12.7.1 and 13.13.100.

EDITS:  In section 13.13.100, after "Result Value." change "The" to
"If X is not zero, the". In the same section, change "; otherwise " to
". Otherwise".

SUBMITTED BY: J.K.Reid
HISTORY: WG5/N786a item 234/7, N815a item 6 (X3J3/92-136 item 6)
         Approved as X3J3/92-171 at meeting 122 by a vote of 22-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000065
TITLE: Block and nonblock DO construct
KEYWORDS: block DO construct, nonblock DO construct
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Consider the following DO loop:

          DO 10, I = 1, 10
            K = I
    10    CONTINUE

It can be parsed using either of the following two paths:

  R816  <do-construct>             is  <block-do-construct>

  R817  <block-do-construct>       is  <do-stmt>
                                       <do-block>
                                       <end-do>

  R818  <do-stmt>                  is  <label-do-stmt>

  R819  <label-do-stmt>            is   DO <label> [<loop-control>]

  R821  <loop-control>             is  ,<do-variable> =
                                             <scalar-numeric-expr>,
                                             <scalar-numeric-expr>

  R822  <do-variable>              is  <scalar-variable>

  R823  <do-block>                 is  <block>

  R801  <block>                    is  [<execution-part-construct>]...

  R209  <execution-part-construct> is  <executable-construct>

  R215  <executable-construct>     is  <action-stmt>

  R216  <action-stmt>              is  <assignment-stmt>

  R824  <end-do>                   is  <continue-stmt>

or

  R816 <do-construct>              is  <nonblock-do-construct>

  R826  <nonblock-do-construct>    is <action-term-do-construct>

  R827  <action-term-do-construct> is  <label-do-stmt>
                                       <do-body>
                                       <do-term-action-stmt>

  R819  <label-do-stmt>            is  DO <label> [<loop-control>]

  R821  <loop-control>             is  ,<do-variable> =
                                             <scalar-numeric-expr>,
                                             <scalar-numeric-expr>

  R822  <do-variable>              is  <scalar-variable>

  R828  <do-body>                  is  [<execution-part-construct>]...

  R209  <execution-part-construct> is  <executable-construct>

  R215  <executable-construct>     is  <action-stmt>

  R216  <action-stmt>              is  <assignment-stmt>

  R829  <do-term-action-stmt>      is  <action-stmt>

  Constraint:  A <do-term-action-stmt> must not be a <continue-stmt>...

How is a compiler to decide that the above DO loop is obeying the rules
for a  <block-do-construct> (and thus no diagnostic is required) or that
it is following  the rules for a <nonblock-do-construct> (and thus by
1.4 it should report that the  program is being rejected because it is
violating the constraint)?

ANSWER: The intent of the cited constraint is to remove the ambiguity
raised in the  question in favor of the <block-do-construct>
interpretation.

Discussion: Item 5 in section 1.5.1 states that

The syntax rules are not a complete and accurate syntax description of
Fortran, ...; where a syntax rule is incomplete, it is accompanied by
the corresponding constraints and text.

This is an application of this rule.

REFERENCES: ISO/IEC 1539:1991 (E) sections 1.5.1, 2.1, and 8.1.

EDITS: None.

SUBMITTED BY: L. Rolison X3J3/92-126
HISTORY: Approved as X3J3/92-169 at meeting 122 by a vote of 20-0
         Edit approved in 92-267r at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000066
TITLE: Declaration of FUNCTION type
KEYWORDS: function, declarations
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  In the following example:

          SUBROUTINE SUB
            ...
            Y=F(X)
            ...
            CONTAINS
              FUNCTION F(X)
                REAL F,X
                  ...
              END FUNCTION F
          END

Is the declaration of function-name "F" in the REAL <entity-decl-list>
legal? Does the second constraint in 5.1 contradict the text in the
first sentence of the first paragraph after constraints in section
12.5.2.2?

ANSWER: Yes. The example above is standard conforming. There is no
conflict between the constraint and the text mentioned.

Discussion: The information in section 5.1 that applies to functions
describes functions being called, not functions being defined by program
units or by internal functions. The information in section 12.5.2.2
describes the definition of functions.

However, this distinction has been made less clear by syntax rules and
constraints in section 5.1 that do not reflect it. The supplied edit
remedies this situation by using consistent terminology and eliminating
the resultant redundant constraint.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1 (R504) and 12.5.2.2

EDITS:

   1. Change R504 "<function-name>{(<array-spec>)}" to "<function-name>".

   2. Change "Constraint: An <array-spec> for a <function-name> that
      does not have the POINTER attribute must be an
      <explicit-shape-spec-list>" to "Constraint: An <array-spec>
      for an <object-name> that is a function result that does not have
      the POINTER attribute must be an <explicit-shape-spec-list>".

   3. Delete the constraint "An <array-spec> for a <function-name> that
      does have the POINTER attribute must be a <deferred-shape-spec-
      list>".

SUBMITTED BY: L.R.Rolison X3J3/92-057 (121-LRR-4)
HISTORY: Original response in X3J3/92-090, reconsidered and rewritten
         Approved as X3J3/92-173 at meeting 122 by unanimous consent
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000067
TITLE: Output of negative signed zero
KEYWORDS: F edit descriptors, negative signed zero, formatted output
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  If the real variables A, B, C, and D have the values -.003,
-.003, -0.0, and 0.0 respectively  and they are written with:

          WRITE(6,100) A,B,C,D
   100    FORMAT(F10.2, F10.3, 2F10.3)

is the following output correct:

     -0.00    -0.003       0.0       0.0
.........1.........2.........3.........4

ANSWER: No.

QUESTION:  or should it be

      0.00    -0.003     0.000     0.000
.........1.........2.........3.........4

ANSWER: Yes. Negative signed zero in an output record is prohibited by
section 10.5.1 item (3). Truncation of trailing zeros by F edit
descriptor is not allowed. See the last paragraph of section 10.5.1.2.1.

REFERENCES: ISO/IEC 1539:1991 (E) sections 10.5.1 and 10.5.1.2.1

EDITS: None.

SUBMITTED BY: A.D.Tait X3J3/92-045 pp 14-16
HISTORY: Approved as X3J3/92-074 at meeting 122 by a vote of 22-0
         Approved in ballot 92-182

--------------------------------------------------------------------------------

NUMBER: 000068
TITLE: Pointer association status
KEYWORDS: pointer association
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  When the execution of a procedure is terminated by the
execution of a RETURN or END statement, the pointer association status
of a pointer declared or accessed in the procedure becomes undefined
unless one of the exceptions listed in section 6.3.3.2 of the standard
applies.

In the following example, when SUB is terminated, X remains associated
because it is in a COMMON block.  Pointer Z will become undefined.  The
Y in the main program is useful, but according to the standard, it is
invalid because it points to the undefined Z.  Is this correct?

            COMMON /COM/ X,Y
            CHARACTER*10,POINTER::X,Y
            ...
            CALL SUB
            PRINT *, X         ! X must be valid
            PRINT *, Y         ! is this Y valid?
          END

          SUBROUTINE SUB
            COMMON /COM/ X,Y
            CHARACTER*10,POINTER::X,Y,Z
            ALLOCATE (X,Z)
            X = 'A STRING'
            Z = 'ANOTHER'
            Y => Z
            RETURN
          END

ANSWER: No, the interpretation suggested in the question is not correct.
The example is valid.

Discussion: The question appears to confuse the association status of
the pointer and the definition status of its target.  The pointer
association status of Z becomes undefined on the execution of the RETURN
statement in the above example, but this does not imply that the target
of Z becomes undefined.  The situation is analogous to that described in
section 6.3.1.2 of the standard in the context of the ALLOCATE
statement.

If the previous target had been created by allocation, it becomes
inaccessible unless it can still be referred to by other pointers that
are currently associated with it.

An example and further elaboration is given in section C.6.4

The basic principle is that ALLOCATE, NULLIFY, and pointer assignment
primarily affect the pointer rather than the target. ALLOCATE creates a
new target but, other than breaking its connection with the specified
pointer, it has no effect on the old target.  Neither NULLIFY nor
pointer assignment has any effect on targets.

Similarly, the target of Z in the above example is not affected when the
pointer association status of Z becomes undefined.  If the old target of
Z could not be referred to by other pointers, then it would become
inaccessible (though still technically defined).  In this example, the
old target of Z can still be referenced by Y.  It therefore remains both
defined and accessible.

The statement in section 14.6.2.2 that "The definition status of a
pointer is that of its target" applies only when the pointer is
associated with a target.

REFERENCES: ISO/IEC 1539:1991, sections 6.3.1.2, 6.3.3.2, 14.6.2.1,
C.6.4

EDITS:  The list in section 14.6.2.1, item (3), of ways that pointer
association status can become undefined is incomplete.

In section 14.6.2.1, item (3), add a new subitem as follows:

  (e) After the execution of a RETURN or END statement in a procedure
      where the pointer was either declared or, with the exceptions
      described in 6.3.3.2, accessed.

The reference to section 6.3.3.2 in 14.6.2.1 (3) (d) is misleading.  In
section 14.6.2.1, item (3), subitem (d), remove "6.3.3.2,".

SUBMITTED BY: Y.Yoshida, X3J3/92-051 p4
HISTORY: Approved as X3J3/92-083A at meeting 122 by a vote of 18-2
         Approved in X3J3/92-329 at meeting 123 (unanimous consent)

--------------------------------------------------------------------------------

NUMBER: 000069
TITLE: I/O implied DO variable
KEYWORDS: implied DO, I/O statement
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION(S):
   (1)  Can the "do-variable" in an implied-DO in an I/O statement be a
        sub-object?

   (2)  Should the second constraint in section 9.4.2 read:
        "Constraint: The "do-variable" must be a named scalar variable
        of type integer, default real, or double precision real."?

ANSWER(S):
   1. No.  The intent of the committee was to allow only named scalar
      variables as "do-variables".  The supplied edit corrects this
      error.

   2.  Yes, it should have.

Discussion: In FORTRAN 77, all implied-DO variables were required to be
a "variable", and derived types were not part of the language.  The
rules for implied-DO variables and DO loop "do-variables" were
identical.  The committee's intent was to permit only simple variables
(named scalar variables) as implied-DO variables in I/O statements.

REFERENCES: ISO/IEC 1539:1991 (E) sections 8.1.4.1.1, 9.4.2, 5.2.9,
            ANSI X3.9-1978 12.8.2.3, 11.10, 9.3.

EDIT:  In section 9.4.2, in the second constraint, replace the word
"scalar" with "named scalar variable".

SUBMITTED BY: Larry Rolison, 92-086 (121-86/121-LRR-9)
HISTORY: 92-086
         Approved as X3J3/92-217b at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000070
TITLE: Characteristics specified by interface bodies
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Section 12.3.2.2 indicates that an interface body specifies
all of a procedure's characteristics and that the characteristics must
be consistent with those in the procedure definition.  Are the following
code fragments standard conforming?

(a)      PROGRAM FRED
           INTERFACE
             SUBROUTINE SUB (ARR,J)
               INTEGER ARR(1:)
             END SUBROUTINE
           END INTERFACE
         INTEGER ARR(10)
         CALL SUB(ARR,2)
         END PROGRAM

         SUBROUTINE SUB(ARR, J)
           INTEGER ARR(J:)
           ...
         END SUBROUTINE SUB

(b)      FUNCTION C1( )
           CHARACTER(*) C1
           ...
         END FUNCTION C1
         FUNCTION C2(N)
           CHARACTER(N) C2
           ...
         END FUNCTION C2

         SUBROUTINE CALLER( )
           INTERFACE
             FUNCTION C1( )
               CHARACTER(*) C1
             END FUNCTION
             FUNCTION C2(N)
               CHARACTER(2) C2
             END FUNCTION
           END INTERFACE
           CHARACTER(5) CC
           CC=C1( )//C2(2)

ANSWER:

  (a)  This example is standard conforming.

  (b)  This example is not standard conforming.

Discussion:

(a)  12.2.1.1 states that the characteristics of a dummy data object
include its shape, and that if the shape is assumed then that is a
characteristic. Section 2.4.5 states that the shape of an array is
determined by its rank and extent in each dimension (but not by its
bounds, 5.1.2.4.2). Both the interface block for SUB and the definition
of SUB describe the shape of ARR as assumed, so they are describing the
same shape, and the program is standard conforming.

It is possible to read the second sentence in 12.2.1.1 as requiring
bounds to match.  This was not intended.  An edit is included to clarify
that it is the shape resulting from the bounds specifications that is a
characteristic and not the bounds themselves.

(b)  Section 12.2.2 states that the characteristics of a function
include whether or not the function result value is a character of
assumed length.  So the interface body for function C1 must indicate
that C1 is of assumed length.  However, item (3) in 5.1.1.5 indicates
that scoping units that invoke an external character function of assumed
length must have access to a declaration of the function name with a
length type parameter value other than *.  An edit is included to
clarify this restriction.

In addition, the interface for C2 does not conform to the standard as
the length of C2 specified as 2 is not consistent with the length
specified as N within the function definition.

EDITS:

   1. In section 5.1.1.5 item (3), add to the end: "Note that the
      interface for such a function cannot be specified in an interface
      body."

   2. Replace the last two sentences in 12.2.1.1 [166:4-6] with the
      following:

      If the shape or character length type parameter is not constant,
      the corresponding characteristic is the method by which the value
      is to be determined when the procedure is invoked.  This includes
      the possibility that the value is assumed or that it is given by
      evaluating a specification expression.  Two such methods are
      considered to be the same if they yield the same value under all
      possible conditions in which they might be applied; they need not
      be expressed identically.

   3. Replace the last two sentences in 12.2.2 [166:14-16] with the
      following:

      If the shape or character length type parameter is not constant,
      the corresponding characteristic is the method by which the value
      is to be determined when the function is invoked.  This includes
      the possibility that the value is assumed or that it is given by
      evaluating a specification expression.  Two such methods are
      considered to be the same if they yield the same value under all
      possible conditions in which they might be applied; they need not
      be expressed identically.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.4.5, 5.1.1.5, 5.1.2.4.2,
            12.2.1.1, and 12.2.2.

SUBMITTED BY: Graham Barber (a),  Janice Shepherd (b)
LAST SIGNIFICANT CHANGE: 1993,-02-12, revised	000070
HISTORY: Question (a) originally posed in X3J3/92-264.
         Question (b) originally posed in e-mail collection X3J3/92-46.
         Response proposed in X3J3/92-283.
         Approved by unanimous consent at meeting 123.
         Response questioned by John Reid in X3J3/93-018.
         Revised response proposed in X3J3/93-103.
         Approved by unanimous consent at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000071
TITLE: USE association and COMMON block names
KEYWORDS: use association, COMMON block names, storage association
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Can a module or subprogram access through USE association
variables declared in different modules to be in the same common block?

Example:

      MODULE MOD1
      COMMON /BLOCK/ A,B,C
      END MODULE MOD1

      MODULE MOD2
      COMMON /BLOCK/ X,Y,Z
      END MODULE MOD2

      SUBROUTINE USER()
      USE MOD1
      USE MOD2
      ...
      Y = A               ! Are both Y and A accessible?
      END

ANSWER: Yes.

Discussion: The COMMON statement in MOD1 forms a common block storage
sequence as described in 5.5.2.1.  The COMMON statement in MOD2
similarly forms a common block storage sequence.  These two sequences
are associated as described in 5.5.2.3, thus associating A with X, B
with Y, and C with Z.  The USE statements in USER make these variables
accessible in that scoping unit.  The associated variables are
considered to behave as though they had been equivalenced. The list of
entities made accessible by USE association in 11.3.2 includes variables
but not common blocks, so there is no implication that these two
specifications of common block storage sequences for /BLOCK/ interfere
with each other or require a concatenated common block storage sequence
in USER.

Various other combinations of USE association, host association, and
local COMMON statements can similarly result in common associated
variables being accessible in the same scoping unit.  One of these
cases, that involve USE association and local COMMON statements, is
prohibited in 5.5.2.5.

The edits below emphasize the independence of common block storage
sequence formation from USE and host association and eliminate the
ineffective restriction in 5.5.2.5.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.5.2.1, 5.5.2.3, 5.5.2.5,
and 11.3.2

EDITS:

   1. In the first sentence of 5.5.2.1 after "For each common block",
      insert "in a scoping unit".

   2. At the end of 5.5.2.1, add the following paragraph:  "Only COMMON
      statements and EQUIVALENCE statements appearing in the scoping
      unit contribute to common block storage sequences formed in that
      unit.  Variables in common made accessible by USE association or
      host association do not contribute."

   3. At the end of the first paragraph of 5.5.2.3, add the following
      sentence:  "USE association or host association may cause these
      associated objects to be accessible in the same scoping unit."

   4. Delete the last two sentences in 5.5.2.5.

SUBMITTED BY: Jon L. Steidel, 120-JLS-8
LAST SIGNIFICANT CHANGE: 1992-11-12, added edits to previously proposed
interpretation	000071
HISTORY: 120-86 (120-MBSH-3), initial response draft
         92-163, revised draft response
         92-191, revised draft response
         92-316, revised draft response - approved by a (19-2)
         vote at meeting 123
         93-087, consideration of ballot response:
         92-316 reapproved by unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000072
TITLE: Missing constraint for SIZE=
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  In section 9.4.1, should there be an additional constraint:

    "If a SIZE= specifier is present, an ADVANCE= specifier also must
    appear"?

ANSWER: Yes.

In reading the first two paragraphs of section 9.4.1, immediately
following the list of constraints, it can be seen that SIZE and EOR have
the same requirements and, thus, there should be a constraint for SIZE
that parallels the constraint (last in the list) for EOR.

REFERENCES: ISO/IEC 1539:1991 (E) sections 9.4.1

EDIT: Section 9.4.1, [120:25], add a constraint to the end of list:

      "If a SIZE= specifier is present, an ADVANCE= specifier also must
      appear."

SUBMITTED BY: Dick Weaver
HISTORY: 92-193

--------------------------------------------------------------------------------

NUMBER: 000073
TITLE: Description of the MERGE intrinsic function
KEYWORDS: elemental function, MERGE, array construction function
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTIONS:

The MERGE intrinsic function is described as an array construction
function in sections 13.8.6 and 13.10.16.

The description of MERGE in section 13.13.67 classifies it as an
elemental function.

1. Are the descriptions of MERGE in sections 13.8.6 and 13.10.16
consistent with its classification as an elemental function?  Note that
13.8 is "Array intrinsic functions" and MERGE is the only elemental
included.

2.Should all elemental functions be listed as "array construction"
functions or should MERGE  be described elsewhere.

ANSWERS:

   1. Yes.  MERGE is both an elemental intrinsic function and, when
      called with array arguments, an array construction function.

   2. All elemental intrinsic functions are array construction functions
      when called with array arguments.

REFERENCES: ISO/IEC 1539:1991 (E) sections 13.8.6, 13.10.16, 13.13.67

EDIT:  None

SUBMITTED BY: Dick Weaver X3J3/92-197
LAST SIGNIFICANT CHANGE: 93-02-11	000073
HISTORY: Submitted as X3J3/92-197
         Draft response in X3J3/92-322 at meeting 123 (not
         approved)
         Response in X3J3/93-090, passed 14-4

--------------------------------------------------------------------------------

NUMBER: 000074
TITLE: Meaning of "referenced" in 11.3.2
KEYWORDS: local names, data entity
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:

Question 1:  The section of the standard in 11.3.2 [158:27-31] states:

"Two or more accessible entities, other than generic interfaces, may
have the same name only if no entity is referenced by this name in the
scoping unit."

Should the use of this name as an argument to an inquiry function also
be disallowed; or passing the duplicate name as an argument be
disallowed; or the duplicate name in a pointer assignment be disallowed?
Can the duplicate name be the left hand side of an assignment statement?

Question 2:  Is it valid to have two local-names on a rename-list that
are the same but refer to two different data entities?  In the following
example, is the appearance of the second AA local-name in the rename-
list legal?

          USE MID, AA=>BB
          USE MID, AA=>CC

ANSWER:

Answer 1:  The cases cited in the question are not covered specifically
in 11.3.2 although they were intended to be included in the quoted text
as "referenced" entities. The cited cases are examples of the appearance
of names rather than as a technical Fortran 90 term for "reference".

Answer 2:  The example is invalid. The appearance of the second AA is
not allowed by the standard. In section 11.3.2 [158:15-16], the standard
states that the local name is a "local name for the entity" which was
intended to mean that a new entity is not created, the existing entity
is just renamed.

Discussion: It was intended that the term "referenced" be used in the
sense that an entity "appears in" or "is referred to" in the scoping
unit, and was not intended to mean "referenced" in terms of the
technical definition. That is, if two  or more accessible entities have
the same  name, that name must not appear in the  same scoping unit. The
following edit improves this wording.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2

EDIT:  In section 11.3.2 [158:28] change the term "no entity is
referenced by this name" to "the name is not used to refer to an
entity".

SUBMITTED BY: Dick Weaver, 92-198 question raised.
HISTORY: Response draft in meeting 123 (92-297) -
         approved by unanimous consent in meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000075
TITLE: Interface blocks in block data
KEYWORDS: interface block, block data
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  In section 12.3.2.1, on page 167, the third constraint

   "An interface-block must not appear in a BLOCK DATA program unit"

is constraining what? (The existence of a constraint implies that, if
the constraint were not present, the constrained "action" would be
allowed.)

ANSWER: The constraint is redundant with the second constraint in
section 11.4.

REFERENCES: ISO/IEC 1539:1991 (E) sections 11.4, 12.3.2.1

EDITS: None.

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11, first draft response	000075
HISTORY: X3J3/92-200
         Draft response in X3J3/92-323 at meeting 123, not approved
         92-323 reconsidered at meeting 124; reapproved by unanimous
         consent

--------------------------------------------------------------------------------

NUMBER: 000076
TITLE: Attributes, properties, characteristics
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  I've been trying to understand "attributes" and "properties".
Beginning with the glossary definition of "attributes":

      Attributes: A property of a data object that may be specified in
                      a type declaration statement

There would seem to be some set of "properties", of which a subset are
"attributes".  However, in trying to use that definition while reading
the standard, I had a variety of difficulties:

      --  that definition itself:  data entities besides data objects
          have attributes and the attributes of a function result can be
          specified in a type declaration stmt in the same manner as for
          a data object.

      --  the first pp of chapter 5 equates attributes and properties
          "Collectively, these properties are termed the attributes of
          the data object"

      --  the introduction (xv, 2pp from bottom) equates attributes and
          properties: "... given the desired properties (attributes)"

      --  where I would expect "properties", I find "attributes", for
          example in host association 12.1.2.2.1 "The accessed entities
          are known by the same name and have the same attributes ....".
          For host association, can the attributes be the same but
          properties be different?

      --  chapter 4, 4.4.2 for example, talks about derived type
          definitions having the SEQUENCE property but a derived type
          definition is not a data object.  (File and file connections
          also have properties; that usage,
          however, is clearly separate from data entities)

My questions:

    Data objects in Fortran 90 have (1st pp section 5)
                --  attributes
                --  properties
                --  characteristics (see also 12.2.1.1)

    (1)  What is the relationship between attributes, properties, and
         characteristics?

    (2)  Is this complexity, which seems to have led to a number of
         difficulties, necessary?

ANSWER:

   1. The intended relationships:

      attributes -- Going by the 1st pp of section 5, attributes are
      type plus those things that can be specified in both a type
      declaration statement and a separate specification statement
      (DIMENSION, for example).

      properties -- those things derived from attributes or that could
      be specified in a separate specification statement but not in a
      type statement.  Also, having or not having a value is a
      property (glossary entry "defined").  The "array property", for
      example, is derived from the dimension attribute.  The only
      property specifiable in a separate specification statement is
      SEQUENCE.

      characteristics -- This word is used only a few times in
      discussions of data objects and was likely used as "normal
      English".  Unfortunately, "characteristics" is used in a
      technical way in chapter 12; that usage is disjoint from chapter
      5.

   2. No, this complexity is not necessary.

The use of "characteristics" is readily removed.

Fortran 90 is not dependent on the distinction between "properties" and
"attributes".  The distinction would seem to be only an artifact of
defining attributes in terms of specific specification statements and
thus needing another term for "attributes" not so specified.   While
this may have simplified the definition of attributes it has, as you've
noted, added complexity to the language definition and resulted in
errors in the standard itself.

To correct this we will:

    --  consolidate "attributes" and "properties" into a single concept,
        "attributes".

    --  explicitly list the attributes a data entity may have and how
        those attributes can be specified.

REFERENCES: ISO/IEC 1539:1991 (E), X3J3/92-305, X3J3/92-307

EDITS:

page xv pp beginning "Section 4 (Intrinsic"
   delete "the properties of" [xv]
   change "and properties" to "and attributes" [xv]

page xv pp beginning "Section 4 also" change "properties" to "concepts"

   Note: this change is consistent with prior pp "Note that only type
   concepts ..."

page xv pp beginning "Section 5" change "properties (attributes" to
   "attributes" [xv]

page xvii change "scope properties" to "scopes" [xvii]

1.5.3 change "Syntax conventions and characteristics" to "Syntax
conventions" [5:2]

   Rationale: eliminate spurious "characteristics"

2.3.1 page 11 2nd pp change "configure" to "specify"  [11:10]

   Rationale: that is why most are called specification statements.
   This change is being made in conjunction with the change to 2.4.

2.4 page 13 change "define the characteristics of" to "specify" [13:2]

2.4.1.1 page 13 1st pp change "The properties of intrinsic" to
"Intrinsic" [13:11]

2.4.7 page 15 change "characteristics" to "properties"

   Rationale: consistent with 1.3.2, page 1.

4.4.2 page 35 2nd pp
   change "have the SEQUENCE property" to "specify SEQUENCE" [35:43]

   Rationale: derived data type definitions are the subject and they
   are not data objects and thus do not have attributes.

4.4.2 page 35 2nd pp
   change "with the SEQUENCE property" to "with the SEQUENCE statement"
   [35:45]

4.4.2 page 36 pp beginning "The actual"
   change "SEQUENCE property" to "SEQUENCE statement" [36:39-40]

5 page 39 1st pp replace entire pp with the following pp and table:

Every data entity has a number of attributes (for example, type, rank,
and shape) that determine the uses of the data entity.  Not all
attributes apply to every data entity; the SEQUENCE attribute, for
example, applies only to derived type data entities.  A named data
object or a function result must not be specified explicitly to have a
particular attribute more than once in a scoping unit.

 attribute        how specified for data objects and function results
 ---------        ------------------------------------------------------

 type             either is determined implicitly by the first letter of
                    its name (5.3), or is specified explicitly in a
                    type-declaration-stmt
 accessibility    type-declaration or specification statement (PUBLIC,
                  PRIVATE)
 ALLOCATABLE      type-declaration or specification statement
 array            derived from rank
 EXTERNAL         type-declaration or specification statement
 intent           type-declaration or specification statement (IN, OUT,
                  INOUT)
 INTRINSIC        type-declaration or specification statement
 OPTIONAL         type-declaration or specification statement
 PARAMETER        type-declaration or PARAMETER statement
 POINTER          type-declaration or specification statement
 rank             type-declaration or specification statement (array-
                  spec)
 SAVE             type-declaration or specification statement
 scalar           derived from rank
 SEQUENCE         SEQUENCE statement in the derived type definition
 shape            type-declaration or specification statement (array-
                   spec)
 TARGET           type-declaration or specification statement
                                                              [39:3-9]

5.1.1.7 page 43 2nd pp
   change "SEQUENCE property" to "SEQUENCE attribute" [43:24]

5.1.2 page 43
   change heading "Attributes" to "Attribute specifiers" [43:31]

   Rationale: parallel construction to the 5.1.1 heading and necessary
   now that DIMENSION is not an attribute (array/scalar, rank and shape
   are).

5.1.2.1 through 5.1.2.11

   delete "attribute" from each heading [43:34 to 48:29]

   Rationale: parallel construction to  5.1.1.1 through 5.1.1.4 and
   necessary now that DIMENSION is not an attribute

5.1.2.4 page 46, 1st pp, sentence beginning "The DIMENSION"

   change "The DIMENSION attribute" to "DIMENSION" [45:2]

5.1.2.4 page 46, 1st pp, sentence beginning "The rank"

   change "DIMENSION attribute" to "DIMENSION specifier" [45:4]

5.1.2.4 page 46, 1st pp, sentence beginning "An array-spec"

   change "DIMENSION attribute" to "DIMENSION specifier" [45:5]

5.1.2.4 page 46, 1st pp, sentence beginning "If the DIMENSION"

   change "DIMENSION attribute" to "DIMENSION specifier" [45:6]

5.1.2.4 page 46, pp beginning "Examples"

   change "DIMENSION attribute specification" to "the DIMENSION
   specifier" [45:13]

5.1.2.4.3 page 46 pp beginning "The size, bounds, and shape of an"
   delete "except as an argument to an intrinsic inquiry function that
   is inquiring about argument presence, a property of the type or type
   parameters, or association status". [46:26-27]

   Rationale: a reference, 2.5.5, is the appearance of the data object
   in a context requiring its value.  The exceptions above are not
   references.

5.1.2.4.3 page 46 pp beginning "The size, bounds, and shape of the
target"
   delete "except as an argument to an intrinsic inquiry function that
   is inquiring about argument presence, a property of the type or type
   parameters, or association status". [46:31-33]

   Rationale: a reference, 2.5.5, is the appearance of the data object
   in a context requiring its value.  The exceptions above are not
   references.

5.2.5 page 50
   change "the DIMENSION attribute(5.1.2.4) and specifies the array
   properties" to "rank or rank and shape attributes" [50:35]

5.2.9 page 51 change "array properties" to "array attributes" [51:38]

5.2.10 page 53 1st pp change "properties" to "attributes" [53:39]

5.5.1 page 56 2nd pp change "properties" to "attributes" (two
occurrences) [56:37]

5.5.2 page 59 2nd pp change "properties" to "attributes" [59:4]

13.1 page 183 1st pp change "properties" to "attributes" [183:7]

glossary: array-valued - change "property" to "attribute" [254:26]

glossary: attribute - replace definition with "Attributes determine the
uses of a data
             entity (5)." [254:31

   Note: alternately, list the attributes.

glossary: defined - delete "the property of" [256:15]

glossary: explicit interface - delete "the property of" [257:1]

glossary: inquiry function - change "properties" to "attributes"
[257:34]

glossary: scalar -
       change "Not having the property of being an array"
       to       "Having a rank of 0" [259:40]

glossary: undefined - delete "the property of" [261:24]


SUBMITTED BY: Dick Weaver
HISTORY: Submitted as X3J3/92-202r
         Related question submitted in X3J3/92-248

--------------------------------------------------------------------------------

NUMBER: 000077
TITLE: Misc. questions
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  In using the standard, I've noted a number of corrections.
Are those corrections, expressed here as edits, right?

Rev 1: incorporates Bill Leonard's comments of 25 Sept.

       Intro page xiii pp beginning "Computation involving..."
       change "entities" to "data entities"

2.4.3.1, 1st pp page 14
       change "but subobjects" to "but subobjects of named objects"
       [14:2]

       Rationale:  '0123456789'(N:N) found on page 62, for example, is a
       constant subobject but is not referenced by a subobject
       designator.

2.5.6, 2nd pp page 16
       change "different entities" to "different data entities" [16:31]

       Rationale: the concept of storage applies only to data entities.

4.3.1.2, 3rd pp page 28
       change "such an entity" to "such a data entity" [28:35]

       Rationale: kind type applies only to data entities

4.3.1.3, 2nd pp page 29
       change "complex entity" to "complex data entity" [29:29]

       Rationale: complex is a data concept; consistent with nearby
       text.

4.4.1, page 34 3rd pp
       change "any entity" to "any data entity" [34:9]

       Rationale: other possibilities are covered in the rest of the
       sentence.

4.4.2, page 35 2nd pp
       change "an entity" to "a data entity" [35:46]

       Rationale: only data is being discussed.

4.4.2 page 36 1st line
       change "entities" to "data entities" [36:1]

4.4.5 page 37
       change "entities" to "data entities" (2 occurrences) [37:30]

5 page 39
       change section 5 title from "Data object..." to "Data entity ..."

       Rationale: Entity declarations, see R504, are for data objects
       and for function results.  A function result is not a data object
       (2.4.3 and 2.4.3.1), but function results and data objects are
       data entities.

       Note that an effect of this change  is to align the title "Data
       entity declarations ..." with R504      "entity-decl"

5 page 39 1st pp
       change "every data object" to "every data entity" [39:3]
       change "uses of the object" to "uses of the data entity] [39:4]
       Sentence beginning "Collectively" delete [39:4]

       (see prior rationale)

5 page 39 1st pp
        change "a named data object" to "a named data object or a
        function" (two occurrences) [39:5-6]

6.3.1 page 67
       change "entities" to "variables" [67:30]

       Rationale: only variables can be redefined or undefined

7.1.5 page 77 1st pp
       change "entities" to "data entities" [77:2]

7.1.6.2 page 79 pp beginning "If a specification..."
       change "an entity" to "a data entity"  [79:28]

7.1.7 page 80 pp beginning "The evaluation..."
       change "entity" to "data entity" [80:5]

7.1.7 page 80 pp beginning "For G..."
       change "entities" to "data entities" [80:11]

7.1.7 page 80 pp beginning "Execution of an ..."
       change "entity" to "data entity" [80:26]

7.1.7.1 page 81 pp beginning "Where X is ..."
       change "entities" to "data entities" [81:5]

7.5.3.2 page 93 last pp
       change "entities" to "data entities" (two occurrences) [93:41-42]

8.1.2.4 page 97 pp beginning "The execution of..."
       change "entities" to "data entities" [97:27]

9.1, page 109
       replace the sentence beginning "However, ..." with "However, a
       record as seen by a Fortran program does not necessarily
       correspond to a physical record on an external medium." [109:19]

       Rationale: The existing sentence talks about "physical entity",
       but the Fortran "entity" concept has no physical realization.
       (i.e., this use of "entity" is not consistent with its Fortran 90
       definition).  If footnotes are used then this sentence, less the
       "However,", would be much better as a footnote.

9.4.1, page 120 pp beginning "In a data transfer statement, the
       variable..."
       change "entity" to "variable" [120:33]

       Rationale: variables can only be associated with variables

9.4.2 page 123 1st pp
       change "entities" to "data entities" [123:18]

       Rationale: It is data entities that have a value.

9.4.4 page 125 item (5)
       change "entities" to "data entities"

9.4.4.1 page 125
       change "to the entities" to "to the variables" [125:28]

       Rationale: an input item that can receive a value is a variable

9.4.4.1 page 125
       change "from the entities" to "from the data entities" [125:30]

       Rationale: only data entities have values.

9.4.4.4 page 126 1st pp
       change "Data are transferred" to "Data is transferred" [126:10]
       change "and entities" to "and data entities" [126:10]
       change "the entities" to "the name-value subsequences" [126:15]
       Rationale: For "Data is transferred", collective nouns should be
       accompanied by singular verbs when the collection is to be taken
as a unit.

9.4.4.4 page 126 2nd pp
       change "entities" to "data entities" [126:18]

9.4.4.4 page 126 3nd pp
       change "entities" to "data entities" [126:20]

9.4.4.4 page 126 pp beginning "All values following ..."
       change "namelist entity (10.9) within the input records are
       transmitted to the matching entity specified in the
       namelist-group-object-list prior to processing any succeeding
       entity within the input record for namelist input statements"
       to "name-value subsequence (10.9) within the input records
       are transmitted to the matching variable specified in the
       namelist-group-object-list prior to processing any succeeding
       name-value subsequence within the input record for namelist input
       statements" [126:24-26]

       Rationale: name-value subsequence is the term in the referenced
       text. A namelist-group-object-list specifies variables, see R544.

9.4.4.4 page 126 pp beginning "All values following ..."
       change "If an entity" to  "If a variable" [126:26]
       change "of the entity" to  "of the variable" [126:27]
       change "for that entity" to  "for that variable" [126:28]

       Rationale: R544, variables are specified.

9.4.4.4 page 126 pp beginning "An input ..."
       change "an entity" to "a variable" [126:29]

       Rationale: variables can only be associated with variables

9.4.4.4 page 126 pp beginning "On output..."
       change "entity" to "data entity" [126:36]

       Rationale: only data entities have a value.

9.4.4.4.1 page 126 1st pp
       change "entities" to "data entities" [126:39]

9.4.4.4.1 page 126 bottom pp
       change "entity" to "variable" [126:44]

9.4.4.4.1 page 127 top
       change "real list entities" to "real variables" [127:1]
       change "complex list entity" to "complex variable" [127:2]
       change "corresponding entities" to "corresponding data
       entities"[127:2]
       change "if an entity" to "if a variable" [127:3]
       change "character entity" to "character variable" [127:3]
       change "complex entity" to "complex variable" [127:5]
       change "real entities" to "real variables" [127:5]

9.4.4.4.2 page 127 1st pp
       change "data are transferred" to "data is transferred" [127:17]
       change "entities" to "data entities" [127:17]

9.6.2 page 134 1st pp
       change "entity" to "variable" [134:7}

       Rationale: variables can only be associated with variables.

13.5.4 page 184
       change "entity" to "data entity" [184:18]

13.5.5 page 184
       change "entity" to "data entity" [184:23]

13.10.5 page 189
       change "entity" to "data entity" [189:48]

13.13.53 page 214
       change "entity" to "data entity" [214:32]

glossary entry "entity"
       delete from definition the terms: a named variable, an
       expression, a component of a structure, a named constant
       add to definition the term "a data entity" [256:38-39]

       Rationale: the terms deleted were not a complete replacement for
       "data entity".

glossary entry "main program"
       change "subprogram" to "external subprogram" [258:22]

       Rationale: consistent with glossary entry for "program unit"

ANSWER:

REFERENCES: ISO/IEC 1539:1991 (E) sections .....

EDIT:

SUBMITTED BY: Dick Weaver
HISTORY: Submitted as X3J3/92-203

--------------------------------------------------------------------------------

NUMBER: 000078
TITLE: Intrinsic functions in MODULE specification statements
KEYWORDS: USE associated, intrinsic function, MODULE, specification
expression
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Consider a module that references an intrinsic function in a
specification expression which declares a public data object in the
specification part of the module.  Section 11.3.2 states

"The local name of an entity made accessible by a USE statement may
appear in no other specification statement that would cause any
attribute (5.1.2) of the entity to be respecified in the scoping unit
that contains the USE statement, except that it may appear in a PUBLIC
or PRIVATE statement in the scoping unit of a module."

The question centers on whether a scoping unit which uses such a module
gains access to the intrinsic procedure through use association.
Specifically, are the following two cases standard conforming?

     Case 1:
       MODULE SPEC
         PARAMETER (J = 3)
         DIMENSION ARRAY (IABS(10 - J)) ! Reference to IABS
       END MODULE

       PROGRAM USER
         USE SPEC
         REAL,DIMENSION (100)  :: IABS  ! Legal to respecify IABS?
         ...
       END

    Case 2:
       MODULE SPEC
         PARAMETER (J = 3)
         INTRINSIC IABS             ! IABS explicitly declared INTRINSIC
         DIMENSION ARRAY (IABS(10 - J)) ! Reference to IABS
       END MODULE

       PROGRAM USER
         USE SPEC
         REAL,DIMENSION (100)  :: IABS  ! Legal to respecify IABS?
         ...
       END

ANSWER: Neither case is standard conforming.

Discussion: In both cases, IABS denotes an intrinsic procedure in module
SPEC. Procedures are entities which may be made accessible by USE
association, and in the absence of a PRIVATE declaration applicable to
IABS, they are made accessible.  Thus, the cited restriction applies and
the examples do not conform.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2

EDIT: None

SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE: 1992 11 10, new	000078
HISTORY: Initially drafted as X3J3/92-205
         Response in X3J3/92-278 -
         Approved by unanimous consent at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000079
TITLE: Automatic character and ALLOCATABLE, POINTER and TARGET
attributes
KEYWORDS: Allocatable, automatic, array, character, pointer, target
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Section 5.1 states:

The specification-expr (7.1.6.2) of a type-param-value (5.1.1.5) or an
array-spec (5.1.2.4) may be a nonconstant expression provided the
specification expression is in an interface body (12.3.2.1) or in the
specification part of a subprogram.  If the data object being declared
depends on the value of such a nonconstant expression and is not a dummy
argument, such an object is called an automatic data object.  An
automatic object must not appear in a SAVE or DATA statement nor be
declared with a SAVE attribute nor be initially defined with an =
initialization-expr.

Thus, a character object with a length-selector which is a nonconstant
type-param-value is an automatic object.

Section 5.1.2.9 states:

The ALLOCATABLE attribute specifies that objects declared in the
statement are allocatable arrays.  Such arrays must be deferred-shape
arrays whose shape is determined when space is allocated for each array
by the execution of an ALLOCATE statement (6.3.1).

The standard does not appear to prohibit allocatable arrays of automatic
objects.

Question 1: Is it the intent to allow allocatable arrays of automatic
character?

      FUNCTION FRED (J)
      CHARACTER(LEN=J), DIMENSION(:), ALLOCATABLE :: CH
      ALLOCATE (CH(100))

Question 2: If allocatable arrays of automatic objects are allowed, is
it correct to assume the array must not have the SAVE attribute?

Question 3: Character length is part of a character entity's type and
type parameters.  Was it intended that character entities whose length
is specified by a variable expression or a * (assumed length character)
be allowed to also have the POINTER or TARGET attribute?

The third constraint of Section 7.5.2 states

The target must be of the same type, type parameters, and rank as the
pointer.

In general, there should be no problem with allowing the POINTER and
TARGET attribute for automatic arrays.  However, there is a problem if
TARGET is intended to be allowed for automatic character, both scalar
and arrays, where the length is specified by a variable expression.
Character length is part of the type and type parameters, but where
length is specified by a variable, the above constraint cannot be
diagnosed at compile time.  Was it the intent to allow the TARGET
attribute on any automatic objects, only on automatic arrays except
where character length is specified by a variable expression, or for no
automatic objects? If the intent is to allow TARGET on all automatic
objects, the above constraint must be relaxed as it cannot be detected
at compile time.

ANSWER: The intent of the standard is to prohibit pointers and
allocatable arrays of character type whose length is specified by a
variable expression.  An edit is supplied to clarify this prohibition.
Also, the third constraint of section 7.5.2 cannot be diagnosed at
compile time for automatic character targets or targets that are
character dummy arguments with assumed length and, therefore, is relaxed
by one of the supplied edits.

REFERENCES: ISO/IEC 1539:1991 sections 5.1, 5.1.2.9, and 7.5.2.

EDITS:

   1. Section 5.1, add to the list of constraints: "The POINTER and
      ALLOCATABLE attributes must not be specified for an automatic data
      object."

   2. In the third constraint of section 7.5.2 delete ", type
      parameters,".  Add at the beginning of the paragraph following the
      constraints of section 7.5.2, "The target must have the same type
      parameters as the pointer."

SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE: 1993-02-10 000079
HISTORY: Initially drafted as X3J3/92-206 with two possible responses
        92-206b "Second Possibility" rejected at meeting 123 (9-9)
        92-206b "First Possibility" rejected at meeting 123 (14-5)
        "Second Possibility" adopted at meeting 124 (14-2)

--------------------------------------------------------------------------------

NUMBER: 000080
TITLE: Vector subscripts in masked array assignment statements
KEYWORDS: vector subscripts, WHERE statement, WHERE
construct, array assignment
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Is there a restriction on vector subscripts in masked array
assignments?

Question 1:  Is it intended to allow vector subscripts in masked array
assignment statements?

Question 2:  If the answer to question 1 is "yes", is the intent that
the following two programs are semantically equivalent; that is, should
they print the same results?

      PROGRAM ONE
      INTEGER, DIMENSION(5)  :: INDEX, J, K
      INDEX = (/ 1, 2, 3, 4, 5 /)
      J     = (/ 1, 2, 1, 1, 2 /)
      K     = (/ 1, 1, 2, 2, 2 /)
      WHERE (J == K)
        J(INDEX) = 0
      ELSE WHERE
        J(INDEX) = 1
      END WHERE
      PRINT *, J
      END

      PROGRAM TWO
      INTEGER, DIMENSION(5)  :: INDEX, J, K
      LOGICAL, DIMENSION(5)  :: MASK
      INDEX = (/ 1, 2, 3, 4, 5 /)
      J     = (/ 1, 2, 1, 1, 2 /)
      K     = (/ 1, 1, 2, 2, 2 /)
      MASK = J == K
      DO I = 1, 5
         IF (MASK(I)) J(INDEX(I)) = 0
      END DO
      DO I = 1, 5
         IF (.NOT.MASK(I)) J(INDEX(I)) = 1
      END DO
      PRINT *, J
      END

ANSWER: The answer to questions 1 and 2 is yes.

Discussion: Vector subscripts are allowed in masked array assignment
statements.  Section 7.5.3.2 describes the interpretation of vector
subscripts in <mask-expr> and in the <expr> of an <assignment-stmt>.
However, the interpretation of <variable> in <assignment-stmt> is not
completely defined.  If <variable> is an array section, for example, and
a nonelemental function reference occurs within a <section-subscript>,
the interpretation is not specified.  The edits below correct this.

REFERENCES: ISO/IEC 1539:1991 (E) section 7.5.3.2, section 6, section
6.2.2.

EDITS: In the second paragraph of section 7.5.3.2 after <expr>
[93:29], add "or <variable>".

In the third paragraph of section 7.5.3.2 after <expr> [93:34], add "or
<variable>".

SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE: 92-11-13	000080
HISTORY: Submitted as X3J3/92-207 at meeting 123
         Response in X3J3/92-291 approved at meeting 123 (UC)

--------------------------------------------------------------------------------

NUMBER: 000081
TITLE: Pointer actual argument overlap
KEYWORDS: pointer, target, actual argument, dummy argument, argument
associated
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  Section 12.5.2.9, Restrictions on entities associated with
dummy arguments, clearly states that if there is partial or complete
overlap between actual arguments associated with two different dummy
arguments of the same procedure, the overlapping portions may not be
defined, redefined, or undefined during the procedure execution.  It
continues:

This restriction applies equally to pointer targets.  For example , in

          REAL, DIMENSION (10), TARGET :: A
          REAL, DIMENSION (:), POINTER :: B, C
          B => A (1:5)
          C => A (3:9)
          CALL SUB (B, C)

B (3:5) cannot be defined because it is part of the actual argument
associated with the second dummy argument.  C (1:3) cannot be defined
because it is part of the argument associated with the first dummy
argument.  A (1:2) [which is B (1:2)] remains definable through the
first dummy argument and A (6:9) [which is C (4:7)] remains definable
through the second dummy argument.

Unfortunately, this example does not contain an explicit interface for
the called subroutine, nor are there sufficient words to clearly state
what is meant by the words and example provided.

Question 1: Do the above restrictions hold when both dummy arguments are
non-pointers?  In this case the following interface describes SUB.

      INTERFACE
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:) :: X, Y
        END SUBROUTINE
      END INTERFACE

Question 2: Same as question 1, only add the TARGET attribute to one or
both of the dummy arguments. The following interfaces may describe SUB.

      INTERFACE
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:), TARGET :: X, Y
        END SUBROUTINE
      END INTERFACE
or

      INTERFACE
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:) :: X, Y
        TARGET X
        END SUBROUTINE
      END INTERFACE

Question 3: Do the above restrictions hold *upon entry* when both dummy
arguments are pointers?  That is, *upon entry* to SUB, is it safe to
assume that pointer dummy arguments do not have overlapping elements
which may get defined during execution of SUB?  The following interface
describes SUB.

      INTERFACE
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:), POINTER :: X, Y
        END SUBROUTINE
      END INTERFACE

Question 4: Same as question 3, but one dummy argument is a pointer, one
has the target attribute.  *Upon entry* to SUB, is it safe to assume a
pointer dummy argument does not point to any elements of a target dummy
argument which may get defined during execution of SUB, but during the
execution of SUB such an association may come to exist?  The following
interface describes SUB.

      INTERFACE
        SUBROUTINE SUB (X, Y)
        REAL, DIMENSION (:) :: X, Y
        POINTER X
        TARGET Y
        END SUBROUTINE
      END INTERFACE

Question 5: Two derived type dummy arguments each have a subobject (or a
subobject of a subobject etc.) which are pointers with the same type,
kind type parameter, and rank.  *Upon entry* to the subroutine, is it
safe to assume such pointer subobjects do not have overlapping targets
which may get defined?  That is, in the following fragment, *upon entry*
to SUB, is it safe to assume X%PTR_1 and Y%PTR_2 cannot have overlapping
target elements which get defined during execution of SUB?

       SUBROUTINE SUB (X, Y)
       TYPE A
         SEQUENCE
         REAL, DIMENSION(:), POINTER :: PTR_1
       END TYPE

       TYPE B
         SEQUENCE
         REAL, DIMENSION(:), POINTER :: PTR_2
       END TYPE

       TYPE (A) :: X
       TYPE (B) :: Y

ANSWER: The restrictions hold for any two dummy arguments.  Thus the
answers to the specific questions are:

Question 1:  Yes
Question 2:  Yes
Question 3:  Yes (and Yes)
Question 4:  Yes
Question 5:  Yes

Discussion: Section 12.5.2.9 states

While an entity is associated with a dummy argument, no action may be
taken which affects the value or availability of the entity or any part
of it, except through the dummy argument.

Consider the case:

       SUBROUTINE SUB (B, C)
       REAL, POINTER, DIMENSION (:) :: B, C
       ...
       END SUBROUTINE

If the actual arguments have overlapping targets, then redefining B
within SUB, as in

       B = 0.

modifies the value of C and therefore is not permitted.  It does not
matter whether the dummy arguments have the POINTER or TARGET
attributes.

Had the case in Question 5 involved a single derived type dummy argument
with two or more pointer components, the answer would be 'No'.  It
cannot be assumed that two pointer subobjects of the same dummy argument
do not overlap.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.5.2.9

EDITS:  None
LAST SIGNIFICANT CHANGE:
SUBMITTED BY: Jon Steidel
HISTORY: Submitted as X3J3/92-208 at meeting 123
         Proposed response in X3J3/93-85 withdrawn at meeting 124

--------------------------------------------------------------------------------

NUMBER: 000082
TITLE: Host association and generic names
KEYWORDS: host association, generic names, accessibility
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Consider the program fragment

         1        INTERFACE  F
         2           FUNCTION X(Y)
                    ...
         3        CONTAINS
                    ...
         4           INTEGER F(10)
         5           I = F(2)

Reading in 12.1.2.2.1, Host association:

Statement 4 defines F to be an object-name (item 5 in the list on page
164).

Thus F is the name of a local entity and any entity of the host that has
F as its nongeneric name is inaccessible (text following list on page
164).

Therefore the generic name, F, in the host is accessible.

With that, is F(2) in statement 5 a reference to the generic name or to
the array name?

ANSWER: F(2) is a reference to the array name.

Discussion: The rules in 12.1.2.2.1 are incomplete as they fail to
address the case of a generic name in the host.  An edit is included to
supply the missing rules.  Applied to this case, they indicate that the
outer F is inaccessible because the inner F is nongeneric.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.1.2.2.1, 14.1.2.3, and
14.1.2.4

EDIT:  In 12.1.2.2.1, insert the following after the sentence containing
the long numbered list:

   If the local entity is nongeneric, any entity of the host that has
   this name as its generic name is inaccessible.  If the local entity
   is generic and an entity of the host has this name as its generic
   name, the versions of the host entity that are prohibited by 14.1.2.3
   from being merged with the local entity are instead inaccessible.

SUBMITTED BY: Richard Weaver
LAST SIGNIFICANT CHANGE: 93 02 11, initial response	000082
HISTORY: Submitted as X3J3/92-235
         Related question submitted in X3J3/92-209
         Response proposed in X3J3/92-104.
         Approved by unanimous consent at meeting 124.


--------------------------------------------------------------------------------

NUMBER: 000083
TITLE: Generic override of intrinsic procedure
KEYWORDS:
STATUS: X3J3 consideration in progress

QUESTION:  Because we all like to look at example code, I'll start with
that then point out what I'm looking for.  Consider if you will:

    INTERFACE SIN
      REAL FUNCTION MY_SIN(X)
        REAL, INTENT(IN) :: X
      END FUNCTION
    END INTERFACE

My question is this:  Can a generic interface that has the same name as
an intrinsic procedure override an existing intrinsic procedure?  That
is, can a user provide a generic interface definition such as shown
above where the intent is to invoke the user routine MY_SIN when the
generic name SIN is referenced with an argument of type default real?

Now for some background:  The only reference I've been able to find
anywhere in the standard that hints that a user can extend an intrinsic
procedure is the following sentence from 14.1.2.3:

When an intrinsic procedure, operator, or assignment is extended, the
rules apply as if the intrinsic consisted of a collection of specific
procedures, one for each allowed combination of type, kind type
parameter, and rank for each argument or operand.

I interpret this sentence to rule the above example to be NOT standard
conforming.  My reasoning is thus:  The portion of the sentence
beginning "the rules apply..." tells me that there is a "hidden" generic
interface for SIN that looks something like:

    INTERFACE SIN
      REAL FUNCTION DEFAULT_REAL_SIN(X)
        REAL, INTENT(IN) :: X
      END FUNCTION
      REAL FUNCTION REAL_FIRST_KIND_SIN(X)
        REAL(KIND=<SOME VALUE>), INTENT(IN) :: X
      END FUNCTION
      REAL FUNCTION REAL_SECOND_KIND_SIN(X)
        REAL(KIND=<SOME OTHER VALUE>), INTENT(IN) :: X
      END FUNCTION
      ...
      COMPLEX FUNCTION CSIN(X)
        COMPLEX, INTENT(IN) :: X
      END FUNCTION
      ...
    END INTERFACE

We know from 11.3.2 that if a user supplies a generic interface with the
name SIN, such as in my first example, the user interface will be
"unioned" with the "hidden generic intrinsic" interface.  By the rules
of chapter 14 for determining which specific interface to invoke, it
will be discovered that the MY_SIN specific interface and the
DEFAULT_REAL_SIN specific interface are ambiguous.  Thus, I conclude
that a a user can NOT redefine the interface of an existing intrinsic
procedure; a user can only EXTEND the interfaces (such as defining a
specific interface for SIN that accepts an argument of type logical).
This conclusion is consistent with the rules for overloading intrinsic
operators that prohibit a user interface from redefining, say, "+"for
two integer operands.

Do you agree with my interpretation?

ANSWER:

Discussion:

REFERENCES: ISO/IEC 1539:1991 (E) sections 11.3.2, 12.3.2.1, 14.1.2.3,
            and 14.1.2.4.1

EDITS:

SUBMITTED BY: Larry Rolison
LAST SIGNIFICANT CHANGE: 000083
HISTORY: Submitted as X3J3/92-210, meeting 123

--------------------------------------------------------------------------------

NUMBER: 000084
TITLE: Change masked array assignment constraint to prose
KEYWORDS: masked array assignment, WHERE statement,
WHERE construct, shape, constraint
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  The first constraint following rule R743:

    Constraint:  In each assignment-stmt, the mask-expr and the variable
    being defined must be arrays of the same shape.

However, it may be impossible to determine that the mask-expr and the
variable being defined are of the same shape at compile time.  A program
can be constructed quite easily in which the shapes of these entities
are determined dynamically at run time.
For example:

           INTEGER ARRAY_1(100), ARRAY_2(100), START, END
           READ(5,*) START, END, ARRAY_1, ARRAY_2

           WHERE (ARRAY_1(START:END) .NE. 0)
                  ARRAY_2(START:END) =                    &
                  ARRAY_2(START:END) / ARRAY_1(START:END)
           ENDWHERE

The term "shape" is defined in section 2.4.5 Array as follows:

The shape of an array is determined by its rank AND ITS EXTENT IN EACH
DIMENSION, and may be represented as a rank-one array whose elements are
the extents.

Since all constraints are intended to provide additional information to
(or in some cases limit) the BNF syntax rules and are intended to be
determinable at compile time, and since the extents of a mask-expr or
variable in a masked array assignment can not always be determined at
compile time, this constraint is in error and should be changed from a
constraint to a prose restriction.

ANSWER: Yes, the constraint should be changed.

REFERENCES: ISO/IEC 1539:1991 (E) sections 7.5.3.1 and 7.5.3.2,
            in particular the first constraint following rule R743.

EDIT:  Delete the first constraint following rule R743.  Use the
constraint body as the new first paragraph of section 7.5.3.2.

SUBMITTED BY: Larry Rolison
HISTORY: Submitted as X3J3/92-211 at Meeting 123.
         Approved at meeting 123 (uc)

--------------------------------------------------------------------------------

NUMBER: 000085
TITLE: Nondefault integer data type for UNIT=, RECL=, and REC=
specifiers
KEYWORDS: unit, data type
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  Rules R902, R905, and R912 allow any type of integer for
UNIT=, RECL=, and REC= respectively.  Should a nondefault integer data
type be allowed for these specifiers in the <io-control-spec-list>?

ANSWER: Yes.  The standard is consistent in requiring default KIND
scalar integer variables in I/O statements when values are returned to
the program in such a variable.  When an integer value is required as the
value for an I/O specifier in any of <connect-spec-list>, <close-spec-
list>, <io-control-spec-list>, <position-spec-list>, and <inquire-spec-
list>, but no value is returned for that specifier, then any KIND of
scalar integer expression is consistently allowed.

REFERENCES: ISO/IEC 1539:1991 (E) section 9.3, 9.3.4, and 9.4.1

EDITS: None

SUBMITTED BY: Joanne Brixius X3J3/92-212
HISTORY: Questions submitted as X3J3/92-212, X3J3/92-213, and
         X3J3/92-243
         Approved as X3J3/92-274 at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000086	
TITLE: USE and host association
KEYWORDS: Use, association, host, accumulating, generic interface,
EXTERNAL
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Use association, 11.3.2 states

The USE statement provides the means by which a  scoping unit access
named data objects, derived types,  interface blocks, procedures,
generic identifiers  (12.3.2.1), and namelist groups in a module.

Host association, 12.1.2.2.1 states

An internal subprogram, a module subprogram, or a  derived-type
definition has access to the named  entities from its host via host
association. The  accessed entities are known by the same name and have
the same attributes as in the host and are variables,  constants,
procedures including interfaces, derived  types, type parameters,
derived-type components, and  namelist groups.

Question 1:  Do use and host association access the same entities? What
entities does each access?

Question 2:  For both use and host association, what entities are not
accessed?

Question 3:  For host and use association, if the host or module
referenced  contains an EXTERNAL statement for ABC, is ABC an accessed
entity  that has the EXTERNAL attribute?  Note that an EXTERNAL
statement  is not a "named entity" (the statement has no name) and the
procedure named in the statement is not in the host or module  (that is
why the EXTERNAL statement).

The answer to question 1 or 2 should also answer this question.

Question 4:   Given the following

       PROGRAM  A              MODULE M
         USE X                         USE Y

       CONTAINS
         SUBROUTINE B
          USE M

is subprogram B associated in some way with X?  What way?  Note that A,
the  host of B, "accesses" entities in X by use association; the
entities in X are  not "in" B's host.

Question 5:  In the same example is subprogram B associated in some way
with  Y?  What way?  As with question 4 note that the entities in Y are
"accessed" from M; the entities in Y are not in M and use  association
is to the entities "in the module".

Question 6:  Given the following:

       MODULE A           ! level 1 host

       USE AA
       INTERFACE F
        ...
       CONTAINS

       SUBROUTINE B     ! module subroutine, level 2 host
       USE BB
       INTERFACE F
       ....

         CONTAINS
         SUBROUTINE C  ! internal subprogram
         USE CC
         INTERFACE F
         ...
         .... = F(X)            ! an invocation of the generic name F

and where modules AA, BB, and CC all contain a generic interface  for F:

How is the invocation of the generic name F resolved? (in what  sequence
are which hosts and uses considered?)

Note the levels of nesting:  A contains B contains C.  Section
14.1.2.4.1, "Resolving procedure references to names established  to be
generic", (3), seems to consider only B, the host of C, and  not A.

ANSWER:

Answer 1:Entities declared PRIVATE are potentially accessible by host
association but not by use association.  Otherwise, it was  intended
that the classes of entities made accessible by these  two forms of
association be the same.  These are named data  objects (including both
constants and variables), derived types  derived type components,
procedures (both those defined in the  host or module and those declared
there and defined elsewhere;  both those identified by names and those
identified by other  generic identifiers), and namelist groups. See
sections 12.1.2.1  and 11.3.2. An edit is provided to make the cited
text  consistent.

Answer 2:  Entities not in the list in 12.1.2.1 and 11.3.2 are not made
accessible. For example, FORMAT statement labels, construct  names, and
common block names are not made accessible.

Answer 3:  In such an example, ABC would be accessible. Section 12.3.2.2
indicates that the EXTERNAL statement specifies a list of names  that
are procedures. In the host or module, ABC is the name of a  procedure
and thus is potentially an accessible entity; it is not  necessary that
the definition of ABC be present in the host or  module.

Answer 4:  The entities of module X made accessible in A by use
association  are made accessible in B by host association.  Note that
each  such entity has a local name (or other identifier) in A. See
Section 11.3.2.

Answer 5:  The entities of module Y made accessible in M by use
association  are made accessible in B by use association.  Note that
each such  entity has a local name (or other identifier) in M. See
Section  11.3.2.

Answer 6:  In effect, first C and CC are checked for a consistent
specific   interface , then B and BB, then A and AA, and finally (if F
were  the generic name of an intrinsic function) the intrinsics are
checked.

In applying 14.1.2.4.1 to a reference in C, item (1) provides the check
of  interfaces in C (including those made accessible from cc), and item
(3)  provides for a recursive application of 14.1.2.4.1 to b.  In this
recursive  application, (1) checks B (and BB), and (3) results in a
further recursive  application of 14.1.2.4.1 to A.  In this application,
(1) checks A (and AA),  (3) is not applicable, and (4) checks the
intrinsics. 14.1.2.3 establishes  that there must be no ambiguity in
distinguishing the interfaces declared in C  from those made accessible
from CC.

REFERENCES: ISO/IEC 1539:1991 (E) sections 11.3.2, 12.1.2.2.1, 14.1.2.3,
and  14.1.2.4.1.

EDIT: In section 12.1.2.2.1 replace the second sentence of the first
paragraph with:

The accessed entities are known by the same name and  have the same
attributes as in the host and are named  data objects, derived types,
derived type components,  interface blocks, procedures, generic
identifiers  (12.3.2.1), and namelist groups.

SUBMITTED BY: Richard Weaver
LAST SIGNIFICANT CHANGE: 1992-11-10, new	000086
HISTORY: Submitted in X3J3/92-214
         Response proposed in 92-281 - meeting 123
         (vote of 11-7 was insufficient for approval)
         Revised response proposed in 93-030r1.
         Approved at meeting 124 by a vote of (15-1)

--------------------------------------------------------------------------------

NUMBER: 000087
TITLE: PARAMETER statements and SAVE statements
KEYWORDS: PARAMETER, named constant, SAVE
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Can a named constant appear in a SAVE statement?  In Fortran
77 named constants were not allowed to appear in a SAVE statement.
Fortran 90 appears to allow named constants in SAVE statements.

ANSWER: No, a named constant must not appear in a SAVE statement.  Edits
are provided to indicate this restriction.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1, 5.1.2.5

EDITS:

   1. Change the sixteenth constraint of section 5.1 to

      The SAVE attribute must not be specified for an object that is in
      a common block, a dummy argument, a procedure, a function result,
      an automatic data object, or an object with the PARAMETER
      attribute.

   2. Change the penultimate sentence of 5.1.2.5 from "The SAVE
      attribute ... result, or an automatic data object." to "The SAVE
      attribute ... result, an automatic data object, or an object with
      the PARAMETER attribute."

SUBMITTED BY: Janice C. Shepherd  93-011
LAST SIGNIFICANT CHANGE:  1993-02-10	000087
HISTORY: Submitted as 93-011 with proposed response
         After minor edits, adopted by unanimous consent at meeting 124

--------------------------------------------------------------------------------

NUMBER: 000088
TITLE: Common block names and local names
KEYWORDS: common block name, local name
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  Section 12.1.2.2.1 says

    A name that appears in the scoping unit as

    (5) an object name in an entity-decl ...

    ... is the name of a local entity and any entity of the host that
    has this as its nongeneric name is inaccessible.

Is this consistent with 14.1.2.1 "Common Blocks" ?

ANSWER: Yes.  Accessibility does not apply to common block names.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.1.2.2.1, 14.1.2.1.

EDIT: None

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11, first draft response	000088
HISTORY: Submitted as X3J3/92-219
         Response proposed in X3J3/92-324, meeting 123 (vote of 14-6 was
         insufficient for approval)

--------------------------------------------------------------------------------

NUMBER: 000089
TITLE: Errors in the DATA statement description
KEYWORDS: DATA statement, structure constructor, named constant,
constant
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Does the text description in section 5.2.9 [53:4-20] of the
values permitted in a DATA statement contain a recurring flaw?  This
description continually refers to the constant values in the list as
simply "constants".  According to R533 a structure constructor is
allowed in the list, but it is not a constant; rather it is a constant
expression.  This is demonstrated by:

The definition of "constant" in 2.4.3.1.2.  There are only two broad
categories of constants defined:  named constants and literal constants.

The syntax rules for "constant" (R305-R307) reinforce this definition by
defining only two nonterminals:  literal-constant and named-constant.

The description of the structure constructor in section 4.4.4 [37:10-11]
states:

A structure constructor whose component values are all constant
expressions is a derived-type constant expression.

ANSWER: Yes, there is a flaw in Section 5.2.9 in the text description of
the values permitted in a DATA statement.  The following edits eliminate
this flaw.

Discussion: In considering the edits to Section 5.2.9 to repair this
flaw, it became apparent that the second sentence in the third paragraph
following the constraints, [53:4-5] "Each such value ... host
association." applied equally to named constants and structure
constructors.  This means that the type definition for the structure
constructor must be accessible.  Furthermore, this should be stated as a
constraint.

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.2.9, 2.4.3.1.2, 3.2.3,
4.4.4

EDITS:

   1. Add a new constraint after the second constraint following R537:

      If a DATA statement constant value is a named constant or a
      structure constructor, the named constant or derived type must
      have been declared previously in the scoping unit or made
      accessible by use or host association.

   2. Delete the second sentence in the third paragraph following the
      constraints [53:4-5], "Each such value ...host association."

   3. In the third sentence [53:6], replace "following constant" with
      "following constant value".

   4. In the next two paragraphs [53:11, 17], change "constant" to
      "constant value" (twice)

   5. In the sixth paragraph [53:18, 19], change "constant" to "constant
      or structure constructor" (twice)

SUBMITTED BY: Larry Rolison - X3J3/92-221
LAST SIGNIFICANT CHANGE:  1993-02-10	000089
HISTORY: Submitted as X3J3/92-221 at Meeting 123
         Draft response X3J3/93-032 prepared for consideration
         at Meeting 124
         Revised as X3J3/93-032r1 based on comments from Rolison and
         adopted at meeting 124 by unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000090
TITLE: Subroutine and function names in nested scopes
KEYWORDS: procedure names, nested scopes
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  Section 12.1.2.2.1 says

   A name that appears in the scoping unit as

   (2)  a function-name in a function-stmt ...

   (3)  a subroutine-name in a subroutine-stmt...

   is the name of a local entity and any entity of the host that has this
   as its nongeneric name is inaccessible.  Entities that are local
   (14.1.2) to a procedure are not accessible to its host.

 1. If this is true, how can hosts reference internal procedures, module
    procedures and interface blocks (the text in 2.2.3.3 pertains only to
    internal procedures and is somewhat vague) ?

 2. Are entities local to an interface body accessible to the host?
    (i.e., should the "Entities that are local ..." rule above be more
    general?)

ANSWER:

1. The text cited from sections 12.1.2.2.1 and 14.1.2 contains errors.
   The text in 12.1.2.2.1 was intended to describe how names established
   to be:

   a) A derived type name in the scope of an internal subprogram or in
      the scope of a module subprogram;
   b) an internal subprogram in the scope of a module subprogram;
   c) a procedure name by its appearance in an interface body in the scope
      of an internal subprogram or in the scope of a module subprogram;

makes any entity of the host of the specified scope that has the name as
its nongeneric name inaccessible. Edits are provided to clarify this
intent.

Derived-type statements, SUBROUTINE statements and FUNCTION statements
establish a new scope, but the derived-type name, subroutine name and
function name defined by those statements are local entities of the host
scope.

Additional rules are then needed to prevent the name of a module
procedure, internal procedure, procedure specified in an interface body,
or derived type from conflicting with the names of local and global
entities within the scope. These rules are included in the edits below.

2. No, entities local to an interface body are not accessible to the
host.  This is part of the more general rule stated in the first two
paragraphs of section 14.

"Entities are identified by lexical tokens within a scope..."

"By means of association, an entity may be referred to... in a different
scoping unit..."

Thus, in the absence of association, an entity is not accessible in
different scoping units. The statement in section 12.1.2.2.1 that
"Entities that are local (14.1.2) to a procedure are not accessible to
its host." is there to explain two things:

a)  Host association allows entities of a host to be accessed in a
procedure but entities that are local to a procedure are not accessible
to its host.

b)  Host association applies to derived-type definitions and component
names local to those derived-type definitions are accessible in the host
scope.


REFERENCES: ISO/IEC 1539:1991 (E) sections 2.2.3.3, 12.1.2.2.1, and
            14.1.2

EDITS:

In section 12.1.2.2.1 after the second sentence of the second paragraph
add:

If a scoping unit contains an interface body for an external procedure
the name of that procedure is a global name and any entity of the host
that has this as its nongeneric name is inaccessible.

In the list specified in section 12.1.2.2.1:

   1. Delete items (1), (3) and (4) and renumber the rest.
   2. In item (2) delete "in a <function-stmt>," and also delete the
      comma preceding the "or".

In section 12.1.2.2.1 ahead of the sentence "Entities that are local to
(14.1.2) to a procedure are not accessible to its host." add:

"If a scoping unit contains a subprogram or a derived type definition
the name of the subprogram or derived type is the name of a local entity
and any entity of the host that has this as its nongeneric name is
inaccessible."

At the end of the last sentence of section 14.1.2 add

"except in the following cases:

   1. The name of a derived type must not be used as the name of a type
      component within the scope of that derived type.

   2. The name that appears as a  <subroutine-name> in a <subroutine-
      stmt> has limited use within the scope established by the
      <subroutine-stmt>.  It can be used to identify recursive
      references of the subroutine or to identify the name of a common
      block.

   3. The name that appears as a <function-name> in a <function-stmt>
      has limited use within the scope established by that <function-
      stmt>. It can be used to identify the result variable, to identify
      recursive references of the function, or to identify the name of a
      common block.

   4. The name that appears as an <entity-name> in an <entry-stmt> has
      limited use within the scope of the subprogram in which the
      <entity- stmt> appears. It can be used to identify the name of a
      common block., to identify recursive references, or if the
      subprogram is a function to identify the result variable."


SUBMITTED BY: Richard Weaver, X3J3/92-220
LAST SIGNIFICANT CHANGE: 1993 meeting 124, 	000090
HISTORY: first draft response in X3J3/92-328 (failed meeting 123)
         Alternate proposal submitted X3J3/93-107
         Action deferred at meeting 124 because of short lead time.

--------------------------------------------------------------------------------

NUMBER: 000091
TITLE: Constraint diagnosis for PRIVATE attribute
KEYWORDS: PRIVATE, modules, constraints
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  Must the violation of constraints be diagnosed when the
criteria for the constraint is violated or confirmed across module
definitions?  More specifically should the following two constraints:

The third constraint following R522:  [49:26-28]

A module procedure that has a dummy argument or function result of a
type that has PRIVATE accessibility must have PRIVATE accessibility and
must not have a generic identifier that has PUBLIC accessibility.

The fourth constraint following R424:  [33:10-11]

If a component of a derived type is of a type declared to be private,
either the derived type definition must contain the PRIVATE statement or
the derived type must be private.

be diagnosed in the following program?:

          MODULE A
            TYPE X
              INTEGER :: I
            END TYPE X
            TYPE Y
              TYPE (X) :: R    ! Note component of type X
            END TYPE Y
            CONTAINS
            FUNCTION F()        ! Module function of type X
              TYPE(X) :: F
            END FUNCTION F
          END MODULE A

          MODULE B
            USE A
            PRIVATE :: X  ! Note component of type Y now has
                          ! a PRIVATE attribute
                          ! Note also that module function F now
                          ! has PRIVATE attribute
          END MODULE B


ANSWER: Yes

Discussion: Module A by itself is standard-conforming.  It is not until
module A is used by module B that the cited constraints are violated.

REFERENCES: ISO/IEC 1539:1991 (E) sections 1.4, 4.4.1, and 5.2.3

EDITS:  None.

SUBMITTED BY: Maureen Hoffert
LAST SIGNIFICANT CHANGE: 1993-02-10	00091
HISTORY: Submitted at 123 in X3J3/92-225.
         Response in X3J3/93-024 adopted at meeting 124 by a vote of
         (14-3)

--------------------------------------------------------------------------------

NUMBER: 000092
TITLE: Pointer and storage association
KEYWORDS: pointer association, storage association, ASSOCIATED
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Consider the following example program:

      PROGRAM PROG
        INTEGER   :: VAR
        COMMON /COM/ VAR
        VAR = 5
        CALL SUB
      END PROGRAM PROG
      SUBROUTINE SUB
        INTEGER,POINTER :: PTR
        INTEGER,TARGET  :: TGT
        COMMON /COM/ TGT
        PTR => TGT
        ...
      END SUBROUTINE SUB

Is the pointer assignment legal? Although the entity named TGT was
declared with the TARGET attribute, a storage associated entity, VAR,
was not.

ANSWER: The pointer assignment is legal only because PTR is declared
within the scoping unit of SUB and is not accessible outside the scoping
unit of SUB.

Discussion: By the rules of 6.3.3.2, PTR becomes undefined upon return
from SUB to the calling program.  Note however that if PTR was also
accessible in the scoping unit PROG and the variable VAR was not
declared with the TARGET attribute, the program would not be standard
conforming.  The following example is not standard conforming.

      PROGRAM PROG
        INTEGER         :: VAR
        INTEGER,POINTER :: PTR
        COMMON /COM/ VAR, PTR
        VAR = 5
        CALL SUB
        ...
      END PROGRAM PROG
      SUBROUTINE SUB
        INTEGER,POINTER :: PTR
        INTEGER,TARGET  :: TGT
        COMMON /COM/ TGT, PTR
        PTR => TGT
        ...
      END SUBROUTINE SUB

After the call to SUB, PTR is pointer associated with the same storage
that VAR is storage associated with.  In this case, VAR must be declared
with the TARGET attribute in the scoping unit PROG for the program to be
standard conforming.

REFERENCES: ISO/IEC 1539:1991 (E) section 6.3.3.2.

EDITS: None.

SUBMITTED BY: Len Moss
LAST SIGNIFICANT CHANGE:  1993-02-10	000092
HISTORY: Issue arose during Victoria (1992) WG5 meeting, while reviewing
         various questions concerning S20.121(27)
         Separate request submitted following meeting 121
         Submitted as X3J3/92-226 at meeting 123
         Response in X3J3/93-034r adopted at meeting 124 by
         unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000093
TITLE: Scalar pointer function results
KEYWORDS: function results, pointer attribute
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  May a scalar function result have the pointer attribute?

ANSWER: Yes.

Discussion: The text that appears as the last paragraph of 5.1.2.4.3 is
intended to apply to all function results even though it appears in a
section titled, "Deferred-shape array".  To clarify this point, the edit
below moves that text to section 5.2 which has the more general title,
"Type declaration statements".

REFERENCES: ISO/IEC 1539:1991 (E) sections 5.1 and 5.1.2.4.3

EDIT:  Delete the last paragraph of 5.1.2.4.3 [46:43].  Insert the
following paragraph after the second paragraph following the constraints
in 5.1 [40:38+]

       A function result may be declared to have the pointer attribute.

SUBMITTED BY: Len Moss - X3J3/92-227
LAST SIGNIFICANT CHANGE: 1993-02-10	000093
HISTORY: Submitted as X3J3/92-227 at meeting 123
         Proposed response in X3J3/93-075 adopted at meeting 124 by
         unanimous consent

--------------------------------------------------------------------------------

NUMBER: 000094
TITLE: Functions in WRITE statement implied-DO loops
KEYWORDS: implied-DO, WRITE, function
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  An example of an array-result function is:

          FUNCTION F(I)
          DIMENSION F(I)
          ...
          END

Question 1:  If this function is used in an output list with an implied-
DO:

          WRITE(6,100) (F(I), I=1,N)

Does the output list consist of N arrays of the array-result of function
F(I) or does the output list consist of N array element references of
F(I)?

Question 2:  A more complicated example is the use of a multidimensional
array:

          FUNCTION F(I,J)
          DIMENSION F(I,J)
          ...
          END

     The function is used in an output list with an implied-DO:

          WRITE(6,100) ((F(I,J), I=1,N), J=1,K)

     Does the output list consist of N*K arrays of the array-result of
function F(I,J)?

Question 3:  An example of a character variable-length array-result
function is:

          FUNCTION F(I,J)
          DIMENSION F(I)
          CHARACTER(LEN=J) F
          ...
          END

     The function is used in an output list with an implied-DO:

          WRITE(6,100) ( ( F ( I, J ), I=1,N ), J=1,K )

     Does the output list consist of N*K different sized arrays of
varying character
     length function results?

Question 4:  Should an implied-DO loop in an output statement be
restricted to a scalar function result?  The DATA statement <data-i-do-
object> is limited to an array element, a <scalar-structure-component>,
or a <data-implied-do>.  See R536 in section 5.2.9.

ANSWER:

  (1) The output list consists of N arrays of the array-result of
      function F(I).
  (2) Yes.
  (3) Yes.
  (4) No.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.4, 12.4.2, and rule R1209.

EDIT: None.

SUBMITTED BY: Joanne Brixius X3J3/92-230
HISTORY: Submitted as X3J3/92-230
         Approved as X3J3/92-292 at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000095
TITLE: Functions in IOLENGTH implied-DO loops
KEYWORDS: implied-DO, INQUIRE, IOLENGTH, function
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  In section, 9.6.3, the INQUIRE with IOLENGTH specifier is
described.

The use of implied-DO and function references in an output list impacts
the INQUIRE statement that used the IOLENGTH specifier with an output
list.

An example of a array-result function is:

          FUNCTION F(I)
          DIMENSION F(I)
          INTEGER I
          REAL F(I)
          ...
          END

Question 1  If the function is used in an output list with an implied-
DO:

          INTEGER ISIZE
          INQUIRE(IOLENGTH=ISIZE) (F(I), I=1,N)

Does the output list consist of N arrays of the array-result of function
F(I) or does the output list consist of N array element references of
F(I)?  See Question 3.

The function F(I) must be referenced N times to be able to determine the
size of the result.  The size of the function result cannot be
determined by a declaration of the function in the caller.  The function
must be executed to determine the size of the result.

Question 2:  An example of a character variable-length array-result
function is:

          FUNCTION F(I,J)
          DIMENSION F(I)
          INTEGER I,J
          CHARACTER(LEN=J) F
          ...
          END

The function is used in an output list with an implied-DO:

          INQUIRE(IOLENGTH=ISIZE) ( ( F ( I, J ), I=1,N ), J=1,K )

Does the output list consist of N*K different sized arrays of varying
character length function results?  The actual size of the result can
only be determined by executing the function.

Question 3:  Should an implied-DO loop in an INQUIRE statement with an
IOLENGTH  specifier be restricted to a scalar function result?  The DATA
statement <data-i-do-object> is limited to an array element, a <scalar-
structure-component>, or a <data-implied-do>.  See R536  in section
5.2.9. This would allow the determination of the size of a function
reference without actual execution of the function.

ANSWERS:

1. The output list in the INQUIRE statement "references" the function
   "F" N times.  Each reference returns an array valued result.  This is
   not necessarily a reference in the sense of an actual function call.

   Your statement about referencing the function is not correct. An
   implementation is allowed to call the function if it so wishes, but is
   not required to do so.  In the presence of an explicit interface it is
   possible some implementations will not call the function, or may call
   it fewer than N times.

2. The output list consists of N*K different sized arrays of varying
   length character function results.  The implementation is not required
   to actually call the function.

3. No.

REFERENCES  ISO/IEC 1539:1991 (E) sections 9.6.3, 7.1.7.1

EDITS: None.

SUBMITTED BY: Joanne Brixius X3J3/92-231
LAST SIGNIFICANT CHANGE:	000095
HISTORY: Submitted as X3J3/92-231
         Approved as X3J3/92-311 at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000096
TITLE: Definition of "Declaration"
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  "Declaration" is a significant concept of Fortran 90.

Section 5 is titled "Data object declarations and specifications" and
what were in Fortran 77 "type statements" are now "type declaration
statements".  5.1.1 says "A type specifier specifies the type of all
entities declared in an entity declaration list."

Nowhere, though, can I find a definition of "declaration".

What does it mean, in Fortran 90, to "declare" something?

ANSWER: We will add a definition of "declaration" to the glossary.  For
clarity, we will also add a definition of "specification".

REFERENCES:  ISO/IEC 1539:1991 (E) sections .....

EDIT:  add to page 260 after "size" [260:14+]

Specification: a specification assigns attributes and properties to
named data objects.

add to page 256 after "datum" [256:10+]

Declaration: The process of specifying an attribute or a property of a
named data object.

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11	000096
HISTORY: Submitted as X3J3/92-232
         Draft response in X3J3/92232r, withdrawn for reconsideration

--------------------------------------------------------------------------------

NUMBER: 000097
TITLE: Specification expression
KEYWORDS: constant expression, specification expression
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTIONS:  In section 7.1.6.2 "Specification expression":

   1. In item (9) should not the restriction "defined by an ALLOCATE
      statement" be "allocatable" instead? That is, the ALLOCATE
      statement does not have to exist, it is being allocatable -- even
      if never allocated -- that is restricted. [79:14-15]

      And the same comment re pointer assignment. [79:14-15]

   2. Would Item (9) be clarified if "local" were inserted before
      "variable"? [79:14]

   3. In the text beginning "and where any subscript ..." should not
      "is" be "must be"?  As written it says that any subscript is
      a restricted expression. [79:17]

   4. In the text beginning "A specification expression (R509, R514,
      R515)... should not the "(R509, R514, R515)" be deleted?

ANSWER:

   1. Yes, see edits below. Edits are provided for similar problems in
      other sections.

   2. No.

   3. No, this is part of a long and complex sentence which begins on
      the previous page.  'Is' is the correct form and parallels the
      rest of the sentence and describes what a restricted expression
      'is', not what a subscript is.

   4. There is redundancy, but not an error.

REFERENCES: ISO/IEC 1539:1991 (E) sections 7.1.6.1, 7.1.6.2

EDITS:

   Replace 7.1.6.1 (6), in the first list, with the following:
      (6) A reference to
          a) an array inquiry function (13.10.15) other than ALLOCATED
          b) the bit inquiry function BIT_SIZE,
          c) the character inquiry function LEN,
          d) the kind inquiry function KIND,
          e) or a numeric inquiry function (13.10.8)
             where each argument of the function is either
             a) a constant expression
             b) a variable whose type parameters or bounds inquired
                about are not assumed,
             c) or a variable that does not have the ALLOCATABLE or
                POINTER attribute, or

   Replace 7.1.6.1 (6), in the second list with the following:
      (6) A reference to
          a) an array inquiry function (13.10.15) other than ALLOCATED
          b) the bit inquiry function BIT_SIZE,
          c) the character inquiry function LEN,
          d) the kind inquiry function KIND,
          e) or a numeric inquiry function (13.10.8)
             where each argument of the function is either
             a) an initialization expression
             b) a variable whose type parameters or bounds inquired
                about are not assumed,
             c) or a variable that does not have the ALLOCATABLE or
                POINTER attribute, or

   Replace 7.1.6.2 (9) with the following:
      (9) A reference to
          a) an array inquiry function (13.10.15) other than ALLOCATED
          b) the bit inquiry function BIT_SIZE,
          c) the character inquiry function LEN,
          d) the kind inquiry function KIND,
          e) or a numeric inquiry function (13.10.8)
             where each argument of the function is either
             a) a restricted expression
             b) a variable whose type parameters or bounds inquired
                about are not assumed,
             c) or a variable that does not have the ALLOCATABLE or
                POINTER attribute, or

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 93-02-12	000097
HISTORY: Submitted as X3J3/92-233r at meeting 123
         Revised edit submitted in X3J3/93-086 at meeting 124; passed
         15-2

--------------------------------------------------------------------------------

NUMBER: 000098
TITLE: KIND param and list directed I/O
KEYWORDS: unit, data type
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  In an I/O record, can the kind-param of a constant be a named
constant?

ANSWER: No.  Section 5.1.2.1 which describes where and when named
constants are allowed does not discuss named constants in the context of
an I/O record; therefore, named constants are not allowed in an I/O
record.  The edit below clarifies what the committee intended, by
specifically addressing values in I/O records.

REFERENCES: ISO/IEC 1539:1991 (E) section 5.1.2.1

EDIT:  In section 5.1.2.1, after the sentence "A named constant must not
appear within a format specification (10.1.1)." add the following
sentence:

      "A named constant must not appear within an I/O record (9.1)."

SUBMITTED BY: Joanne Brixius X3J3/92-234
HISTORY: Submitted as X3J3/92-234
         Approved as X3J3/92-273r2 at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000099
TITLE: Generic interfaces
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:

   11.3.2, page 158, pp beginning "If two or more" says that:

        If two or more generic interfaces that are accessible in a
        scoping unit have the same name, ..., they are interpreted as a
        single generic interface.

   14.1.2.4.1, page 244, says

        (1) If the reference ... of an interface block that has that
            name and either is contained in the scoping unit ... or is
            made accessible by a USE statement...

        (3) ... if the name is established to be generic in that host
            scoping unit ...

Question 1:  What section 11 seems to say will be treated as a single
interface is, in Section 14, actually treated as individual interfaces.
Which is correct?

Question 2:  If the text from 11.3.2 above applies to more than just USE
association, should it be moved to 12.3.2.1 "Procedure Interface Block"?

ANSWER:

REFERENCES: ISO/IEC 1539:1991 (E) sections .....

EDIT:

SUBMITTED BY: Dick Weaver
HISTORY: Submitted as X3J3/92-236 at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000100
TITLE: ASSOCIATED intrinsic and zero-sized objects
KEYWORDS: Associated, Zero sized objects, Target, Pointer
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: The response to defect item 000027 states what conditions must
be met for the two argument form of the ASSOCIATED intrinsic function to
return a value of true.  It does not state what the behavior of the
intrinsic is for zero sized arguments.

Question 1: Can the single argument form of the ASSOCIATED intrinsic
return true as its result if the argument's target is zero sized?

Question 2: Can the two-argument form of the ASSOCIATED intrinsic return
true
when both arguments are zero sized?

The following need answers only if the answer to question 2 is yes.

Question 2a: If the arguments to ASSOCIATED are zero sized but of rank
greater
than one, must the extents of each dimension be the same for ASSOCIATED
to
return true?  For example, what is printed by the following program?

       PROGRAM HUH
         REAL, DIMENSION(:,:), POINTER :: P1, P2
         REAL, DIMENSION(10, 10), TARGET :: A
         P1 => A(10:9:1, :)
         P2 => A(:, 10:9:1)
         PRINT *, ASSOCIATED (P1, P2)
       END

Question 2b: In the following example, rank, shape, type, kind type
parameters, and extent of dimensions of the zero sized arguments to
ASSOCIATED match, but the second argument is not the same as the right
hand side of the previous pointer assignment statement.   What is the
output of this program?  (Does a notion of "base address" come to play
for zero-sized objects as it does for nonzero-sized objects?)

       PROGRAM HMMM
       REAL, DIMENSION(:,:),    POINTER :: P1
       REAL, DIMENSION(10, 10), TARGET :: A
       P1 => A(:, 2:1:1)
       PRINT *, ASSOCIATED (P1, A(:, 3:2:1))
       END


ANSWER: The one-argument form of ASSOCIATED is intended to return a
result of true if the pointer actual argument is currently associated
with a target, even if the target is zero sized.  The result of the two-
argument form of the ASSOCIATED function is undefined if either of the
arguments is a pointer that is currently associated with a target that
is zero sized or if the second argument is not a pointer but of zero
size.  The following edits clarify the intent.

REFERENCES: ISO/IEC 1539 : 1991 section 13.13.13.

EDITS:

   1. Section 13.13.13 Case (ii) add the following sentence at the end

      If POINTER is currently associated with a zero-sized target, or
      TARGET is a zero-sized array, the result is undefined.

   2. Section 13.13.13 Case (iii) add the following sentence after the
      last sentence.

If either POINTER or TARGET are associated with a zero-sized array, the
result is undefined.

SUBMITTED BY: Jon Steidel - X3J3/92-240
LAST SIGNIFICANT CHANGE:  1993-02-10	000100
HISTORY: Submitted as X3J3/92-240 at meeting 123
         Response in X3J3/93-035 adopted at meeting 124 by unanimous
         consent

--------------------------------------------------------------------------------

NUMBER: 000101
TITLE: Specification statements
KEYWORDS:
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

Rev 1. Replaced the list from Metcalf & Reid Ch 7 with the list derived
from the syntax in 5.2 of Reid & Metcalf, per note from John & Mike.
(listing it as Reid & Metcalf sometimes is a result of speaking from the
end of many alphabetical listings myself!)

Rev 2. Deleted FORMAT, ENTRY from Reid & Metcalf per e-mail suggestion.

QUESTION: The following list compares the specification statements from
Fortran 77 (listed in chapter 8), those of Fortran 90 (R214, page8), and
those of Metcalf & Reid "Fortran 90 Explained" per e-mail.

          Fortran 77        Fortran  90         Metcalf&Reid

                            access              access
                            ALLOCATABLE         ALLOCATABLE
          COMMON            COMMON              COMMON
                            DATA                DATA
                                                derived-type-def
          DIMENSION         DIMENSION           DIMENSION
          EQUIVALENCE       EQUIVALENCE         EQUIVALENCE
          EXTERNAL          EXTERNAL            EXTERNAL
          IMPLICIT                              IMPLICIT
                            INTENT              INTENT
                                                interface-block
          INTRINSIC         INTRINSIC           INTRINSIC
                            NAMELIST            NAMELIST
                            OPTIONAL            OPTIONAL
          PARAMETER                             PARAMETER
                            POINTER             POINTER
          SAVE              SAVE                SAVE
                                                stmt-function
                            TARGET              TARGET
          type-stmt                             type-stmt
                                                USE

I have in the past and I will in the future argue for changes in
terminology -- where those changes better align Fortran with common
usage in describing programming languages or facilitate the description
of Fortran.  However the changes above seem more accidental than
intended and, I am convinced, will make a users transition to Fortran 90
more onerous than it need be.

   -- patterns learned in Fortran 77 will not carry forward, for no
      apparent reason

   -- complexity is increased.  In describing Fortran 77 you could
      write "all specification statements must precede ..." (3-3, line
      46).

   -- incompatible vendor documentation (some will follow the standard,
      some will pick up PARAMETER as M&R did, some will pick up EXTERNAL
      as M&R did, ...) will make the writing of portable programs
      more difficult.

Question 1: While reclassifying DATA as a specification statement seems
an improvement, the deletions and not classifying some new statements
(see M&R, above) as specifications seems unfortunate.  Were these
changes in terminology intended or an accidental result of incorporating
statement sequencing rules into the BNF?

Question 2: Do you want to reconsider?

Question 3: In 11.3.3.1 page 159 should
  "A common block and all its associated specification statements be
   changed to: "............................... and type-declaration ...

Question 4: In 12.3.2 page 167 should
  "... and by specification statements for the dummy arguments ..." be
  changed to "........................ and type-declaration ....."

Question 5: In 12.5.2.2 page 175, in the first constraint should
  "... any specification statement ..." be changed to
  "... any specification or type-declaration statement ..."

Question 6: In 12.5.2.5 page 178, in the first constraint (same question
as 5, above).

ANSWER:

1. Yes.  The changes in terminology were intended as a way to
specify partially the statement ordering via the BNF.  The effect
of losing the easy way to specify "specification" statements was
unintentional.

2. No.  Reverting to the FORTRAN 77 style would not be a benefit
at this time.  This style will be reconsider in writing Fortran 9x, in
particular the changes suggested in the question, items 3 through 6.

EDITS:
Section 11.3.3.1, [159:11] after "specification", add "and type-
declaration"

Section 12.3.2 [167:7] after "specification", add "and type-declaration"

Section 12.5.2.2, first constraint, [175:36] after "specification" add
"or type-declaration"

Section 12.5.2.5, first constraint, [178:1] after "specification" add
"or type-declaration"

SUBMITTED BY: Dick Weaver
HISTORY: 92-244r2           123                      first submitted
         92-325             123                      initial response

--------------------------------------------------------------------------------

NUMBER: 000102
TITLE: Returned value for INQUIRE POSITION= on an empty file
KEYWORDS: INQUIRE, file position
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  Consider the following two cases

1. Reading an empty sequential file

         OPEN ... POSITION='REWIND'  ! positioned at initial point
         READ ... END=               ! reads endfile record, positioned
                                     ! after endfile record
         BACKSPACE ...               ! positioned before endfile record
                                     ! which is also the initial point
         INQUIRE ... POSITION=

2. Writing an empty sequential file

         OPEN ... POSITION='REWIND'  ! positioned at initial point
         ENDFILE ...                 ! write endfile record, positioned
                                     ! after endfile record
         BACKSPACE ...               ! positioned before endfile record
                                     ! which is also the initial point
         INQUIRE ... POSITION=

In section 9.6.1.16, "POSITION= ..." appears to imply any of the
following can be returned by the INQUIRE statement in these three cases:

      processor dependent  - since the file has been repositioned
      REWIND               - since the file is now at its initial point
      APPEND               - since the file is now at its terminal point

Thus even for implementations that are specified to use REWIND and
APPEND, rather than a processor-dependent value, the standard would seem
to be ambiguous.  One implementation can return "REWIND" while another
returns "APPEND".  Is this ambiguity intended?

ANSWER: Yes.  If the file has been repositioned since the OPEN statement
was executed, then the value returned by INQUIRE(POSITION=...) is
processor-dependent.  No particular value is required to be returned,
but a few values are prohibited in certain cases.  The processor is free
to return any value that is not specifically prohibited by section
9.6.1.16.

A standard-conforming program cannot depend on a particular value being
returned in this case.  If an implementation chooses to return "REWIND"
or "APPEND" after a file has been repositioned, the file must currently
be positioned at the same point as if it had just been opened with that
same value for the POSITION specifier in the OPEN statement.  An
implementation must not return APPEND if the file is not positioned at
its terminal point or endfile record.  Similarly, it must not return
REWIND if the file is not positioned at its initial point.

This is not the same as saying that an implementation will return APPEND
when the file is positioned at its terminal point.  It need not.  But if
it does return APPEND, then the program can be assured that the file
really is positioned at its terminal point or endfile record.

REFERENCES:  ISO/IEC 1539:1991 (E) Section 9.6.1.16

EDITS: None.

SUBMITTED BY: Dick Weaver, 92-245
HISTORY: 92-245 rev2, 92-245 rev3

--------------------------------------------------------------------------------

NUMBER: 000103
TITLE: Statement Function with unreferenced dummy argument
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Consider the following example

    F(A,B,C)=A+B  ! statement function, dummy-arg C not used in expr
    INTEGER C

Since "C" is implicitly typed, must any later type definition (the
INTEGER C in the example) confirm that typing?

ANSWER: Yes (and therefore the example is nonstandard conforming).  This
is covered in the second constraint in Section 12.5.4.  While that
constraint appears to be about the scalar-expr "A+B", the last sentence,
beginning "If a scalar...", applies to the dummy arguments as well (the
2nd constraint combines what should have been two separate constraints).

The constraint will be split and clarified.

REFERENCES: ISO/IEC 1539:1991 (E) sections .....

EDIT:  In section 12.5.4 split the second constraint at "If a scalar
variable ..." [182:12] into a new constraint and add "dummy-arg," just
before "scalar variable".

SUBMITTED BY: Dick Weaver
LAST SIGNIFICANT CHANGE: 92-11-11	000103
HISTORY: Submitted as X3J3/92-249
         Approved as X3J3/92-249r at meeting 123 by a vote of 16-3

--------------------------------------------------------------------------------

NUMBER: 000104
TITLE: Rounding formatted output
KEYWORDS: rounding, formatted i/o
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION 1:  The standard requires floating-point values to be rounded,
on output (see 10.5.1.2.1 through 10.5.1.2.4).  It does not,  however,
say how they are to be rounded.  Always rounding  up and always rounding
down are allowed by the standard.  Was that intended?

QUESTION 2:  The ISO/IEC 1539:1980 semantics for G edit descriptors
assume that floating-point values are rounded down.  The ISO/IEC
1539:1991 semantics for G edit descriptors assume that floating-point
values are rounded to nearest  If those assumptions are violated, the
implementation is sometimes required to print strings of asterisks for
numbers that a user might think should be printed normally.

If the interpretation is that implementations must always round to
nearest, to which nearest value must they round in the case of a value
exactly between two representable values?

ANSWERS:

1. Yes.

2. No particular rounding method is required by the standard.  The above
analysis of the effect of this on output formatting using the G edit
descriptor in a formatted write statement is correct.

This change from FORTRAN 77's behavior was made in order to suggest a
particular preferred implementation, namely, round to nearest.  The
committee believed that this change would promote portability of
programs and consistency in implementations of I/O libraries, without
actually requiring any particular rounding method.

The standard's description for selecting between E and F editing, when
the user specified a G edit descriptor, assumes that if a value to be
printed is exactly between the two numbers obtained by rounding the
original value up and down (to the appropriate number of decimal
digits), then the magnitude of the value printed will be the absolute
value of the original value rounded up.

REFERENCES: ISO/IEC 1539:1991 (E) sections 10.5.4.1.2

EDITS: None

SUBMITTED BY: Robert Corbett, X3J3/92-268
LAST SIGNIFICANT CHANGE: 000104
HISTORY: Submitted as X3J3/92-268
         Approved as X3J3/92-299 at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000105
TITLE: Parallel evaluation of operands and arguments
KEYWORDS: expression, operand, argument, function, parallel, concurrent
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:

Question 1  Does Fortran permit concurrent evaluation of operands in
expressions and of actual arguments of functions?

Question 2  Is the following program standard conforming?

              PROGRAM TEST
                INTEGER F,M
                PRINT *, F(1,M) + F(2,M)
              END
              FUNCTION F(X,M)
                INTEGER F,X,M
                M = X*X
                F = M+M
                RETURN
              END

ANSWER:

Answer 1  Yes, the standard permits a wide variety of expression
evaluation models.

Answer 2  No, the specific example provided is not standard conforming.

Discussion: Sections 7.1.7.1, 12.4.2 and 12.5 provide information on
rules for expression evaluation and argument association.  Annex C
section 12.5 attempts to make it clear what was intended.

The use of concurrent, parallel or lazy evaluation of expressions is
permitted in a standard conforming Fortran processor.

Any program whose results depend on how expression evaluation is
performed is not standard conforming.

In the example provided in the question the PRINT statement is non-
standard conforming.  Section 7.1.7 contains the following prohibition:

The evaluation of a function reference must neither affect nor be
affected by the evaluation of any other entity within the statement.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 7.1.7, 12.4.2,12.5, C.12.5

EDITS:  None.

SUBMITTED BY: R. L. Page
LAST SIGNIFICANT CHANGE: 93 Feb. 000105
HISTORY: Contributions to the discussion provided by Brian Smith
         Type changed from Amendment to Interpretation meeting 124 in
         93-079r1.
         Approved by unanimous consent at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000106
TITLE: Multiple USE of modules; renaming rules
KEYWORDS: USE, modules, accessibility, renaming
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  Section 11.3.2 states

More than one USE statement for a given module may appear in a  scoping
unit.  If one of the USE statements is without an ONLY qualifier, all
public entities in the module are accessible and the rename-lists and
only-lists are interpreted as a single concatenated rename-list.  If all
the USE statements have ONLY qualifiers, only those entities named   in
one or more of the only-lists are accessible, that is, all the only-
lists are interpreted as a single concatenated only-list.

Assume the following module definition in considering the following
questions.

      MODULE MOD
        INTEGER I, J, K
      END MODULE

Question 1:  If the following USE statements appear in a scoping unit,
by what names are I and J accessible?

      USE MOD
      USE MOD, ONLY: X => I
      USE MOD, ONLY: Z => J

The rules quoted above state in this case all public entities are
accessible since one of the USE statements is without an ONLY qualifier.
By concatenating the only-lists and rename-lists on a single rename list
we have

      USE MOD, X => I, Z => J

Is I accessible through both the name I and X, and is J accessible
through both the name J and Z?

Question 2:  Same as question 1 without the ONLY clause.  Here, all the
USE statements are without ONLY clauses.

      USE MOD
      USE MOD, X => I
      USE MOD, Z => J

Because MOD appears in a USE statement without a rename-list, are all
public entities from MOD accessible by their declared name in MOD as
well as any local names given in the rename-lists?  That is, is I
accessible by both I and X, and J accessible by both J and Z?

ANSWER: In both examples, I is made accessible only as X, and J is made
accessible only as Z.

Discussion: The text cited in 11.3.2 allows a collection of USE
statements referencing the same module to be interpreted as an
equivalent single USE statement.  This circumvents restrictions on list
lengths that would otherwise be indirectly imposed by the source form
rules on line lengths and number of continuations.

In general, it is not possible to characterize the effect of such a
collection as the union of the effects that each individual statement
would have in the absence of the other statements.  USE statements with
ONLY: can be so composed but not USE statements without ONLY:, because
the lists on other USE statements can limit the accessibility of
entities not explicitly named in a USE statement without ONLY:.

There are programming practices that can minimize the confusion this
might engender:  Use of multiple USE statements referencing the same
module can be limited to those cases where it is required by the length
of the list involved.  When multiple USE statements are required, a
minimum number can be used, and they can be placed one after another.
If one USE statement indicates that all public entities are to be
accessible (by omitting ONLY:), all can do so.  The standard does not
require any of these programming practices.

REFERENCES: ISO/IEC 1539:1991, section 11.3.2

EDIT:  None.

SUBMITTED BY: Jon Steidel
LAST SIGNIFICANT CHANGE:  1993-02-10, expanded discussion	000106
HISTORY: Initially drafted as X3J3/92-246
         Response proposed in X3J3/92-279
         meeting 123 vote (12-4) insufficient to approve
         Discussion section expanded in X3J3/93-106.
         Approved by a vote of (14-2) at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000107
TITLE: USE renaming of generic and specific interfaces
KEYWORDS: USE, module, generic name, specific name,
interfaces, renaming
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  A module contains a generic interface whose name matches the
name of a specific interface defined in the interface block defining the
generic interface.  When the module is used, the name of the generic
interface appears in a rename-list on the USE statement.  Does the
rename apply also to the specific interface?  For example:

      MODULE MOD
      INTERFACE GEN
        SUBROUTINE GEN (A, B)
           REAL A, B
        END SUBROUTINE
      END INTERFACE
      END MODULE

      SUBROUTINE USER (X)
         USE MOD, RENAME => GEN  ! Renames generic and specific GEN
         DIMENSION GEN (100) ! Legal to have local variable by name GEN?
         ...
      END SUBROUTINE

ANSWER: Yes, the rename also applies to the specific name.

Discussion: In the example, RENAME is the local name in USER which
refers to the same entity that the name GEN refers to in MODULE MOD.
The name GEN is free to be used for other purposes in USER.

REFERENCES: ISO/IEC 1539:1991, sections 11.3.2

EDIT: none

SUBMITTED BY: Jon Steidel
HISTORY: Initially drafted as X3J3/92-247
         Response proposed in X3J3/92-282 -
         approved by unanimous consent at meeting 123

--------------------------------------------------------------------------------

NUMBER: 000108
TITLE: Referencing disassociated pointers
KEYWORDS: pointer, target, association status, disassociated, array
pointer, inquiry functions, referenced, defined
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: There are several places in the standard that refer to whether
a disassociated pointer can be referenced. The places seem to be
inconsistent in the restrictions they place on such references.

In section 5.1.2.4.3

"The size, bounds, and shape of the target of a disassociated array
pointer are undefined.  No part of such an array may be defined, nor may
any part of it be referenced except as an argument to an intrinsic
inquiry function that is inquiring about argument presence, a property
of the type or type parameters, or association status."

In section 5.2.7

"An object that has the POINTER attribute must not be referenced or
defined unless, as a result of executing a pointer assignment (7.5.2) or
an ALLOCATE statement (6.3.1), it becomes pointer associated with a
target object that may be referenced or defined."

In section 7.1.4.1

"If the pointer is not associated with a target, it may appear as a
primary only as an actual argument in a reference to a procedure whose
corresponding dummy argument is declared to be a pointer."

In section 7.5.2

"A pointer must not be referenced or defined unless it is associated
with a target that may be referenced or defined."

In section 13.7.2

"The inquiry functions RADIX, DIGITS, MINEXPONENT, MAXEXPONENT,
PRECISION, RANGE, HUGE, TINY, and EPSILON return scalar values related
to the parameters of the model associated with the types and kind type
parameters of the arguments. The value of the arguments to these
functions need not be defined, pointer arguments may be disassociated,
and array arguments need not be allocated."

(1)  Where exactly can a pointer that is disassociated be referenced?

(2)  Can array pointers that are disassociated be referenced in more
places than scalar pointers that are disassociated?

(3)  Can a pointer with an undefined association status ever be
referenced? (e.g. as the argument to the KIND intrinsic in a PARAMETER
statement).

ANSWER:

1. A pointer that is disassociated may never be referenced.  The text
cited from 5.1.2.4.3 is misleading and the text cited from 13.7.2 is
incomplete.  With the edits below, the text becomes more precise.

2. No.

3. No.  A pointer with undefined association status may be the argument
to the KIND intrinsic in a PARAMETER statement, but this is not
considered to be a reference.  The term reference is defined in the
first paragraph of section 6.

Discussion: The first paragraph of section 6 defines a reference to be
the appearance of a data object name or subobject designator in a
context that requires its value.  When a pointer appears as an argument
to an inquiry intrinsic function that is inquiring about argument
presence, a property of the type or type parameters, or association
status, its value is not required.  Thus a disassociated pointer may
appear in these places.  A pointer with undefined association status may
appear in all of these places except as an argument to the ASSOCIATED
intrinsic function.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 5.1.2.4.3, 5.2.7, 6, 7.1.4.1,
7.5.2, 13.7.2

EDITS:

   1. Replace the text in the seventh paragraph of 5.1.2.4.3, "The size,
      bounds, and shape of the target ... association status." [46:25-
      33] with, "The size, bounds, and shape of the target of a
      disassociated array pointer are undefined.  No part of such an
      array may be referenced or defined; however, the array may appear
      as an argument to an intrinsic inquiry function that is inquiring
      about argument presence, a property of the type or type
      parameters, or association status."

   2. Replace the text in section 13.7.2 with, "The inquiry functions
      RADIX, DIGITS, MINEXPONENT, MAXEXPONENT, PRECISION, RANGE, HUGE,
      TINY, and EPSILON return scalar values related to the parameters
      of the model associated with the types and kind type parameters of
      the arguments. The value of the arguments to these functions need
      not be defined, pointer arguments may have undefined or
      disassociated association status, and array arguments need not be
      allocated."

SUBMITTED BY: Janice C. Shepherd - X3J3/92-258
LAST SIGNIFICANT CHANGE: 1993-02-10  000108
HISTORY: Submitted as X3J3/92-258 at meeting 123
         Response in 93-076 adopted at meeting 124 by a vote of (11-3)

--------------------------------------------------------------------------------

NUMBER: 000109
TITLE: Intrinsic function ASSOCIATED
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  The description of ASSOCIATED (section 13.13.13) fails to
specify that the result is scalar. Is this an oversight?  Or is there
some way in which an array-valued result can be returned?

ANSWER: The result returned by ASSOCIATED is always scalar. The
following edit makes this clear.

EDIT:  In 13.13.13 in the specification of the result type, add "scalar"
after "default logical".

REFERENCES: ISO/IEC 1539:1991(E) Section 13.13.13

SUBMITTED BY: Graham Barber
LAST SIGNIFICANT CHANGE: 1992 11 11, new	000109
HISTORY: Originally submitted as X3J3/92-264
         Response proposed in X3J3/92-317 - approve by (18-1) vote at
         meeting 123

--------------------------------------------------------------------------------

NUMBER: 000110
TITLE: Named constant shape specification
KEYWORDS: statement ordering, type declaration statement, named
constant, PARAMETER statement, shape, DIMENSION statement, attribute
specification
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:  The standard seems inconsistent in that the following appears
valid

             SUBROUTINE SUB ( )
               REAL, PARAMETER :: R = 1
               DIMENSION R (2)
             END

while the following appears not to be

             SUBROUTINE SUB ( )
               PARAMETER (R = 1)
               DIMENSION R(2)
             END

Was this the intent?

ANSWER: No, both are illegal.

Discussion: Section 5.2 states, "All attributes (other than type) may be
specified for entities, independently of type, by single attribute
specification statements.  The combination of attributes that may be
specified for a particular entity is subject to the same restrictions as
for type declaration statements regardless of the method of
specification." Section 5.2.10 places the following restriction on
objects named in a PARAMETER statement: "The named constant must have
its type, shape, and any type parameters specified either by a previous
type statement in the same scoping unit, or by the implicit typing rules
currently in effect for the scoping unit." While the restriction is
stated in the section titled, "The PARAMETER Statement", it applies to
all objects with the parameter attribute.  Objects with the parameter
attribute may appear in subsequent specification expressions and
initialization expressions.  Because of this, the committee chose to
require the shape of an object with the parameter attribute to be known
before it is initialized and thus before it can appear in subsequent
specification and initialization expressions.

REFERENCES: ISO/IEC 1539:1991 sections 5.2 and 5.2.10.

EDITS: none

SUBMITTED BY: Peter Griffiths
HISTORY: Initially drafted as X3J3/120-100
         Submitted as X3J3/92-289 at meeting 123
         Approved at meeting 123 (17-2)

--------------------------------------------------------------------------------

NUMBER: 000111
TITLE: Array constructors in masked assignment statements
KEYWORDS: array constructors, masked assignment statements, WHERE
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  The description of masked array assignment (section 7.5.3.2)
does not specify how an array constructor referenced in such an
assignment is evaluated.  Is the evaluation of an array constructor
controlled by the mask-expr?  In particular, consider the following
examples:

                (/  MATMUL (A, B) + 1  /)

Evaluation on an element-by-element basis is not possible.

                (/  ((A (1 : J : I), I = 1, J), J = M, N)  /)

It is hard to select a particular element for evaluation.

ANSWER: Yes.

Discussion: The evaluation of an array constructor is controlled by the
mask-expr in a masked assignment statement.  Section 4.5 specifies that
an array constructor is interpreted as a rank-one array.  Section
7.5.3.2 specifies that a reference to an array is controlled by the
mask-expr.  However, the reference to MATMUL in the first example is a
nonelemental function reference.  The first sentence of the second
paragraph of section 7.5.3.2 specifies that a nonelemental function
reference is evaluated without any control by the mask-expr.

REFERENCES: ISO/IEC 1539:1991 (E) sections 4.5 and 7.5.3.2

EDITS:  None.

SUBMITTED BY: Graham Barber - X3J3/92-264
LAST SIGNIFICANT CHANGE:  1992-11-13	000111
HISTORY: Submitted in X3J3/92-264
         Proposed response in X3J3/92-293 prepared at meeting 123 failed
         by a vote of (10-10)
         Same response in X3J3/93-093 at meeting 124 failed by a vote of
         (1-13).

--------------------------------------------------------------------------------

NUMBER: 000112
TITLE: Sequence derived type external functions
KEYWORDS: SEQUENCE, derived type, external functions
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Can an external function of sequence derived type be declared
with a TYPE specification in the FUNCTION statement?

For example, is the following a valid code fragment?

          TYPE (T) FUNCTION F ()
            TYPE T
              SEQUENCE
              INTEGER I, J
            END TYPE T
            ...
          END

ANSWER: Yes, the code fragment is valid, as an external function of
sequence derived type can be declared with a TYPE specification in its
FUNCTION statement.

Discussion: The second paragraph of 12.5.2.2 indicates the only two
conditions under which the attributes of a function result must be
specified by specification statements within the function body.

"If the function result is array-valued or a pointer, this must be
specified by specifications of the name of the result variable within
the function body."

It was not intended that the syntax of allowing TYPE on a FUNCTION
statement be limited to internal and module functions.  The last
sentence of the first paragraph of 5.1.1.7 should not be applied to
function results.  An edit is included for clarification.

REFERENCES: 5.1.1.7, 12.5.2.2.

EDITS:  Add after the last sentence of the first paragraph of 5.1.1.7:

"If the data entity is a function result, the derived type can be
specified on the FUNCTION statement providing the derived type is
defined within the body of the function or is accessible there by use or
host association."

SUBMITTED BY: Janice C. Shepherd, 92-130.
LAST SIGNIFICANT CHANGE: Nov. 1992, original draft response	000112
HISTORY: Draft response proposed in 92-298
         (14-4) vote at meeting 123 insufficient for approval
         Approved by unanimous consent at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000113
TITLE: Ordering of array specification and initialization
KEYWORDS: statement ordering, type declaration statement,
initialization, shape, DIMENSION statement, attribute specification
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION: Fortran 90 requires that an array initialized via a DATA
statement must have its array properties established by a previous
specification expression (5.2.9).  When an array is initialized via an
=initialization-expr specification in a type declaration statement,
however, there is no such requirement.  For example, the code fragment,

             INTEGER :: I
             DATA I /2*1/
             DIMENSION :: I(2)

is prohibited by the standard, whereas the similar fragment,

             INTEGER :: I = (/1,1/)
             DIMENSION :: I(2)

appears to be permitted.  Is the lack of such a requirement when
initializing an array in a type declaration statement an error in the
standard?

ANSWER: Yes, it was the intent of the committee that specifications in
type declaration statements have the same restrictions as specifications
in attribute specification statements.

Discussion: Section 5.2 states, "The combination of attributes that may
be specified for a particular entity is subject to the same restrictions
as for type declaration statements regardless of the method of
specification."  Section C.5.1 also supports this intent.  Thus there is
evidence in the standard that the same restrictions should be applied to
objects independent of whether their attributes were specified in a type
declaration statement or an attribute specification statement.  The edit
below clarifies this intent for the initialization of arrays.

REFERENCES: ISO/IEC 1539:1991 sections 5.1, 5.2, 5.2.9, and C.5.1

EDIT: Section 5.1, add the following to the end of the fifth paragraph
following the constraints, "If the variable is an array, it must have
its shape specified either in the type declaration statement or a
previous attribute specification statement in the same scoping unit."

SUBMITTED BY: Peter Griffiths
LAST SIGNIFICANT CHANGE: 1993-02-11	000113
HISTORY: Initially drafted as X3J3/120-62 (120-LJM-2a)
         Resubmitted as X3J3/92-287
         Response in X3J3/92-287r rejected at meeting 123 (8-12)
         Resubmitted with opposite answer at meeting 124 in X3J3/93-080
         and adopted by a vote of (15-1)

--------------------------------------------------------------------------------

NUMBER: 000114
TITLE: Named constant attribute specification
KEYWORDS: statement ordering, type declaration statement, named
constant, PARAMETER statement, shape, DIMENSION statement,  attribute
specification statement
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: The standard seems inconsistent in that the program unit

             SUBROUTINE SUB ( )
               REAL, DIMENSION (2) :: R
               PARAMETER (R = 1)
             END

appears to be valid while the program unit

             SUBROUTINE SUB ( )
               DIMENSION R(2)
               PARAMETER (R = 1)
             END

does not appear valid as section 5.2.10 states, "The named constant must
have its type, shape, and any type parameters specified either by a
previous occurrence in a type declaration statement in the same scoping
unit, or by the implicit typing rules currently in effect for the
scoping unit." Was it intended that one case be valid while the other is
not?

ANSWER: No, that was not the intent; both program units are valid.

Discussion: Section 5.2 states, "The combination of attributes that may
be specified for a particular entity is subject to the same restrictions
as for type declaration statements regardless of the method of
specification." Section C.5.1 also supports this intent.  Thus there is
evidence in the standard that the same restrictions should be applied to
objects independent of whether their attributes were specified in a type
declaration statement or an attribute specification statement.  The edit
below clarifies this intent by changing the statement in section 5.2.10
quoted above.

REFERENCES: ISO/IEC 1539:1991 sections 5.2.10, 5.2, and C.5.1

EDIT: Section 5.2.10, replace the first sentence following the syntax
rules with, "The named constant must have its type, shape, and any type
parameters specified either by previous type declaration or attribute
specification statements in the same scoping unit, or by the implicit
typing rules currently in effect for the scoping unit."

SUBMITTED BY: Peter Griffiths
LAST SIGNIFICANT CHANGE:  1993-02-10	000114
HISTORY: Initially drafted as X3J3/120-99
         Submitted as X3J3/92-288 at meeting 123
         Approved at meeting 123 (UC), subsequently questioned in letter
         ballot
         Revised in X3J3/93-074 and adopted at meeting 124 by unanimous
         consent

--------------------------------------------------------------------------------

NUMBER: 000115
TITLE: Multiple dummy arguments
DEFECT TYPE: Interpretation
KEYWORDS:
STATUS: X3J3 approved; ready for WG5

QUESTION:  Section 12.5.2.5 implies that a dummy argument in an ENTRY
statement can also appear in the subprogram's FUNCTION or SUBROUTINE
statement.  That is, the following is standard conforming:

      SUBROUTINE S1(A,B,C)
      ...
      ENTRY SE1(A,B)
      ...
      END SUBROUTINE

Does this imply that an entity can occur multiple times in a single
list?  For example,

      FUNCTION F2(A,B,A)
      ...
      END FUNCTION

      SUBROUTINE S3( )
      ...
      ENTRY SE2(C,D,C)
      ...
      END SUBROUTINE

ANSWER: Section 14.1.2 indicates that function F2 and subroutine S3 are
invalid.

Discussion: Section 14.1.2 lists named variables as a class (1) entity.
The section also indicates that a name that identifies a local entity of
one class must not be used to identify another local entity of the same
class.  When a dummy argument appears in both an ENTRY statement and a
subprogram FUNCTION or SUBROUTINE statement, the name denotes the same
local entity and not two different entities of the same class.  In
function F2 shown, the entity denoted by the first A is not the same
entity as the second A.  A similar statement can be made for the
entities denoted by C in subroutine S3.  In both cases, the fragments
are attempting to use the same name for two entities of the same class
and are therefore invalid.

REFERENCES: ISO/IEC 1539:1991 (E) section 14.1.2

EDITS: None

SUBMITTED BY: Tim Peters and Janice Shepherd
LAST SIGNIFICANT CHANGE: 1992-11-11, new	000115
HISTORY: Discussed in e-mail 92-048 (pg 27-29,30-34)
         Response proposed in X3J3/92-295 - approved by unanimous
         consent at meeting 123

--------------------------------------------------------------------------------

NUMBER:000116
TITLE: Scoping units and statement labels
KEYWORDS: Scoping units, statement labels, hosts
DEFECT TYPE: Interpretation
STATUS: X3J3 approved; ready for WG5

QUESTION:

Question 1:  When does the scope change from the host to an inner scope?
It makes a difference in determining when a label is a duplicate of
another label in the same scope.

Question 2:  In the following example, are the labels considered
duplicates thus making the program not standard conforming?

       PROGRAM EX1
  10     INTEGER I
  20     TYPE T
  10       INTEGER T1
  20       REAL T2
  30       INTEGER T3
  30     END TYPE

Question 3:  In the following example, are the labels not considered
duplicates as the INTERFACE and END INTERFACE statements are in the host
scope while the two interface bodies each have their own scope?

       PROGRAM EX2
10       INTEGER I
20       INTERFACE
10         SUBROUTINE S(A)
20           REAL A
30         END SUBROUTINE
10         FUNCTION F (AA)
20           REAL AA
30         END FUNCTION
30       END INTERFACE

Question 4:  In the following example, are the labels not considered
duplicates since the internal subroutine and function are separate
scoping units?

     MODULE
10     INTEGER I
     ...
20   CONTAINS
10     SUBROUTINE INNER1 ( )
20       I = I + 1
30     END SUBROUTINE
10     FUNCTION F ( )
20       F = 4.5
30     END FUNCTION
30   END MODULE

ANSWER:

Answer 1:  In 2.2 a scoping unit is defined.  The syntax rules for a
derived type definition, a procedure interface body, and a program unit
or subprogram define the extents of scoping units.  Thus the TYPE, END
TYPE, PROGRAM, END PROGRAM, MODULE, END MODULE, BLOCK DATA, END BLOCK
DATA, SUBROUTINE, END SUBROUTINE, and FUNCTION, END FUNCTION statements
define the beginning and end of such scoping units.

Answer 2:  The example is not standard conforming because there are
duplicate labels in the scoping unit of the derived type since the TYPE
statement is part of the derived type.

Answer 3:   The example is standard conforming and does not have
duplicate labels.

Answer 4:  The labels for the internal subroutine and function are not
considered duplicates since they are in separate scoping units.

REFERENCES: ISO/IEC 1539:1991 (E) section 2.2 [9]

EDITS(S): None

SUBMITTED BY: Janice Shepherd
LAST SIGNIFICANT CHANGE: 1992-11-13	000116
HISTORY: 92-304 (Meeting 123) - approved by unanimous consent at
         meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000117
TITLE: Use of MODULE PROCEDURE statement in internal procedures
KEYWORDS: interface block, module procedure, host association
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  The second constraint in section 12.3.2.1 appears to indicate
that the following program fragment is not standard conforming.  Is the
following code fragment standard conforming?

      MODULE MOD
      CONTAINS
       SUBROUTINE SUB1(I)
       ...
       END SUBROUTINE SUB1
      END MODULE

      PROGRAM MAIN
       USE MOD
       CALL INNER
      CONTAINS
       SUBROUTINE INNER
        INTERFACE SUB
         MODULE PROCEDURE SUB1
        END INTERFACE
        ...
       END SUBROUTINE
      END PROGRAM

ANSWER: Yes.  The program fragment is standard conforming.

Discussion: There are several defects in the second constraint of
section 12.3.2.1. First, the constraint should not restrict the program
fragment that is shown nor similar ones involving generic interfaces in
internal procedures within module subprograms.  Second, the constraint
implies that an <interface-block> is a scope, when it is not.  An edit
is included to correct these defects.

REFERENCES: ISO/IEC 1539:1991 (E) Section 12.3.2.1.

EDIT:  Replace the second constraint in section 12.3.2.1 with "The
MODULE PROCEDURE specification is allowed only if the <interface-block>
has a <generic-spec> and is contained in a scoping unit where each
<procedure-name> is accessible as a module procedure."

SUBMITTED BY: Y. Yoshida
LAST SIGNIFICANT CHANGE: 1992-11-12, new	000117
HISTORY: Question posed in X3J3/92-132 items 63,64.
         Response proposed in X3J3/92-318; not formally considered at
         meeting 123 due to a lead time problem
         Approved at meeting 124 by unanimous consent.

--------------------------------------------------------------------------------

NUMBER: 000118
TITLE: Named constructs and host association
KEYWORDS:
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Section 12.1.2.2.1 defines when a name appearing in a scoping
unit is the name of a local entity, making inaccessible any entity of
the host that has the same name as its nongeneric name.  Should the
appearance of a name as a construct name be on the list?

ANSWER: Yes.

Discussion: Section 14.1.2 indicates that construct names are local
entities.  An edit is included to add construct names to the list in
section 12.1.2.2.1.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 12.1.2.2.1 and 14.1.2.

EDIT:  Add new item to the list in section 12.1.2.2.1:  "(16) The name
of a named construct" and adjust the list punctuation accordingly.

SUBMITTED BY: P. Griffiths
LAST SIGNIFICANT CHANGE: 1992 11 12, new	000118
HISTORY: Submitted as a request in X3J3/92-132 item 68.
         Response proposed in X3J3/92-319 - approved by unanimous
         consent at meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000119
TITLE: Rank of assumed-shape array
KEYWORDS: Rank, assumed-shape, array, argument
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION: Must the rank of an assumed-shape dummy argument match that
of the corresponding actual argument?

The fourth paragraph of section 12.4.1.1 indicates that if a dummy
argument is a pointer, the actual argument must be a pointer and their
ranks must agree.  No similar statement appears to exist for assumed-
shape arrays.

ANSWER: Yes.  The rank of an assumed-shape dummy argument must match
that of the actual argument.  This is implied by the statement in
5.1.2.4.2 that an assumed-shape array takes its shape from the
associated actual argument array. An edit is included to clarify this
restriction.

REFERENCES: ISO/IEC 1539:1991 (E) sections 12.4.1.1 and 5.1.2.4.2

EDIT:  At the end of the first paragraph of section 12.4.1.1 [172:41],
add: "If the dummy argument is an assumed-shape array, the rank of the
dummy argument must agree with the rank of the actual argument."

SUBMITTED BY: A. Meyer
LAST SIGNIFICANT CHANGE: 1992 11 12, new	000119
HISTORY: Submitted as a request in X3J3/92-132 item 69.
         Response proposed in X3J3/92-320 - approved by unanimous
         consent at meeting 123.

--------------------------------------------------------------------------------

NUMBER: 000120
TITLE: PRESENT intrinsic and host association
KEYWORDS: PRESENT, host association, optional
DEFECT TYPE: Erratum
STATUS: X3J3 approved; ready for WG5

QUESTION:  Can the PRESENT intrinsic be called from an internal
procedure with an argument that is an optional dummy argument of its
host?

For example

        SUBROUTINE HOST(OPT)
        REAL, OPTIONAL :: OPT
        ...
        CONTAINS
          SUBROUTINE INNER ( )
          IF (PRESENT (OPT) ) THEN
            ...

ANSWER: Yes.

Discussion: As long as the optional dummy argument is accessible it can
be used as an argument to the PRESENT intrinsic. An edit is provided for
clarification.

REFERENCE:  ISO/IEC 1539:1991 (E) Section 13.13.80

EDIT:  Replace the description of Argument in 13.13.80 with  "A must be
the name of an optional dummy argument that is accessible in the
procedure in which the PRESENT function reference appears."

SUBMITTED BY: J. C. Shepherd
LAST SIGNIFICANT CHANGE: 1992 11 11, new 000120
HISTORY: Question and proposed response first appeared in X3J3/92-321

--------------------------------------------------------------------------------

NUMBER: 000121
TITLE: ";" As a Statement Separator
KEYWORDS: Separator, ";"
DEFECT TYPE: Amendment
STATUS: X3J3 consideration in progress

QUESTION:  Are the following cases legal?

(1)  C = A ;  + B

(2)  F = ; &
     G

(3)  P = Q

ANSWER:

SUBMITTED BY: Paul St. Pierre,  119-PSP-1
LAST SIGNIFICANT CHANGE:	000121
HISTORY: 119-PSP-1 (initial submission)
         X3J3/92-284 (considered at meeting 123)

--------------------------------------------------------------------------------

NUMBER: 000122
TITLE: Intrinsic procedures in modules
KEYWORDS: intrinsic procedures, modules
DEFECT TYPE: Interpretation
STATUS: X3J3 consideration in progress

QUESTION:  A standard-conforming processor is permitted (1.4) to add
nonstandard intrinsic procedures, even when such procedures change the
meaning of an otherwise standard-conforming program.  Is such a
processor permitted to "package" such nonstandard intrinsic procedures
into a (non-Fortran-expressible) module, so that they would only be
visible in scoping units that access the module via USE association?

For example, suppose a vendor provides (possibly built into the
compiler) a module, WAY_COOL, containing a function named NEAT_STUFF
which takes a single default integer argument and returns a default
integer result.  Is the vendor permitted to define NEAT_STUFF to be a
nonstandard intrinsic?  If so, if the following program is submitted to
this processor, which version of NEAT_STUFF (the userUs or the vendorUs)
is invoked in each subroutine?

      PROGRAM HOT_STUFF
         CALL YOURE_HOT
         CALL YOURE_NOT
      END PROGRAM
      SUBROUTINE YOURE_HOT
         USE WAY_COOL
         PRINT *, NEAT_STUFF(42)
      END SUBROUTINE
     SUBROUTINE YOURE_NOT
         PRINT *, NEAT_STUFF(43)
      END SUBROUTINE
      FUNCTION NEAT_STUFF(NOT)
         NEAT_STUFF = NOT
      END FUNCTION

ANSWER:

Discussion:

REFERENCES: ISO/IEC 1539:1991 (E) section 1.4

EDITS:

SUBMITTED BY: Len Moss, X3J3/93-025
LAST SIGNIFICANT CHANGE:
HISTORY:

--------------------------------------------------------------------------------

NUMBER: 000123
TITLE: Result of INT(A) not equal to A for non-default integers
KEYWORDS: intrinsic, INT
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION: Is the sentence in 13.13.47
              "case (i): If A is of type INTEGER, INT(A)=A"
incomplete? Specifically consider the case of A being non-default
INTEGER kind where RANGE(A) > RANGE(INT(A))

ANSWER: No, the sentence is correct.

Discussion: Case(i) does not apply when RANGE(A) > RANGE(INT(A)).  The
text just before the example addresses such cases:

          "The result is undefined if the processor cannot
          represent the result in the specified integer type."

REFERENCES: ISO/IEC 1539:1991 (E) Section 13.13.47

EDITS:  None.

SUBMITTED BY: JIS X3J3/93-036(3)
LAST SIGNIFICANT CHANGE: 93 Feb, new 000123
HISTORY: Question posed in 93-036 item 3.
         Response proposed in 93-077.
         Approved by unanimous consent at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000124
TITLE: Result of LBOUND for assumed-size arrays
KEYWORDS: LBOUND, assumed-size array, intrinsic
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  The description of the value returned by LBOUND (ARRAY,DIM)
does not appear to consider the case where ARRAY is an assumed-size
array and DIM equals the rank of the array.  Does the value returned for
such a case really depend on whether the dimension DIM of ARRAY has size
zero?

ANSWER: No. The value returned is independent of the size  of the
dimension.

Discussion: The text in the case (i) description of LBOUND does not
include the information about the value returned for the situation where
ARRAY is an assumed-size array and DIM equals the rank of the array.  An
edit is provided to
correct that omission.

REFERENCES: ISO/IEC 1539: 1991 (E), section 13.13.52.

EDIT:

In section 13.13.52 replace the text of case (i) with:

"For a whole array of array structure component in which the size of
dimension DIM is non-zero or in which DIM is the last subscript of an
assumed-size array, LBOUND (ARRAY, DIM) has a value equal to the lower
bound for subscript DIM of ARRAY; otherwise it  has the value 1."

SUBMITTED BY: JIS, X3J3/93-036 (4) at meeting 124.
LAST SIGNIFICANT CHANGE:  93, Feb. new 000124
HISTORY: Draft response as X3J3/93-096 at meeting 124.

--------------------------------------------------------------------------------

NUMBER: 000125
TITLE: Copy in/copy out of target dummy arguments
KEYWORDS: dummy argument, target, explicit interface, association
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Previous Fortran standards have permitted copy in/ copy out
as a valid implementation for argument passing to procedures, as does
Fortran 90.  Fortran 90 introduces pointer and target attributes.
Sections 12.4.1.1 and C.12.8 indicate that it was intended that copy in/
copy out also be a valid implementation for passing dummy arguments that
have the target attribute.  The following example demonstrates a case
where a copy in/ copy out implementation may get different results from
an implementation which does not use a copy in/ copy out method for
passing arguments that have the target attribute.

POINTER IPTR
TARGET I
IPTR => I
CALL SUB (I, IPTR)
...
CONTAINS
    SUBROUTINE SUB (J, JPTR)
    POINTER JPTR
    TARGET J
    PRINT *, ASSOCIATED (JPTR, J)
    END SUBROUTINE
END

Is this a flaw in the standard?

ANSWER: Yes, there is a flaw in the standard.  The edits supplied
disallow copy in/ copy out as a valid implementation for passing dummy
arguments that have the TARGET
attribute.

Discussion: The changes apply only to target dummy arguments.

Note that the edits supplied reinforce the response to defect item 41.

REFERENCES: ISO/IEC 1539:1991 (E) sections 6.3.3.2, 12.4.1.1, and
C.12.8.

EDITS:

   1. Add another item to list in section 6.3.3.2, "(7)  An actual
      argument that is associated with a dummy argument of the procedure
      that has the TARGET attribute."

   2. Section 12.4.1.1, add at the end of the fourth paragraph,  " If
      the dummy argument has the TARGET attribute, the actual argument
      must have the TARGET attribute and the type, type parameters, and
      ranks must agree."

   3. Section 12.4.1.1, fifth paragraph, last sentence [173: 10-14]
      delete, "with a dummy argument of the procedure that has the
      TARGET attribute or"

   4. Section 12.4.1.1, delete the sixth paragraph [173: 14-17] and
      replace with, "When execution of a procedure completes, a pointer
      which is associated with a dummy argument of the procedure that
      has the TARGET attribute remains associated with the actual
      argument."

   5. Section C.12.8, delete the second paragraph through the end of
      the section [292: 5-37] and replace with


      A pointer that is associated with a dummy argument that has the
      TARGET attribute when execution of a procedure completes remains
      associated with the corresponding actual argument.

          REAL, POINTER      :: PBEST
          REAL, TARGET       :: B (10000)
          CALL BEST (PBEST, B)
          ...
          CONTAINS
            SUBROUTINE BEST (P, A)
              REAL, POINTER     :: P
              REAL, TARGET      :: A (:)
              ...                         !Find the "best" element A(I)
              P => A (I)
             RETURN
           END SUBROUTINE
       END

It is illegal to associate a dummy argument that has the TARGET
attribute with an actual argument that does not have the TARGET
attribute.  An explicit interface is required when calling a procedure
which has a dummy argument that is a target.  In the following example,
an expression is argument associated with a target dummy argument. The
presence of the explicit interface allows a processor to detect this
error.

          POINTER P
          CALL FRED (P, 4.5+X)               ! Invalid call to FRED
          PRINT *, P
          ...
          CONTAINS
            SUBROUTINE FRED (PTR, TGT)
              POINTER PTR
              TARGET TGT
              PTR => TGT
              RETURN
            END SUBROUTINE
        END

SUBMITTED BY: Jon Steidel - X3J3/93-095
LAST SIGNIFICANT CHANGE:  1993-02-12	000125
HISTORY: Submitted as X3J3/93-095 with draft response at meeting 124 and
         adopted by a vote of (15-1)

--------------------------------------------------------------------------------

NUMBER: 000126
TITLE: Character entry statements and partial association
KEYWORDS: character, entry, function, association
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:   In section 14.6.3.3 there is text that indicates that
partial association can occur between character entities through the use
of ENTRY statements. Is this correct?

ANSWER: No, the statement is not correct.

Discussion: Given the definition of "partially associated" in section
14.6.3.3:

Two scalar entities are partially associated if they are associated
without being totally associated.

The last sentence before the first example in 14.6.3.3 [248:41]

For character entities, partial association may occur only through
argument association, or the use of COMMON, EQUIVALENCE, or ENTRY
statements.

is incorrect.  There is no way that partial association for character
entities may occur through the use of an ENTRY statement.

REFERENCES: ISO/IEC 1539:1991 (E) section 14.6.3.3

EDITS:  In section 14.6.3.3 change the sentence (last two lines of
page 248) from
     "For character entities, partial association may occur only through
      argument association, or the use of COMMON, EQUIVALENCE, or ENTRY
      statements"

to

     "For character entities, partial association may occur only through
      argument association, or the use of  COMMON or EQUIVALENCE
      statements"

SUBMITTED BY: Janice Shepherd 93-092
LAST SIGNIFICANT CHANGE: 1993 meeting 124	000126
HISTORY: Based on original response to X3J3/92-051
         Withdrawn after discussion for further refinement.

--------------------------------------------------------------------------------

NUMBER: 000127
TITLE: Is a module a global entity?
KEYWORDS: module, global name, global entity, local entity, entity, name
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  Consider the following program fragment:

Example 1:

           MODULE ABC
             INTEGER G
           END MODULE

           PROGRAM MAIN
             USE ABC            ! Contains name abc
             REAL ABC           ! Contains name abc
           END PROGRAM

Question 1:  Is a module name a global entity?

Question 2:  May a local entity in a scoping unit have the same name as
a module accessed by that scoping unit?

Question 3:  May a module be accessed in a scoping unit that also
accesses a local name that has the same name as the module?  (That is,
can the contained subroutine access both the module abc and the variable
abc inherited from the host?)


In this second example:

         MODULE ABC
           INTEGER G
         END MODULE

         PROGRAM MAIN
           REAL ABC               ! Contains name abc
            ...
           CONTAINS
             SUBROUTINE SUB
               USE ABC                   ! Contains name abc
              ...
             END SUBROUTINE
         END PROGRAM

is SUBROUTINE SUB standard-conforming?

ANSWER:

Answer 1:  Yes, a module name is a global entity.

Answer 2:  No, a local entity in a scoping unit may not have the same
name as a module  accessed by that scoping unit.

Answer 3:  No, subroutine SUB is not standard conforming.  A module can
not be use associated in a scoping unit that also accesses a local name
that has the same name as the module.

Discussion:

Section 11.3 defines a module name to be a global "name".

Section 14.1.1 defines global "entities". The definition includes module
names because the definition lists program units and a module is a
program unit.

Section 14.1.2 states that a "name" that identifies a global "entity"
must not be used to identify a local "entity".

Section 11.3 [157:24-26] states:

The module name is global to the executable program, and must not be the
same as the name of any other program unit, external procedure, or
common block in the executable program, nor be the same as any local
name in the module.

This would mean that the following:

           MODULE ABC
             REAL ABC
           END MODULE

is NOT standard conforming.

Section 14.1.2 [241:29-31] states:

Except for a common block name (14.1.2.1) or an external function name
(14.1.2.2), a name that identifies a global entity in a  scoping unit
must not be used to identify a local entity of class (1) in that scoping
unit.

When a name is established to be a global entity in a scope, any entity
of the host that has this as its nongeneric name is inaccessible.  This
rule is described for global entities that are external procedures in
section 12.1.2.2.1. An edit is supplied to describe this rule for module
names.

REFERENCES: ISO/IEC 1539:1991 (E) Sections 11, 11.3, 12.1.2.2.1, 14.1.1,
and 14.1.2

EDIT:

In section 12.1.2.2.1 after the first sentence of the second paragraph
that ends "the host entity is inaccessible." add:

"A name that appears in the scoping unit as a <module-name> in a <use-
stmt> is a global name and any entity of the host that has this as its
name is inaccessible."

SUBMITTED BY: L. R. Rolison in x3j3/93-037 at meeting 124.
LAST SIGNIFICANT CHANGE:  93 Feb, new	000127
HISTORY: Submitted at meeting 124 in 93-037.
         Draft response proposed at meeting 124 in paper 93-097

--------------------------------------------------------------------------------

NUMBER: 000128
TITLE: Use associated generic names and renaming
KEYWORDS: Use association, generic names, renames
DEFECT TYPE: Erratum
STATUS: X3J3 consideration in progress

QUESTION:  In section 11.3.2 the standard indicates that if two generic
interfaces are accessible in the same scoping unit and have the same
name they are interpreted as a single generic interface.

Does the use of the phrase 'the same name' in this context include names
introduced through renaming on a USE statement?

More specifically, given the following module definitions:

          MODULE M1
            INTERFACE GEN1
              SUBROUTINE S1 (I)
              END SUBROUTINE
            END INTERFACE
          END MODULE

          MODULE M2
            INTERFACE GEN2
              SUBROUTINE S2 (I,J)
              END SUBROUTINE
            END INTERFACE
          END MODULE

          MODULE M3
            INTERFACE GEN1
              SUBROUTINE S3 (I)
              END SUBROUTINE
            END INTERFACE
          END MODULE

which of the following code fragments are standard conforming?

  a)  USE M1, GEN => GEN1
      USE M2, GEN => GEN2

  b)  USE M1
      USE M2 GEN1 => GEN2

  c)  USE M1
      USE M3 OTHERGEN => GEN1 ! Avoid conflict with GEN1 from M1

ANSWER:

Yes, the use of the cited phrase in the question 'the same name' in this
context include names introduced through renaming on a USE statement.
Thus, all three code fragments are valid.

Discussion: In section 14.1.2.3 rules for "Unambiguous generic procedure
references" are provided. These rules "must be satisfied by every pair
of specific procedures that have the same generic name".

In code fragment a, the generic interface named "GEN" is interpreted as
a single generic interface and subroutines S1 and S2 are specific names
of that interface. The rules in 14.1.2.3 also are met.

In code fragment b, because GEN2 is renamed to be GEN1, and GEN1 then
GENomes a local name, the generic interfaces named GEN1 from  MODULEs M1
and M2 are treated as a single generic interface, based on the 11.3.2
rules.

In code fragment c, OTHERGEN is the local name for GEN1 in module M3.
GEN1 is the local name for GEN1 in module M1.  As these local names are
not the same, the generic interfaces are not treated as a single generic
interface.

The sentence in section 11.3.2 that states that if two "generic
interfaces that are accessible in a scoping unit have the same name"
does not clearly state that that name is a "local" name which was the
intent of the standard.  An edit is provided to correct this.

REFERENCES: ISO/IEC 1539:1991 (E) section 11.3.2, 14.1.2.3.

EDIT:

The sentence in section 11.3.2 that states that if two "generic
interfaces that are accessible in a scoping unit have the same name",
change

              "the same name"
to
              "the same local name".

SUBMITTED BY: Janice C. Shepherd
LAST SIGNIFICANT CHANGE:  1993 02 08, new	000128
HISTORY: Submitted at meeting 124, in 93-058
         Draft response proposed at meeting 124, in 93-096, as item 128,
         in 93-006.

--------------------------------------------------------------------------------

NUMBER: 000129
TITLE: Array constructors in initialization expressions
KEYWORDS: array constructors, initialization expressions, implied-DO
variables
DEFECT TYPE: Interpretation
STATUS: X3J3 draft response

QUESTION:  It was likely the intent of the standard to allow the program
fragment

            INTEGER ARRAY(3)
            PARAMETER ( ARRAY = (/ (ABS(I), I=-3,-1) /) )

However, according to the text in the second list in 7.1.6.1 "(/
(ABS(I), I=-3,-1) /)" is not an initialization expression.

The array constructor "(/ ABS(-3), ABS(-2), ABS(-1) /)" qualifies as an
initialization expression since item (2) in the list indicates that an
array constructor is an initialization expression if each element is an
initialization expression, and (4) includes

      "An elemental intrinsic function reference of type integer or
character where
        each argument is an initialization expression of type integer or
character."

The problem with the "ABS(I)" in PARAMETER ( ARRAY = (/ (ABS(I), I=-3,-
1) /) ) is that "ABS(I)" is not defined as an initialization expression.
It does not qualify under (4) as "I" is not an initialization expression
and it does not qualify under (2) as the primary UABS(I)U is neither an
initialization expression nor an implied-do variable.

Is the program fragment standard conforming.

ANSWER: No, the fragment is not standard conforming.

        In the fragment

            PARAMETER (ARRAY = (/ (ABS(I), I = -3, -1) /) )

        and considering 7.1.6.1, second list, rule 2

            ABS(I) is an element of the array constructor.  It is
            an expression consisting of exactly one primary, a function
            reference.

            That function reference has one argument, I, which is
            another expression consisting of exactly one primary.
            That primary is not an initialization expression and thus
            does not meet the requirements of rule 4.

Nothing could be found indicating that the intent of standard was other
than that indicated above.

REFERENCES: ISO/IEC 1539:1991 (E) section 7.1.6.1

EDITS:  None.

SUBMITTED BY: Janice C. Shepherd
HISTORY: Submitted as paper 93-027
         Draft response 93-088 approved

--------------------------------------------------------------------------------

NUMBER: 000130
TITLE: Multiple statements on line with END statement
KEYWORDS: END statement
DEFECT TYPE: Erratum
STATUS: X3J3 draft response

QUESTION:  Can the end statement of a program unit be followed on the
same line with statements for another program unit?

By use of a ';' one can have multiple statements appear on a single line
as in:

       A = 1;  B = A;

The standard does not seem to indicate one way or another whether an END
statement can be followed by another statement on the same line.
Presumably the statement would belong to the next compilation unit if
such use was allowed, e.g.:

      END; SUBROUTINE S

It is hoped that the intent of the standard is that any statement
appearing on the same line as a program unit END statement must appear
before the END statement.

Note that
      END; SUBROUTINE S
looks very much like
      END SUBROUTINE S;
with a slight typo.

ANSWER:  No, a program unit END statement cannot be followed on the same
line with statements for another program unit.

The text in 3.3 "Source Form" is incomplete and an edit is provided for
its repair.

REFERENCES: ISO/IEC 1539:1991 (E) sections 3.3.1.2 and 3.3.2.2

EDIT: Replace the first sentence of 3.3 with:

    A Fortran program unit is a sequence of one or more lines,
    organized as Fortran statements, comments, and INCLUDE lines.

SUBMITTED BY: Janice C. Shepherd
HISTORY: Submitted as paper 93-059
         Approved response 93-094

================================================================================

LAST SIGNIFICANT CHANGE: before meeting 123	000011 	8
LAST SIGNIFICANT CHANGE: 1993-02-11    000012  9
LAST SIGNIFICANT CHANGE: 1993-02-12	000027 	16
LAST SIGNIFICANT CHANGE: 1993-02-11    000030  17
LAST SIGNIFICANT CHANGE: 92-11-10, new response 000031  19 approved at
                         meeting 123
LAST SIGNIFICANT CHANGE: 1992 11 10, revised content	000032 	19
LAST SIGNIFICANT CHANGE: 1993-02-12    000039   23
LAST SIGNIFICANT CHANGE: 1993-02-12	000041 	24
LAST SIGNIFICANT CHANGE: 1992 11 11, opposite response	000056 30
LAST SIGNIFICANT CHANGE: 1992-11-12	000057 	31
LAST SIGNIFICANT CHANGE: 1992 11 13    000060  33
LAST SIGNIFICANT CHANGE: 1993,-02-12, revised	000070 	38
LAST SIGNIFICANT CHANGE: 1992-11-12, added edits to previously proposed
                         interpretation  000071  39
LAST SIGNIFICANT CHANGE: 93-02-11	000073 	39
LAST SIGNIFICANT CHANGE: 92-11-11, first draft response	000075 40
LAST SIGNIFICANT CHANGE: 1992 11 10, new	000078 	45
LAST SIGNIFICANT CHANGE: 1993-02-10	000079 	46
LAST SIGNIFICANT CHANGE: 92-11-13	000080 	47
LAST SIGNIFICANT CHANGE: 93 02 11, initial response	000082 	49
LAST SIGNIFICANT CHANGE:	000083 	49
LAST SIGNIFICANT CHANGE: 1992-11-10, new	000086 	51
LAST SIGNIFICANT CHANGE:  1993-02-10	000087 	52
LAST SIGNIFICANT CHANGE: 92-11-11, first draft response	000088 52
LAST SIGNIFICANT CHANGE:  1993-02-10	000089 	53
LAST SIGNIFICANT CHANGE: 1993 meeting 124, 	000090 	54
LAST SIGNIFICANT CHANGE: 1993-02-10	00091 	54
LAST SIGNIFICANT CHANGE:  1993-02-10	000092 	55
LAST SIGNIFICANT CHANGE: 1993-02-10	000093 	55
LAST SIGNIFICANT CHANGE:	000095 	57
LAST SIGNIFICANT CHANGE: 92-11-11	000096 	57
LAST SIGNIFICANT CHANGE: 93-02-12	000097 	58
LAST SIGNIFICANT CHANGE:  1993-02-10	000100 	59
LAST SIGNIFICANT CHANGE: 92-11-11	000103 	61
LAST SIGNIFICANT CHANGE:	000104 	61
LAST SIGNIFICANT CHANGE: 93 Feb. 000105 	62
LAST SIGNIFICANT CHANGE:  1993-02-10, expanded discussion	000106 63
LAST SIGNIFICANT CHANGE: 1993-02-10	000108 	64
LAST SIGNIFICANT CHANGE: 1992 11 11, new	000109 	64
LAST SIGNIFICANT CHANGE:  1992-11-13	000111 	65
LAST SIGNIFICANT CHANGE: Nov. 1992, original draft response	000112 65
LAST SIGNIFICANT CHANGE: 1993-02-11	000113 	66
LAST SIGNIFICANT CHANGE:  1993-02-10	000114 	66
LAST SIGNIFICANT CHANGE: 1992-11-11, new	000115 	67
LAST SIGNIFICANT CHANGE: 1992-11-13	000116 	68
LAST SIGNIFICANT CHANGE: 1992-11-12, new	000117 	68
LAST SIGNIFICANT CHANGE: 1992 11 12, new	000118 	68
LAST SIGNIFICANT CHANGE: 1992 11 12, new	000119 	69
LAST SIGNIFICANT CHANGE: 1992 11 11, new	000120 	69
LAST SIGNIFICANT CHANGE:	000121 	69
LAST SIGNIFICANT CHANGE: 93 Feb, new	000123 	70
LAST SIGNIFICANT CHANGE:  93, Feb. new	000124 	70
LAST SIGNIFICANT CHANGE:  1993-02-12	000125 	71
LAST SIGNIFICANT CHANGE: 1993 meeting 124	000126 	72
LAST SIGNIFICANT CHANGE:  93 Feb, new	000127 	73
LAST SIGNIFICANT CHANGE:  1993 02 08, new	000128 	74
