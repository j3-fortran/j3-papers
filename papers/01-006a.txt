
                                                           01-006a

Date:     19 May 2001
To:       J3
From:     Stan Whitlock
Subject:  Outstanding Fortran 95 Interpretations


This document contains all the outstanding Fortran 95
interpretations, with their most recent draft replies. It does not
contain comments in referenced papers, though you may need these to
work further on an interpretation.

The 006 is in 2 parts:  006a and 006b:

  o  006a contains the F95 interpretations that are being processed
     along with a complete index of all F95 interpretations and
     their status

     JP-39 has been completely removed (withdrawn by submitter).
     000016 has been completely removed (duplicated by 000071).

  o  006b conatins the F95 interpretations that have completed
     processing and have been included in Corrigendum 1.

======================================================================
Table of Contents
======================================================================

Part 0 contains the summary status of all of the Fortran 95
       interpretations

Part 1 contains the interpretation processing rules from 00-142.

Part 2 contains F95 interpretation 000000e (typographical interps),
       interpretations 1-32 (00-126) and 66-85 (00-126).  The
       current "last" F95 interpretation is 000093.

Part 3 contains the remaining F90 interpretations left over, with
       their F90 interp numbers (prefixed with "F90/").

       Exceptions: 000200 was already subsumed by 000202 and so does
                          not appear.
                   000202 was replaced by F95/000012 at meeting 143.
                   Note: F90/000202 history added to F95/000012
                         history.

       Note: Additionally to those noted in 00-126, F90 interps
             000206-000212 are included

Part 4 contains the Japanese interpretations with their Japanese
       numbers (JP-4 etc.).

----------------------------------------------------------------------

======================================================================
Part 0: Summary Status of these Fortran 95 Interpretations
======================================================================

Status S:                              Defect Type T:
       P == J3 consideration in progress           C == Clarification
       M    Passed by J3 meeting                   E    Erratum
       B    Passed by J3 letter ballot             I    Interpretation
       W    Passed by WG5 ballot
       C    Included in corrigendum

   S T number     title
   - - ------     -----

   P I 000000e    Rejected Minor edits and corrections
   C I 000001     Visibility of a data object with statement scope
   M I 000002     Free source form requirement for blank in PRINT
                    statement
   C I 000003     Ability to overload the character operator //
   P I 000004     Value returned by MAXVAL/MINVAL
   C I 000005     Value returned by SELECTED_REAL_KIND
   P I 000006     Character length specification of a function result
   P I 000007     Optional intrinsic function arguments
   P I 000008     Optional arguments to MAX/MIN
   P I 000009     INTENT of MOLD argument to TRANSFER
   M C 000010     Meaning of embedded blanks in namelist input name
   M E 000011     G editing typo
   M E 000012     Evaluation of Intrinsic Procedures
   P   000013     Format of zero in list-directed and namelist output
   W   000014     Format of complex numbers in list-directed and
                    namelist output
   W   000015     Commas in list-directed output
   P I 000017     Characteristics of an array function result
   M E 000018     ELEMENTAL procedures with no arguments
   M E 000019     Result of NULL intrinsic associated with
                    CHARACTER(*) dummy argument
   M E 000020     Execution of a WHERE statement within a WHERE
                    construct
   M E 000021     Restrictions on <generic-spec> on END INTERFACE
   M E 000022     Use of NULL() as initialization
   M E 000023     Termination of the previous record by a WRITE
                    statement
   M E 000024     Termination of a partial record by a CLOSE,
                  BACKSPACE, ENDFILE, or REWIND statement
   M E 000025     List-directed input: types of variables
                    corresponding to repeated values
   P   000026     List-directed input: types of variables
                    corresponding to repeated values
   P   000027     Sequential formatted I/O: position of the left tab
   M C 000028     Implicitly Typed Statement Function Character Dummy
   M E 000029     Association of a pointer actual argument with a
                    dummy argument
   P   000030     Ordering requirements on definition of
                    specification functions
   P   000031     Association of pointer function result with
                    INTENT(OUT) dummy argument
   W   000032     Is the TRANSFER function result undefined?
   P E 000066     Errors in processing data transfer statements
   P E 000067     Writing zeros
   P E 000068     Asterisks as I/O units
   C E 000069     What is a numeric character?
   C E 000070     Asymmetry between constant specification and
                    initialization expressions
   P E 000071     Character array constructors
   C E 000072     Resolving generic procedure references
   W   000073     Is padding allowed in storage sequences?
   P   000074     TARGET dummy arguments and POINTER expressions
   W   000075     Defined assignment and INTENT(IN) dummy arguments
                    in PURE procedures
   C E 000076     INTENT(IN) dummy arguments and implied DO loops
   C E 000077     INTENT(IN) dummy arguments and NULLIFY
   P   000078     Resolving generic procedure references
   C E 000079     Pointer Assignment and Allocatable Arrays
   C E 000080     Host association and the EXTERNAL attribute
   M C 000081     Definition status of derived-type objects with
                    pointer components
   C E 000082     Usage of BOZ literal constants
   C E 000083     Scope of array-constructor implied-DO variable
   C E 000084     Events that cause variables to be defined
   M E 000085     Public components of private types
   P   000086     Definition status requirements for defined operations
   M E 000087     MOD and MODULO intrinsic functions with zero divisor
   M E 000088     INTRINSIC statement and attribute
   M E 000089     Rules allowing duplicate names
   M C 000090     What do `Prior Specification' and `defined
                    previously' mean?
   M E 000091     Definition of "present" is defective
   M E 000092     Values of the PAD= Specifier in the INQUIRE Statement
   M E 000093     Allocatable arrays as actual arguments
   P I F90/000049 Characteristics of function results
   P E F90/000070 Characteristics specified by interface bodies
   P E F90/000096 Definition of "Declaration"
   C I F90/000100 ASSOCIATED intrinsic and zero-sized objects
   P E F90/000140 TARGET attribute for a derived-type object with a
                    pointer component
   P E F90/000145 Expressions in <type-spec> of a FUNCTION statement
   P   F90/000164 Use of ONLY with multipart definitions
   C I F90/000179 DO variable with POINTER attribute
   P E F90/000180 Unambiguous generic references
   C I F90/000185 What is the allocation status of an array after an
                    allocation failure?
   P I F90/000190 Subobjects of constants in a DATA statement
   P E F90/000191 Interaction of SEQUENCE derived types and rename
   C I F90/000194 Statements between SELECT CASE and CASE
   P E F90/000196 Inaccessibility of intrinsic procedures
   W   F90/000197 Relationship of NEAREST and SPACING
   P   F90/000204 Meaning of "same variable" description of MVBITS
   P   F90/000205 Restrictions on EXTERNAL
   P   F90/000206 Collating sequence inconsistencies
   P   F90/000207 Integer bit-model inconsistency
   P   F90/000208 nonadvancing output followed by list directed output
   P   F90/000209 STOP|PAUSE in I/O statement
   P   F90/000210 nonadvancing write followed by list directed write
   P   F90/000211 Multiple MODULE PROCEDURE specs
   P   F90/000212 EQUIVALENCE of Data Objects of Different Types or
                    Kinds
   P   JP-04      Construction of derived-type values
   P   JP-05      Construction of array values
   M E JP-06      Type declaration statements
   P   JP-08      Type declaration statements
   W   JP-12      Bounds of each dimension of an array pointer
   P   JP-16      Multiple occurrence of namelist-group-name in
                    NAMELIST statement
   P   JP-17      Multiple occurrence of namelist group object in
                    namelist group
   P   JP-24      The bnf term shared-term-do-construct
   P   JP-31      Signs of literal constants

======================================================================
Part 1: Interpretation Processing Rules
======================================================================

0. All interpretations are listed in J3 standing document 006.

1. Interpretations are processed by the J3/interp group and given a
   number.  The interpretation is marked "J3 consideration in
   progress".  An answer is formulated and presented to J3 in a
   meeting paper.

2. J3 votes on the answer at a J3 meeting; a simple majority vote
   marks the answer as "passed by J3 meeting".

3. Between J3 meetings the chair of /interp sends a J3 letter ballot
   to J3 to approve interp answers that have been "passed by J3
   meeting".  The letter ballot runs for 30 days.  Not voting on
   three of four consecutive J3 letter ballots is grounds to
   terminate J3 membership.  An interp answer passes by a 2/3rds
   vote; a no vote must be accompanied by an explanation of the
   changes necessary to change the member's vote to yes.

   J3/interp reserves the right to recall an interp answer for more
   study even if the answer passes.

4. The chair of J3/interp gathers all interp answers that are marked
   "passed by J3 letter ballot" and forwards them to the WG5
   convenor.  The WG5 convenor holds a ballot of individual members;
   a no vote must be accompanied by an explanation of the changes
   necessary to change the member's vote to yes.  The answers that
   pass this ballot become "WG5 approved".

   J3/interp reserves the right to recall an interp answer for more
   study even if the answer passes.

5. "WG5 approved" answers are processed into a corrigendum document
   by taking the edits from the interp answers and putting them in
   the format required by ISO.  A WG5 vote is made on forwarding the
   corrigendum to SC22.  Interps so forwarded are marked
   "Corrigendum".

6. J3/interp creates a edit for F2K if one is needed for all interps
   marked "Corrigendum".

----------------------------------------------------------------------

======================================================================
Part 2: Correctly numbered F95 interpretations
======================================================================

NUMBER: 00000e
TITLE: Rejected Minor edits and corrections
KEYWORDS: typographical errors
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

QUESTION: Should the following be added to the list of edits?

 8. In 13.13.85 RANGE

        change 'Returns the decimal exponent range in the model ...'
            to 'Returns the upper bound of the decimal exponent range
                of the model ...' [228:20]

    Rationale(1): a range has two values; RANGE returns only one.

    Rationale(2): there is not a decimal range in the model, see 13.7.1,
                  but a decimal range can be calculated. Thus
                  the change from 'in' to 'of'.

 9. In 13.13.79 PRECISION

        change 'Returns the decimal precision in the model ...'
            to '............................. of .............' [226:4]

    Rationale: same as for RANGE, above.

ANSWER: This item collects failed "minor edits and corrections" so that the
reasons for failing them can be recorded for historical purposes. No further
voting is needed for items in this list.

No, 8 and 9 should not be added.  The use of 'range' is consistent with
other
uses in the standard and is meant to convey an entire range of values not
just
2.  The change from 'in' to 'of' is too small a change to be included at
this
time and would best be addressed in a future standard.

EDITS: None
SUBMITTED BY:
HISTORY: 94-028 m128 additional items 8-9

----------------------------------------------------------------------

NUMBER: 000002
TITLE: Free source form requirement for blank in PRINT statement
KEYWORDS: Free source form, PRINT, blank
DEFECT TYPE: Interpretation
STATUS: Passed by J3 meeting

QUESTION:

Consider the following PRINT statement form:    PRINT"(I5)",5

Section 3.3.1 of the Fortran 95 standard states:

  A blank shall be used to separate names, constants, or labels from
  adjacent keywords, names, constants, or labels.

  NOTE 3.3
  For example, the blank[s] after ... READ ... [is] required in the
  following:

  ...
  READ 10
  ...

Although the sentence preceding R420 is somewhat confusing in that it
uses the phrase "a sequence of characters, DELIMITED by either
apostrophes or quotation marks", the syntax rule itself is clear that
the " or ' delimiting characters are part of the
<char-literal-constant> syntax.  The first sentence on the top of
page 36 then clarifies that although the delimiter characters are a
part of the syntax, they are not a part of the value.

Section 3.2 makes it clear that a character literal constant is a
token. Section 3.2.5 describes delimiters but does not include either
" or ' because it is describing delimiters for lists.

Thus, it seems clear that in free source form a blank is required
between the keyword PRINT and the character literal constant
containing the format list but there is also some disagreement on
this point among existing Fortran processors.

(1) In free source form, is a blank required between the keyword
    PRINT and the character literal constant containing the format
    specification?

(2) Also, for clarification, in free source form, is a blank required
    between the keyword PRINT and the asterisk that represents the
    list-directed output specifier?

ANSWER:

(1)  Yes.  The analysis in the QUESTION is correct.  Since PRINT is a
     keyword, when the format specification is a character literal
     constant, the blank is required between the keyword PRINT and
     the format specifier.

(2)  No.  Since PRINT is a keyword, according to the cited rule in
     3.3.1, the asterisk would have to be a name, a constant, or a
     label in order for a blank to be required to separate PRINT from
     the asterisk.  By 3.2.1, an asterisk is not a name.  By 3.2.2,
     an asterisk is not a constant.  And by 3.2.4, an asterisk is not
     a statement label.  Yes, an asterisk may be used as a dummy
     argument alternate return specifier representing a statement
     label but that usage is irrelevant to the PRINT statement.
     Therefore, since an asterisk is none of the three items that
     must be separated from PRINT by a blank, the blank is not
     required.

EDITS:  None.

SUBMITTED BY:  Larry Rolison / Dick Hendrickson

HISTORY:  97-238   m143 Submitted
          01-151r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000004
TITLE: Value returned by MAXVAL/MINVAL
KEYWORDS: MAXVAL, MINVAL
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

QUESTION:
The Result Value section of the MAXVAL intrinsic function description
uses the phrasing:

  or has the value of the negative number of the largest magnitude
  supported by the processor for numbers of the type and kind type
  parameter of ARRAY if ARRAY has size zero

This phrasing has generated at least the two following views on the
return value:

 * If the machine supports the IEEE standard then the implementation
   should return -inf.
 * For portability, the implementation should return -HUGE(ARRAY).

These views lead to the following questions:

1. Is the intent of the standard to describe the result in terms of
   machine values rather than model values?

2. If the answer to 1 is "yes", how are programmers expected to use
   this intrinsic function portably?

ANSWER:

1.   Yes.  Processors may support values that are not present in the
model of 13.7.1.  IEEE -inf is an example of such a number and this
may be returned on a machine that supports the IEEE standard.  If the
negative number of the largest magnitude in the model had been
intended, the model would have been mentioned as, for example, in the
definition of HUGE (13.14.39).

2.   A simple example of its use is to test whether a set of numbers
SET1 has a value greater than any value in the set SET2.  Consider
the expression MAXVAL (SET1) > MAXVAL (SET2).  If SET1 is empty and
SET2 is not, this value is correctly false even if all of the values
are outside the model with values less than -HUGE (SET1).

  It may be helpful to consider how MAXVAL might be coded for an
array of rank one on an IEEE computer.  The following code is
suitable.

    MAXVAL = IEEE_VALUE ( 1.0, IEEE_NEGATIVE_INF)
    DO I = 1, SIZE (ARRAY)
          MAXVAL = MAX (MAXVAL, ARRAY(I))
    END DO

  All of the reduction functions (e.g., MAXVAL, SUM) return values
when the arguments are zero-sized arrays that may be the same as the
values returned for some non-zero-sized arguments.

EDITS: None.

SUBMITTED BY:  Larry Rolison

HISTORY:  97-240    m143  submitted
          00-160r2  m153  Passed 7-5
          00-254    m154  Failed J3 letter ballot

------------------------------------------------------------

NUMBER: 000006
TITLE: Character length specification of a function result
KEYWORDS: character, function result
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

QUESTION:

Consider the following program:

      PROGRAM main
      CHARACTER(8) arg, func
      EXTERNAL func
      CALL sub(arg, func)
      END PROGRAM

      SUBROUTINE sub(arg, func)
      CHARACTER(*) arg, func
      CHARACTER(8) str
      str = func(arg)
      ...
      END SUBROUTINE

      CHARACTER(8) FUNCTION func(arg)
      CHARACTER(*) arg
      ...
      END FUNCTION

Some implementations error the reference to FUNC in subroutine SUB and some
do
not.  The implementations that do not error the reference to FUNC use
essentially the following as the argument for allowing the reference:

  The rules for when an asterisk can be used to specify character length are
  specified on in section 5.1.1.5 (middle of page 51 of the Fortran 95
  standard).

    * The first rule states that an asterisk may be used to declare a dummy
      argument of a procedure.  It is clear that FUNC is a dummy argument of
      SUB.

    * The third rule says that in an external function, the length of the
      result may be specified within the function itself with an asterisk
but
      if the result length is so specified, any invoker of the function must
      specify the character length of the function result as something other
      than an asterisk.  But the function that is being invoked in the above
      example does not declare its result length using the asterisk, so this
      rule does not apply.

Is the above sample program a standard conforming program with respect to
the
concept of declaring the function result length in the invoking program as
an
asterisk?

ANSWER:

EDITS:

SUBMITTED BY:  Larry Rolison
HISTORY:  J3/97-242 m143 submitted

----------------------------------------------------------------------

NUMBER: 000007
TITLE: Optional intrinsic function arguments
KEYWORDS: intrinsic function, argument - optional
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

BACKGROUND:
Interpretation request 000053 asked the following question:

  QUESTION:  Should constraining text be added to the description of

               optional argument   Y    in CMPLX, and
               optional argument   BACK in INDEX, and
               optional argument   SIZE in ISHFTC, and
               optional argument   A3,... in MAX, and
               optional argument   A3,... in MIN, and
               optional argument   BACK in SCAN, and
               optional argument   BACK in VERIFY

  to state that the argument must not be an optional argument of an invoking
  procedure?

and it was answered as follows:

  ANSWER:  In principle yes; however it is more appropriate to add an
  additional restriction on dummy arguments not present in section 12.5.2.8.

  Discussion: The standard contains numerous restrictions intended to ensure
  that the rank of a given expression never changes.  The case of elemental
  functions with optional arguments was inadvertently overlooked.

  Consider the following subprogram:

          SUBROUTINE SUB (A,B,C)
            INTEGER :: A ,B
            INTEGER, OPTIONAL :: C (:)
            PRINT *, MAX (A, B, C)
          END

  When C is present, the result of the elemental function MAX, is an array
of
  the same shape as C.  However, if SUB were to be called with the third
  argument omitted, the result would be a scalar.  The supplied edit
remedies
  this deficiency.

Corrigendum 1 then edited the Fortran 90 standard as follows:

  EDITS:
  1. Add the following point to the numbered list in section 12.5.2.8:
     [179:38]

    (5) If it is an array, it must not be supplied as an actual
        argument to an elemental procedure unless an array of the same
        rank is supplied as an actual argument corresponding to a
        nonoptional dummy argument of that elemental procedure.

  2. In the paragraph following the numbered list, replace "It" with
     "Except as noted in (5) above, it" [179:39]

Corrigendum 3 modified the above edit as follows as part of the response to
Interpretation request 000193:

  EDITS:
  1. In Section 12.5.2.8, add the following to the numbered list
    after the list item added by Corrigendum 1 [179:38+]:
    "(6) If it is a pointer, it must not be supplied as an actual
     argument corresponding to a nonpointer dummy argument other
     than as the argument of the PRESENT intrinsic function."

  2. In Section 12.5.2.8, in the text added by Corrigendum 1
     to the last sentence of the section [179:39]:
     change "in (5)" to "in the list"

The text as modified appears at the end of 12.4.1.5 on page 203 of the
Fortran 95 standard.

QUESTION:
While the response to interpretation request 000053 stated "in principle"
that
an optional dummy argument should not be passed to an optional argument of a
called procedure, and it closed a "loophole" for optional array dummy
arguments, it still did not address the simpler case of an optional scalar
dummy argument being passed to the cited intrinsics.

Consider the following example:

       SUBROUTINE sub(string, substring, direction)
       CHARACTER(*)    :: string, substring
       LOGICAL, OPTIONAL :: direction

       k = INDEX(string, substring, direction)
       ...
       END SUBROUTINE

The last paragraph of 12.4.1.5 states:

  Except as noted in the list above, it may be supplied as an actual
argument
  corresponding to an optional dummy argument, which is then also considered
  not to be associated with an actual argument.

The only case in "the list above" that is relevant is (1) because DIRECTION
is
a dummy data object and is not an array or pointer.  But (1) does not apply
because the appearance of DIRECTION as an actual argument is not a reference
by
the following from 2.5.5:

  The appearance of a data object name, data subobject designator, or
procedure
  name in an actual argument list does not constitute a reference to that
data
  object, data subobject, or procedure unless such a reference is necessary
to
  complete the specification of the actual argument.

The appearance of DIRECTION is not "necessary to complete the specification
of"
DIRECTION, so therefore it is not a reference so therefore (1) does not
apply.
Thus, the last paragraph of 12.4.1.5 does seem to apply which indicates that
an
optional dummy argument can be passed to an optional argument of an
intrinsic
procedure such as INDEX.  However, this does not seem to agree with the
"principle" espoused in the answer to interpretation request 000053, nor
does
the description of INDEX seem to indicate how the result is to be determined
if
the BACK argument is specified but is not present.  (One could possibly
construe the phrase "If BACK is absent" to mean "specified but not present"
but
that does not seem to be the intent of the existing wording or the
"principle"
espoused in interpretation request 000053.)

For an intrinsic procedure that has an optional argument, may an optional
dummy
argument be passed to the optional argument of the intrinsic procedure?

ANSWER:

EDITS:

SUBMITTED BY:  Larry Rolison
HISTORY:  J3/97-243 m143 submitted

Addendum:  A history of how this interp progressed:

Yukimasa Yoshida sent a message to the interpretation request bulletin board
noting that some of the actual arguments to intrinsic functions should not
be
allowed to be optional dummy arguments.  Since I could not find an
interpretation request in the premeeting papers for meeting 121, I submitted
paper X3J3/92-058 (121-LRR-5) with his message and added that the ISHFTC
intrinsic function should be added to the list supplied by Mr. Yoshida.

Given the hand-written notes on my paper copy of 92-058, the /PROC subgroup
apparently worked on my original paper and recast it as 92-094 with the
proposed edit:

  The restriction:

      "The corresponding actual argument must not be an optional
       dummy argument."

  should be added to the text describing these optional arguments mentioned
  above for CMPLX, INDEX, ISHFTC, MAX, MIN, SCAN, and VERIFY.

[ Historical aside:  While looking through the minutes for this meeting,
  I noticed that this was the meeting where Richard Maine joined the
committee
  and Walt rejoined the committee (to work on a validation suite for Fortran
  90).  Under Reports and Comments from Members, Andrew Tait expressed
concern
  about the copyright situation.  Some topics just never die, do they?  Mind
  you, meeting 121 was in May, 1992. ]

The minutes for the last day of the meeting show that Hirchert/Hoffert moved
to
adopt 92-094, but that it and several others were withdrawn.  There are
notes
as to why some of the others were withdrawn but not for 92-094.  I have no
personal notes from this meeting as I did not attend.

WG5 paper N786A authored by John Reid is a proposal for the Victoria meeting
to
create a corrigendum for the Fortran 90 standard.  As part of this proposal,
BSI suggested the following change with respect to an optional dummy
argument
being passed to optional argument of an intrinsic procedure:

  179/38+. Add:
           (5) If it is an array, it must not be supplied as an actual
               argument to an elemental procedure unless an actual
               argument that is present is an array of the same rank.
    Discussion: It was intended that the rank of an expression should
    never vary.

Note that this text again just focuses on the cases where rank causes a
problem.

I don't know the precise contents of WG5 paper N815A since I did not copy it
to
a local directory and it seems to no longer be available on the WG5 server
(at
least not through Richard's mirror), but presumably it is a refinement of
N786A
done at the Victoria meeting.

X3J3 paper 92-156a added the example to the Discussion section (or repeated
it
from N815A) and this paper also has the minor edit following the addition of
part (5) to the list.  The minutes of meeting 122 show that the paper was
approved by a vote of 20-3.

- - - - - - - -

>From a coworker here at SGI/CRI:

The restriction should be that they can't use OPTIONAL arguments not
present,
not just OPTIONALS.  In other words, it should be OK to have

   INDEX(a, b, back)

with BACK optional, provided that BACK is present if the intrinsic is
evaluated.

----------------------------------------------------------------------

NUMBER: 000008
TITLE: Optional arguments to MAX/MIN
KEYWORDS: intrinsic function, MAX, MIN, optional, argument
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

BACKGROUND:
Dick Hendrickson originally posed the question contained in this
Interpretation Request.  As will be seen in the Addendum, Richard Maine
agrees
with me that this question needs an official response.  Hence, I am
submitting
on Dick's behalf (to steal a little more of his thunder).  I have combined
some of his and Richard's words.  Any misstatements in transcription are
most
likely mine.  This intro should be deleted later in the interp process.

QUESTION:
It appears that there is a missing "optional" in the description of the
optional arguments [, A3, ...] in the MAX and MIN functions.  In the Fortran
90
standard, the MAX/MIN descriptions said "optional arguments.  A3, ...", but
those words do not appear 13.14.64 of the Fortran 95 standard.

Section 13.3 [217:27+] states

  ...optional arguments... are identified by the notation "optional" in
  the argument descriptions.

and goes on to describe another notation for the arguments that are listed
as
optional.  But it doesn't say anything about arguments given in [...] and
NOT
also listed as optional.

Suggested change to the argument descriptions for MAX and MIN:

Arguments.
A1, A2     shall both have the same type which shall be integer or real
           and they shall both have the same kind type parameter.

A3, ... (optional)  shall have the same type and kind type parameter as A1.

ANSWER:

EDITS:

SUBMITTED BY:  Larry Rolison / Dick Hendrickson
HISTORY:  J3/97-245 m143 submitted

- - - - - - - -

Addendum:
Dick's original question and the interchange that developed between he and
Richard Maine:

Date: Thu, 18 Sep 1997 13:02:28 -0500
To: x3j3@ncsa.uiuc.edu
From: Dick Hendrickson <dick.hendrickson@worldnet.att.net>
Subject: (x3j3.1997-309) Is A3 optional for MAX or MIN functions

My guess is that there is a missing "optional" in the description of
[, A3, ...] in the MAX and MIN functions.  In F90 the MAX/MIN descriptions
said "optional arguments.  A3,...", but I can't find those words
in F95 13.14.64

Section 13.3 (217:27) says "...optional arguments... are identified by the
notation "optional" in the arguments description." and goes on to describe
another notation for the arguments that are listed as optional.  But it
say anything about arguments given in [...] and NOT also listed as optional.

I don't know if we are doing bug fixes yet on F95, but shouldn't we change
the
argument description for MAX and MIN to

Arguments.
A1, A2     shall both have the same type which shall be integer or real
           and they shall all have the same type parameter.

A3,... (optional)  shall have the same type and type parameter as A1

It's clear what we meant to do, did I miss something simple somewhere?

Dick

- - - - - - - -

Date: Thu, 18 Sep 1997 12:52:42 -0700 (PDT)
From: Richard Maine <maine@altair.dfrc.nasa.gov>
To: Dick Hendrickson <dick.hendrickson@worldnet.att.net>
Cc: x3j3@ncsa.uiuc.edu
Subject: (x3j3.1997-310) Is A3 optional for MAX or MIN functions

Dick Hendrickson writes:

 > My guess is that there is a missing "optional" in the description of
 > [,A3,...] in the MAX and MIN functions.  In F90 the MAX/MIN descriptions
 > said "optional arguments.  A3,...", but I can't find those words
 > in F95 13.14.64
   ....
 > It's clear what we meant to do, did I miss something simple somewhere?

Its not quite so clear to me.  You may have missed something subtle.
Some intrinsics have multiple interfaces and there are subtle but
critical differences between an argument that is optional as opposed
to an argument that is omitted from one or more of the interfaces.

What isn't clear is which of these categories MIN and MAX fit into.
Is it one interface with an infinite number of optional arguments or
is it an infinite number of interfaces, each with a different number
of required arguments?

MIN and MAX are rather "special" in any case in that it is impossible
to write an interface for them (in a finite number of lines of code).
I'm not entirely sure that they fit in either category.

I'm not sure of the correct answer here - all I'm saying is that it
isn't as simple a case as it sounds at first glance.  You can actually
change what is or isn't legal depending on exactly how you describe
MIN and MAX (consider the restrictions in 12.4.1.5).  It may be an
error in f95, but I'd treat it as a "real" question, not as a typo.

--
Richard Maine
maine@altair.dfrc.nasa.gov
- - - - - - - -

Date: Thu, 18 Sep 1997 17:05:29 -0500
To: Richard Maine <maine@altair.dfrc.nasa.gov>
From: Dick Hendrickson <dick.hendrickson@worldnet.att.net>
Subject: (x3j3.1997-312) Re: Is A3 optional for MAX or MIN functions

At 07:52 PM 9/18/97 +0000, Richard Maine wrote:

>Dick Hendrickson writes:
>
> > My guess is that there is a missing "optional" in the description of
> > [,A3,...] in the MAX and MIN functions.  In F90 the MAX/MIN descriptions
> > said "optional arguments.  A3,...", but I can't find those words
> > in F95 13.14.64
>   ....
> > It's clear what we meant to do, did I miss something simple somewhere?
>
>Its not quite so clear to me.  You may have missed something subtle.
>Some intrinsics have multiple interfaces and there are subtle but
>critical differences between an argument that is optional as opposed
>to an argument that is omitted from one or more of the interfaces.
>
>What isn't clear is which of these categories MIN and MAX fit into.
>Is it one interface with an infinite number of optional arguments or
>is it an infinite number of interfaces, each with a different number
>of required arguments?

It's also not clear to me, but, as I read the MAX/MIN description
in Fortran 90 I'd say that A3,... are each optional arguments; not
that the description is a shorthand for an infinite number of lists.
If this is correct then upwards compatibility demands (well suggests anyhow)
that A3, A4, ... are each optional and this leads to the surprising result
that  MAX(A1=1,A2=2,  A4=4  ) is legal.

> It may be an
> error in f95, but I'd treat it as a "real" question, not as a typo.

I guess I agree with that, unless someone has an obvious answer.

Dick

- - - - - - - -

Date: Thu, 18 Sep 1997 15:38:57 -0700 (PDT)
From: Richard Maine <maine@altair.dfrc.nasa.gov>
To: Dick Hendrickson <dick.hendrickson@worldnet.att.net>
Cc: x3j3@ncsa.uiuc.edu
Subject: (x3j3.1997-313) Re: Is A3 optional for MAX or MIN functions

Dick Hendrickson writes:

 > If this is correct then upwards compatibility demands (well
 > suggests anyhow) that A3, A4, ... are each optional and this leads
 > to the surprising result that  MAX(A1=1,A2=2,  A4=4  ) is legal.

I think there might have been an interp related to that, but too many hot
non-J3 things right now for me to take the time to search the interps.

--
Richard Maine
maine@altair.dfrc.nasa.gov

[ Added note from Larry:  This time I could not find the interp that Richard
  maybe remembers.  At least nothing showed up when I searched both the A
and
  B categories using A4 and MAX. ]

----------------------------------------------------------------------

NUMBER: 000009
TITLE: INTENT of MOLD argument to TRANSFER
KEYWORDS: intrinsic function, TRANSFER, MOLD
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

BACKGROUND:
Dick Hendrickson submitted the background and questions contained in this
interpretation request.  Since there was no "official" reply forthcoming,
I've taken the liberty (with Dick's kind permission) of submitting his
informal question as a formal interpretation request.  I have adapted his
original email message and the reply he got from Rich Maine to the basic
interp request format so some of the words in this interp request are mine,
not theirs.  Any errors of interpretation of their words are mine.  This
background section can probably be deleted in a later phase of the
interpretation processing.

QUESTION:
In 13.3 [page 218:2], Fortran 95 states:

  The nonpointer dummy arguments of the generic intrinsic procedures in
13.14
  have INTENT(IN) if the intent is not stated explicitly.

In general, an actual argument that corresponds to a dummy argument that
does
not have the INTENT(IN) attribute does not need to be defined; you need to
look
at the particulars of the invoked procedure to decide if an actual argument
needs to be defined before the invocation.

It is likely that the only intrinsic procedure argument affected by this
change
in wording is the MOLD argument to the TRANSFER function.  The value of the
MOLD argument is never needed so there is no reason to define it before
invoking TRANSFER in a Fortran 90 program.  But, apparently it needs to be
defined in a Fortran 95 program.

This could break a program that uses a local name in a subroutine as the
MOLD
argument and doesn't always define the name with a value, or didn't save it.

In this case, MOLD is like the arguments to the numeric inquiry functions,
the
"attribute" is a compile time characteristic, not a run-time "value" and
should
have the same exception as for the inquiry functions.

(1) Was general statement about INTENT(IN) quoted above intentionally added
to
    the Fortran 95 standard (how did it get into the standard)?

(2) Is it the intent of the standard to apply this general statement to the
    MOLD argument of the TRANSFER intrinsic function?

ANSWER:
(1) Yes.  The cited text was became a part of the Fortran 95 standard as a
    result of applying the edits in Interpretation Request 184 to the
Fortran
    90 standard.  The edits applied by Interpretation Request are included
    in Corrigendum 3.

    [ Thanks to Richard Maine for providing this clue.  This comment should
      be removed in later processing.  Just wanted to give credit where
      credit was due. ]

(2)

EDITS:

SUBMITTED BY:  Larry Rolison / Dick Hendrickson
HISTORY:  J3/97-246 m143 submitted

----------------------------------------------------------------------

NUMBER: 000010
TITLE: Meaning of embedded blanks in namelist input name
KEYWORDS: NAMELIST, optional qualification, name, input
DEFECT TYPE: Clarification
STATUS: Passed by J3 meeting

BACKGROUND:
In running some older NAMELIST tests, a test case was encountered
that has embedded blanks within the "optional qualification"
following a namelist group object name:

    CHARACTER*10 string
    NAMELIST /junk/ string

    WRITE(9,*) ' $junk string(  :  ) = ''1234567890'' /'
    REWIND(9)
    READ(9,junk)
    ...
    END

While studying the standard to determine if the above program was
standard- conforming or not, some questions arose about the use of
"name" and embedded blanks in the namelist section 10.9.1.1.  Among
them were: Since a blank is a delimiter, should it be allowed to be
embedded in a variety of places in a namelist input record that are
not currently described by the standard?  Do we want to strain
namelist input scanning more than a reasonable amount?

In normal Fortran terminology, the term "name" does not include
subobject qualification.  In section 2.5.1 Name and designator, lines
2 through 5, the standard states:

  A name is used to identify a program constituent, such as a program
  unit, named variable, named constant, dummy argument, or derived
  type.  The rules governing the construction of names are given in
  3.2.1.  A subobject designator is a name followed by one or more of
  the following: component selectors, array section, array element
  selectors, and substring selectors.

In section 10.9.1 Namelist Input, lines 13 to 16, the standard states:

  In each name-value subsequence, the name shall be the name of a
  namelist group list item with an optional qualification and the
  name with the optional qualification shall not be a zero-sized
  array, a zero-sized array section, or a zero-length character
  string.  The optional qualification, if any, shall not contain a
  vector subscript.

In section 10.9.1.1 Namelist group object names, lines 32 and 33, the
standard states:

  The name in the input record may be preceded and followed by one or
  more optional blanks but shall not contain embedded blanks.

QUESTION:

(1) Does Section 2.5.1 mean that the optional qualification described
    in the 10.9.1 is not part of the name for namelist input?

    If the optional qualification is not part of the name, there seem
    to be no rules for where blanks and end-of-record may occur
    within the optional qualification.

    Also note that size of the name and the optional qualification
    together may be longer than the size of an input record if there
    are multiple levels of structure component qualification in a
    structure component reference.

(2) Are embedded blanks allowed within substring and subscript
    qualifications in the namelist input?  May an END-OF-RECORD occur
    in these same places?

(3) More specifically, are embedded blanks/END-OF-RECORD allowed in
    the following places in namelist input?

   a.  Between the name and the left parenthesis of either a
       substring or subscript qualification?

   b.  Between tokens within the parenthesized qualifier?

   c.  Between the two sets of parentheses for array and substring
       notation?

   d.  Within the two subscripts or start and end values themselves?

 (4) Are embedded blanks allowed within a reference to a structure?
     May an END-OF-RECORD occur within this reference?

ANSWER:

   The answer to all of the questions above is no.

   In section 10.9.1, the standard says "In each name-value
   subsequence, the name shall be ...".  This usage of "name" refers
   to the optionally qualified namelist group object list item;
   therefore, in this context, "name" refers to both the namelist
   group object name list item, and any following qualification.  In
   section 19.9.1.1, the standard says "The name in the input record
   may be preceded and followed by one or more optional blanks but
   shall not contain embedded blanks."  This usage of "name" also
   refers to optionally qualified namelist group object list item;
   therefore, no blanks are permitted anywhere within the "name" of a
   name-value subsequence.

   Since the end of a record has the same effect as a blank in
   namelist input (10.9), an end of record may not appear anywhere
   within the "name" of a name-value subsequence.

EDITS: None

SUBMITTED BY:  Joanne Brixius / Larry Rolison

HISTORY:  J3/97-253   m143  submitted
          J3/01-152r1 m156  Passed unanimously at J3 meeting

----------------------------------------------------------------------

NUMBER: 000011
TITLE: G editing typo
KEYWORDS: G edit descriptor
DEFECT TYPE: erratum
STATUS: Passed by J3 meeting

QUESTION:
In F95 section 10.5.4.1.2, the last line of the table shows an
equivalent conversion of F(w-n).1,n('b').  This is different from the
corresponding table in F90, which shows this conversion as
F(w-n).0,n('b').  There is no obvious reason for this change; it
appears to be a typo in f95.

Should this conversion be F(w-n).0,n('b') as in Fortran 90?

ANSWER:

Yes, this was a typographical error in f95.

EDIT:

[171:23] Last line of the table in 10.5.4.1.2.  Change ".1" to ".0"

SUBMITTED BY: Richard Maine

HISTORY: 97-225   m143 Submitted Aug. 12, 1997
         01-151r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000012
TITLE: Evaluation of Intrinsic Procedures
KEYWORDS: Algorithm, Mathematical, Computational
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:
1.  When the standard specifies an algorithm for computing a
    mathematical procedure, must a processor use the specified
    algorithm?

    Example: ANINT is defined as INT (A + 0.5).  On some processors
             ANINT (16 000 001.0) evaluates to 16 000 002.0 using
             this algorithm.

2.  May a processor return a mathematically equivalent result in the
    evaluation of a numeric intrinsic procedure?

    Example: If ANINT (16 000 001.0) can be computed as the more
             expected 16 000 001.0, may a processor do so?

ANSWER:
1.  No, a processor is not required to use the algorithm from the
    standard.

2.  Yes, a processor may return the mathematically equivalent result
    in the evaluation of any numeric intrinsic procedure.

DISCUSSION:
The use of an algorithm in the definitions for intrinsic procedures
is intended to describe the end result.  It is not intended to
require that a processor use a particular method of achieving that
result.  Thus, an algorithm specifies the mathematical results, not
the computational results, of the evaluation of intrinsic procedures.

This standard does not require a processor to use a particular
accuracy or precision.  Section 1.4, "Exclusions", states in part:

    "This standard does not specify: . . .
     (6)  The physical properties of the representation of quantities
          and the method of rounding, approximating, or computing
          numeric values on a particular processor." [1:26, 1:37-38]

The edits correct the definitions of the results for the intrinsic
functions ANINT and NINT to be expressed in mathematical terms.

EDITS:

On page 231, subclause 13.14.10, Result Value paragraph [231:16-17].
Replace by
  <Result Value.> The result is the integer nearest A, or if there are
  two integers equally near A, the result is whichever such integer
  has the greater magnitude.

On page 259, subclause 13.14.77, Result Value paragraph [259:9-10].
Replace by
  <Result Value.> The result is the integer nearest A, or if there are
  two integers equally near A, the result is whichever such integer
  has the greater magnitude.

SUBMITTED BY: Keith H. Bierman

HISTORY:  95-247r1  m134  Submitted as F90 interp 000202 with proposed
                          response, approved 9-4, subsumes F90 interp
                          000200.
          95-256    m134  Ballot failed, 10-6
          95-260    m135  Proposed response, no action
          96-023    m136  Proposed response, no action
          96-054    m137  Proposed response, no action
          96-117    m138  Proposed response, no action
          97-259r1  m143  Re-submitted as F95 interp 000012 with
                          proposed response
          00-214    m153  Passed unanimously
          00-254    m154  Passed J3 letter ballot
          00-268    m154  Failed WG5 ballot (N1395 & N1403)
          01-153    m155  Passed unanimously by J3 meeting
----------------------------------------------------------------------

NUMBER: 000013
TITLE: Format of zero in list-directed and namelist output
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:

1.  The fifth paragraph of Section 10.8.2 of the Fortran 90 standard clearly
    indicates that in list-directed output zero must be formatted according
to
    exponential format.  Most, though not all, of the implementations I
tried
    use fixed format.  Even the FCVS test suite assumes fixed format.
Should
    exponential format be used for zero in list-directed output?

2.  The same issue raised in question 1 applies to namelist output (see
Section
    10.9.2.1, paragraph 3).  Should exponential format be used for zero in
    namelist output?

ANSWER:  These questions are duplicated in interpretation number
000067.  See the answer to that query.

HISTORY: 97-165    m143 Submitted
         WG5/N1410      Draft answer

----------------------------------------------------------------------

NUMBER: 000014
TITLE: Format of complex numbers in list-directed and namelist output
KEYWORDS:
DEFECT TYPE:
STATUS: Passed by WG5 ballot

QUESTION:

1.  The seventh paragraph of Section 10.8.2 of the Fortran 95
    standard states that complex numbers must be written with no
    embedded blanks unless the complex constant is broken across two
    records.  Some of the implementations I tested put a blank after
    the comma even when the entire constant fit in a single record.
    Is an implementation permitted to include a blank after the
    comma in a complex constant produced by list-directed output
    when the constant fits in a single record?

2.  Is a blank permitted after the comma in a complex constant
    produced by namelist output when the constant fits in a single
    record?

ANSWER:
1. No.  Section 10.8.2 [178:2-3] states: "The only embedded blanks
permitted within a complex constant are between the comma and the end
of a record and one blank at the beginning of the next record."

2. No.  Section 10.9.2.1 [182:40-41] states: "The only embedded
blanks permitted within a complex constant are between the comma and
the end of a record and one blank at the beginning of the next
record."

SUBMITTED BY:
HISTORY: 97-165      m143   Submitted
         WG5/N1410          Draft answer
         00-260      m154   Passed by J3 meeting
         00-328      m155   Passed J3 letter ballot, as amended
         WG5/N1428          Passed by WG5 ballot

----------------------------------------------------------------------

NUMBER: 000015
TITLE: Commas in list-directed output
KEYWORDS:
DEFECT TYPE:
STATUS: Passed by WG5 ballot

QUESTION:

5.  The first paragraph of Section 10.8.2 of the Fortran 95 standard
    states:

      With the exception of adjacent nondelimited character
      constants, the values are separated by one or more blanks or
      by a comma optionally preceded by one or more blanks and
      optionally followed by one or more blanks.

    I have yet to find a Fortran implementation, other than my own,
    that satisfies this requirement.  In particular, the statement

        PRINT *, 1, ',', 2

    prints a comma immediately following the 1 on every
    implementation I tried.  The comma was followed by zero, one, or
    two blanks in different implementations.

    1.  Is a separator required between a constant other than a
        nondelimited character constant and a following nondelimited
        character constant in list-directed output?

    2.  Is a separator required between a nondelimited character
        constant and a following constant that is not a nondelimited
        character constant?

DISCUSSION: It is not clear in the question if the comma which is
output is the optional separator or is the character constant from
the list.

ANSWER:
1.  Yes.
2.  Yes.

A separator is required in both cases.  The text quoted, which
is at page 177:31-33, is quite explicit.  The key word is "adjacent".

SUBMITTED BY:
HISTORY: 97-165      m143   Submitted
         WG5/N1410          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Passed by J3 letter ballot, as amended
         WG5/N1428          Passed by WG5 ballot

---------------------------------------------------------------------

NUMBER: 000017
TITLE: Characteristics of an array function result
KEYWORDS: Characteristics, function
DEFECT TYPE: Interpretatation
STATUS: J3 consideration in progress

Sections 12.2.1.1 and 12.2.2 of the Fortran 95 standard define rules for
dummy
arguments and function returns in the presence of explicit interfaces that
allow array bounds expressions to be evaluated on either the calling side or
the called side of a call.  The interpretation provided for RFI 000049 on
the
X3J3 website clarifies and reinforces the conditions that permit evaluation
on
either side of the call.  The erratum published in the same file for RFI
000070
changes the semantics of dummy arguments.  The erratum does not explicitly
mention function results, but it might be considered to imply a similar
change
to the semantics of function results.

The erratum provided for RFI 000070 refers to altered text for the
interpretation provided for RFI 000049.  The version of the interpretation
that
appears in the file on the X3J3 website does not contain the altered text.

The definition of characteristics of function results as stated in Section
12.2.2 of the Fortran 95 standard permits more efficient implementation of
array-valued functions, at least for some architectures, than the definition
implied by the erratum provided for RFI 000070.  For Sun, it is more
efficient
for the calling routines to allocate space for array results than to have
the
called routines allocate the space.  In order for the calling routine to
allocate space for an array result, it must know the size of the array.  To
determine the size of the array, it must evaluate the array bounds
expressions
given in the explicit interface for the function.

Section 12.2.2 of the Fortran 95 standard requires the values of the
nonconstant bounds expressions given in an explicit interface to be the same
as
the values of the bounds expressions given in the corresponding function
definition.  Thus, the values of the nonconstant bounds expressions used to
determine the size of the array result can be passed to the called routine,
avoiding any need for the called routine to re-evaluate those expressions.
Because Fortran 95 allows user-defined routines to appear in bounds
expressions, evaluating the bounds expressions more than once per call could
prove inefficient and confusing.

The change implied by the erratum provided for RFI 000070 would remove the
nonconstant bounds expressions from the characteristics of function results.
The shape would still be a characteristic, but the same shape can be
produced
by many different values of the bounds expressions.  Thus, the values of the
nonconstant bounds expressions used in the called routine may differ from
the
values of the corresponding expressions in the explicit interface.

For example, consider the explicit interface

      INTERFACE
        FUNCTION FOO(F, G, H)
          INTERFACE
            PURE INTEGER FUNCTION F()
            END FUNCTION
            PURE INTEGER FUNCTION G()
            END FUNCTION
            PURE INTEGER FUNCTION H()
            END FUNCTION
          END INTERFACE
          CHARACTER*(F()) FOO(G():H())
        END FUNCTION
      END INTERFACE

The definition given in Section 12.2.2 of the Fortran 95 standard requires
the
values of the length and bounds expressions in the interface to be the same
as
the values of the corresponding length and bounds expressions in the
function
definition.

Under the definition implied by the erratum provided for RFI 000070, the
shapes
must match, but the values of the nonconstant bounds expressions need not.
Thus, the function definition might be

      FUNCTION FOO(F, G, H)
        INTERFACE
          PURE INTEGER FUNCTION F()
          END FUNCTION
          PURE INTEGER FUNCTION G()
          END FUNCTION
          PURE INTEGER FUNCTION H()
          END FUNCTION
        END INTERFACE
        CHARACTER*(F()) FOO(G()-1:H()-1)
        . . .
      END FUNCTION

In this case, the values of the bounds expressions used in the called
routine
must be the values of the expressions specified in the function definition,
not
the values of the expressions specified in the interface block.

QUESTION:

If a bound of a function result array is not a constant expression, is the
exact dependence on the entities in the expression a characteristic of the
function result?

ANSWER:

EDITS:

REFERENCES: 95-006a, F90/000027, F90/000049 & F90/000070
SUBMITTED BY:  Robert Paul Corbett
HISTORY:  J3/98-114 submitted

----------------------------------------------------------------------

NUMBER: 000018
TITLE: ELEMENTAL procedures with no arguments
KEYWORDS: Elemental, procedure
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

Section 12.7.2 of IS 1539-1:1997 seems to assume there is at least one
argument to an elemental procedure.  The semantics of the following
examples do not seem to be clearly specified.

Example 1:
      ELEMENTAL INTEGER FUNCTION f()
        f = 0
      END

Example 2:
      ELEMENTAL INTEGER FUNCTION g(i,j)
        INTEGER,INTENT(IN) :: i,j
        g = i + j
      END

Example 3:
      ELEMENTAL INTEGER FUNCTION h2(i)
        INTEGER,INTENT(IN),OPTIONAL :: i
        h = i
      END

Example 4:
      ELEMENTAL SUBROUTINE s()
        REAL x,y,z
        x = 0
        y = 0
        z = x/y
      END

QUESTION 1:
What is the shape of a reference to function F in example 1?  Is it
scalar?

QUESTION 2:
If G() is referenced as G(iscalar,jarray(1:0)), the result is a
zero-sized array.  Is "iscalar" referenced (need it be defined)? Is
the body of G() executed?

QUESTION 3:
What is the shape of a reference to H2() if the argument is textually
not present?

QUESTION 4:
When subroutine S is invoked, how many times is it executed?
Is this example standard-conforming, or may a processor raise a
divide-by-zero exception?

ANSWER:

(1) Yes, A reference to F() is intended to be scalar.
    A clarifying edit is supplied.

(2) It is not possible to tell, in Fortran 95, whether the body of
    G() is executed, so that part of the question has no answer.
    [no edit required]
    Yes, ISCALAR must be defined; this is the same situation as
    writing
      ISCALAR + JARRAY(1:0)
    directly, with no user-defined ELEMENTAL procedure being used.
    [no edit required]

(3) If the I argument to H2 is textually absent, a reference to H2
    returns a scalar result (cf. answer to question 1).  Note that
    execution of this procedure is not standard-conforming if the
    optional argument is not present.  The "H = I" line should be
    replaced by
      IF (PRESENT(I)) THEN
        H = I
      ELSE
        H = 0 ! or some other desired scalar value
      END IF
    [no edit required]

(4) The intention was that the subroutine is executed once per
    invocation. This is not clear from the standard; an edit is
    supplied to correct this oversight.  However, the example is not
    standard-conforming on a processor whose arithmetic does not
    allow division by zero.
    [no edit required]

EDITS:

[206:10+] Insert
          "A reference to an elemental subroutine is not an elemental
           reference if the subroutine has no arguments present."
{Specify zero-argument elemental subroutine reference.}

[214:28] After "If" insert "there are no actual arguments or".
{Clarify zero-argument elemental function reference.}

SUBMITTED BY: Malcolm Cohen

HISTORY: 98-117   m144 Submitted
         00-123   m152 Revised by submitter (version above) but
                       withdrawn for further study without vote
         01-148r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000019
TITLE: Result of NULL intrinsic associated with CHARACTER(*) dummy
       argument
KEYWORDS: NULL intrinsic, assumed character length parameter,
          argument association, pointer association
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION: Consider the following program.

      PROGRAM P
        CALL SUB(NULL())
      CONTAINS
        SUBROUTINE SUB(C)
          CHARACTER(*), POINTER :: C

          PRINT *, LEN(C)
        END SUBROUTINE SUB
      END PROGRAM P

According to 7.1.4.1 [91:27-30], "The data type, type parameters and
rank of the result of the intrinsic function NULL when it appears
without an argument are determined by the pointer that becomes
associated with the result.  See Table 7.2."  In this case, the
pointer that becomes associated with the result is the corresponding
dummy argument when the result appears as an actual argument.

However, according to 5.1.1.5 [51:14-18], a dummy argument of type
character, with a character length parameter of *, "assumes the
length of the associated actual argument when the procedure is
invoked."

Is this a standard conforming program?  If so, how is the length of C
determined, and what should be the output of this program?

ANSWER:

No, this program does not conform to the standard since the actual
argument does not have a character length for the dummy argument to
assume. The edit makes this clear.

EDIT:

Page 91, subclause 7.1.4.1, last line [91:41]. Add
    The optional argument shall also be present if the reference
    appears as an actual argument corresponding to a dummy argument
    with assumed character length.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-148   m145 Submitted
         01-154r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000020
TITLE: Execution of a WHERE statement within a WHERE construct
KEYWORDS: WHERE statement, WHERE construct
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:  7.5.3.2 [113:17-19] indicates that:

   Upon execution of a WHERE statement or a WHERE construct statement
   that is part of a <where-body-construct>, the pending control mask
   is established to have the value m .AND.(.NOT. mask-expr).
                                     c

[112:41-45] indicates that:

   Upon execution of an ENDWHERE statement, the control mask and
   pending control mask are established to have the values they had
   prior to the execution of the corresponding WHERE construct
   statement.  Following the execution of a WHERE statement that
   appears as a <where-body-construct>, the control mask is
   established to have the value it had prior to the execution of the
   WHERE statement.

Notice that after execution of an ENDWHERE statement, the pending
control mask is established to have the value it had prior to the
execution of the corresponding WHERE construct statement, but the
same is not the case for the pending control mask established by the
execution of a WHERE statement that appears as a
<where-body-construct>.

According to this, the output of the following program

      PROGRAM P
        INTEGER :: A(2) = 0, B(2) = 0

        WHERE((/.TRUE.,.TRUE./))
          WHERE((/.TRUE.,.FALSE./)) A = 1
        ELSEWHERE
          A = 2
        END WHERE
        PRINT *, A

        WHERE((/.TRUE.,.TRUE./))
          WHERE((/.TRUE.,.FALSE./))
            B = 1
          END WHERE
        ELSEWHERE
          B = 2
        END WHERE
        PRINT *, B
      END PROGRAM P

will be

 1 2
 1 0

Was this difference in behaviour intended by the committee?

ANSWER:

No. It was intended that
     WHERE(<mask-expr>) <where-assignment-stmt>
should have the same interpretation as
     WHERE(<mask-expr>)
         <where-assignment-stmt>
     END WHERE
The output from the above program should be
 1 0
 1 0

An edit is supplied to correct the text.

EDIT:

Page 113, subclause 7.5.3.2. In the first line of the paragraph
following NOTE 7.48 [113:17] delete 'a WHERE statement or'; after
the paragraph [113:20+] add the new paragraph:
  Upon execution of a WHERE statement that is part of a
  where-body-construct, the control mask is established to have the
  value <m_c>.AND.<mask-expr>. The pending mask is not altered.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-149   m145 Submitted
         01-155   m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000021
TITLE: Restrictions on <generic-spec> on END INTERFACE
KEYWORDS: INTERFACE block, END INTERFACE, generic procedures
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION: According to section 12.3.2.1 [194:18-20]

    The <generic-spec> may be included in the <end-interface-stmt>
    only if it was provided in the <interface-stmt> and, if
    included, shall be identical to the <generic-spec> in the
    <interface-stmt>.

It is not clear what the words "shall be identical" were intended to
mean. In particular, were they intended to merely convey the idea
that the two <generic-spec>s shall specify the same entity, even
though such an entity might be represented in more than one way, or
were they intended to convey something more restrictive?  Are either
of the following examples standard conforming programs?

Example 1:

      PROGRAM P
        INTERFACE OPERATOR(.NE.)
          LOGICAL FUNCTION F(I, C)
            INTEGER, INTENT(IN) :: I
            CHARACTER(*), INTENT(IN) :: C
          END FUNCTION F
        END INTERFACE OPERATOR(/=)
      END PROGRAM P

Example 2:

      MODULE MOD
        INTERFACE GEN
          SUBROUTINE SUB1(I)
            INTEGER :: I
          END SUBROUTINE SUB1
        END INTERFACE
      END MODULE MOD

      PROGRAM P
        USE MOD, G1=>GEN, G2=>GEN
        INTERFACE G1
          SUBROUTINE SUB2(L)
            LOGICAL :: L
          END SUBROUTINE SUB2
        END INTERFACE G2
      END PROGRAM P

ANSWER:

The intention is that the <generic-spec> in the END INTERFACE
statement should be obviously the same as that in the INTERFACE
statement, both to the human reader and to the compiler.  The words
"shall be identical" signify that they must be lexically identical,
that is, identical apart from layout changes permitted by the source
form and the interpretation of the operators .LT., .LE.,.GT., .GE.,
.EQ., and .NE. as always being identical to <, <=, >, >=, ==, and /=.

Example 1 conforms to the standard, but example 2 does not.

Edits are provided to make this clear.

EDITS:
On page 194, subclause 12.3.2.1, in the fourth constraint following
R1207 [194:19-20] delete 'and, if included, ... <interface-stmt>' and
add:
   If the <end-interface-stmt> includes <generic-name>, the
   <interface-stmt> shall specify the same <generic-name>.  If the
   <end-interface-stmt> includes ASSIGNMENT(=), the <interface-stmt>
   shall specify ASSIGNMENT(=).  If the <end-interface-stmt> includes
   OPERATOR(<defined-operator>), the <interface-stmt> shall specify
   the same <defined-operator>.  If one <defined-operator> is .LT.,
   .LE., .GT., .GE., .EQ., or .NE., the other is permitted to be the
   corresponding operator <, <=, >, >=, ==, or /=.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-150   m145 Submitted
         01-156   m156 1st answer passed unanimously at J3 meeting

----------------------------------------------------------------------

NUMBER: 000022
TITLE: Use of NULL() as initialization
KEYWORDS: NULL intrinsic, initialization, default initialization,
          DATA statement
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Rules R429, R505 and R540 respectively describe the syntax for
default initialization of pointer components, pointer objects in type
declaration statements and pointer objects in DATA statements.  These
rules seem to indicate that NULL is to be considered a keyword in
those contexts. This has the surprising effect that the first example
below is a standard conforming program, while the second is not.
That is, in some contexts, something that looks very much like a
reference to an intrinsic function, is in fact a keyword followed by
parentheses.

Example 1:

      MODULE MOD
        INTRINSIC NULL
      END MODULE MOD

      PROGRAM PROG
        USE MOD, DISASSOCIATE=>NULL
        INTEGER, PARAMETER :: NULL = 17
        INTEGER :: J = NULL

        INTEGER :: I
        INTEGER, POINTER :: P => NULL(), P2
        DATA P2, I/NULL(), NULL/
        TYPE DT
          INTEGER, POINTER :: P => NULL()
        END TYPE DT
        TYPE DT2
          INTEGER, POINTER :: I
          INTEGER :: J
        END TYPE DT2
        TYPE(DT2) :: S = DT2(DISASSOCIATE(), NULL), S2
        DATA S2/DT2(DISASSOCIATE(), NULL)/
      END PROGRAM PROG

Example 2:

      MODULE MOD
        INTRINSIC NULL
      END MODULE MOD

      PROGRAM PROG
        USE MOD, DISASSOCIATE=>NULL

        INTEGER, POINTER :: P => DISASSOCIATE(), P2
        DATA P2/DISASSOCIATE()/
        TYPE DT
          INTEGER, POINTER :: P => DISASSOCIATE()
        END TYPE DT
      END PROGRAM PROG

In some places in the scoping unit of PROG example 1, NULL() is used
to specify initialization or default initialization, while in others
NULL is a named constant, and DISASSOCIATE() must be used to specify
initialization.

1) Is example 1 a standard conforming program?

2) Is example 2 a standard conforming program?

3) Was it the intent of the committee that, within the contexts of
   R429, R505 and R540, NULL should be treated strictly as a keyword
   rather than as a reference to an intrinsic function?

DISCUSSION:

The intention is that the intrinsic function NULL be referenced with
no arguments in initialization contexts. This is made clear in the
middle of page 49 in the paragraph that begins 'If <initialization>'
[49:20-21] and also in 7.1.4.1. If the intrinsic function has been
renamed, the new name should be used.

ANSWER:

(1) No, the example is not conforming because it references two
    different entities with the same name (NULL the local variable,
    and NULL the intrinsic function).  See 14.1.2.

(2) No, the example does not conform to the standard as published.
    This is an error, corrected by the supplied edits which make this
    example conforming.

(3) No, the intention was that "NULL()" should be a reference to the
    intrinsic function.  Edits are supplied to remove the keyword
    status of this syntax.

EDITS:

Page 39, subclause 4.4.1, replace the second line of R429 [39:20] by
                     <<or>> => <pointer-initialization-expr>
          R429a  <pointer-initialization-expr> <<is>>
                 <function-reference>
          Constraint: <function-reference> shall be a reference to the
                 intrinsic function NULL with no arguments.

Page 47, subclause 5.1, replace the second line of R505 [47:40] by
                     <<or>> => <pointer-initialization-expr>

Page 49, subclause 5.1, in the paragraph that begins 'If
     <initialization>' [49:20-21], replace 'NULL()' by
     '<pointer-initialization-expr>' twice.

Page 62, subclause 5.2.10, replace the fifth line of R540 [62:19] by
                     <<or>> <pointer-initialization-expr>

Page 62, subclause 5.2.10, in the penultimate line of the page
     [62:48], replace 'NULL()' by 'pointer association status'.

Page 63, subclause 5.2.10, in lines 1, 7 and 10 of the page
     [63:1,7,10], replace  'NULL()' by
     '<pointer-initialization-expr>' thrice.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-151   m145 Submitted
         01-157   m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000023
TITLE: Termination of the previous record by a WRITE statement
KEYWORDS: Nonadvancing, Record termination, WRITE
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Suppose a sequential formatted file is positioned within a record as
a result of a nonadvancing READ.

1. If the next operation performed on the file is a WRITE, can the
   current record be terminated at its current position before the
   next record is written?  Section 9.2.1.3.2 appears to preclude the
   record from being terminated, but at least one Fortran 90
   implementation does the record in such an instance.

2. If next operation is a nonadvancing WRITE and the number of
   characters written does not extend to the end of the current
   record, are the remaining characters at the end of the record
   preserved?

ANSWER:

1. No.  If the current record were to be terminated, the file
   position would be changed.  Section 9.2.1.3.2 [136:37-39] states:
   "For sequential access on input, if there is a current record, the
   file position is not changed.  Otherwise, the file is positioned
   at the beginning of the next record and this record becomes the
   current record."

2. No, the remaining characters in the record are not preserved.  The
   characters are inaccessible.   An edit to section 9.2.1.3.2 to
   clarify the situation is given below.

EDIT:

[136:44] Change "record becomes" to "record, excluding any data
         beyond the current point, becomes"

SUBMITTED BY: Robert Corbett

HISTORY:  98-155   m145 Submitted (part 1)
          WG5/N1410     Draft answer
          01-151r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000024
TITLE: Termination of a partial record by a CLOSE, BACKSPACE,
       ENDFILE, or REWIND statement
KEYWORDS: Record termination, CLOSE, BACKSPACE, ENDFILE, REWIND
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Suppose a partial record has been written as a result of a
nonadvancing WRITE. If the file is closed, or a BACKSPACE, ENDFILE,
or REWIND statement is performed on the file, must the partial record
be terminated?

ANSWER:

After a nonadvancing WRITE there is always a current record in a
file. Existing descriptions of file closure and of the BACKSPACE,
ENDFILE and REWIND statements define subsequent operations on the
file. Further clarification in the BACKSPACE, ENDFILE and REWIND
cases is provided in C.6.1.5 [321:7-11].

An edit is provided to make the intention clear.

EDIT:

Page 136. At the end of the last paragraph of subclause 9.2.1.3.1
[136:33] add
   If a nonadvancing output statement leaves a file positioned within
   the current record and no further output statement is executed
   for the file before it is closed or a BACKSPACE, ENDFILE, or REWIND
   statement is executed for it, the effect is as if the output
   statement were the corresponding advancing output statement.

SUBMITTED BY: Robert Corbett

HISTORY: 98-155      m145   Submitted (part 2)
         WG5/N1410          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot
         01-158r1    m156   Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000025
TITLE: List-directed input: types of variables corresponding to
       repeated values
KEYWORDS: List-directed input, repeated values
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

When a repeat count is used in list-directed input, must all the
variables into which the repeated value is read have the same type?
I see no reason in the standard to assume that restriction, but at
least one Fortran 90 implementation assumes it.

ANSWER:

No, the variables are not required to be of the same type, but the
type of the repeated constant is either a literal constant, or a
nondelimited character constant, but not both (10.8, "where <c> is a
literal constant or a nondelimited character constant").  Whether
certain forms of a repeated constant are treated as a literal
constant or a nondelimited character constant is determined by the
type of the first variable which consumes this value.  Indeed, how
many characters from the input record are part of <c> is dependent on
the type of the first variable which consumes a value from that
<r*c>.

For example, the input
   2*(1.0, 0.0)
conforms to the standard when consumed by three list items of type
character or by two list items of type complex.  If there are three
character variables, the first two get the value "(1.0", while the
third gets the value "0.0)".  If there are two complex variables,
they both are assigned the value (1.0,0.0).

Similarly, the input
   2*.TRUE.
can be consumed by two logical variables, or two character variables,
but not by one character and one logical variable.

An edit is provided to clarify the situation.

EDIT:

In section 10.8.1,  add the following as a new paragraph, just before
Note 10.26 [175:33+].
  "For the <r*c> form of an input value, the constant <c> is
   interpreted as a nondelimited character constant if the first list
   item corresponding to this value is of type default character,
   there is a nonblank character immediately after <r*>, and that
   character is not an apostrophe or a quotation mark; otherwise, <c>
   is interpreted as a literal constant."

SUBMITTED BY: Robert Corbett

HISTORY:  98-155   m145 Submitted (part 3)
          WG5/N1410     Draft answer
          01-159r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000026
TITLE: List-directed input: types of variables corresponding to repeated
values
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:

Consider the example

CHARACTER*80 STRING
COMPLEX Z

READ (*, *) Z, STRING

Support the input consists of

2*(1.0, 0.0)

After the READ, should Z contain (1.0,0.0) and should STRING contain
'(1.0,'?

ANSWER:
(If the first interpretation of r*c in 000025 is correct) No.  Z should
contain (1.0,0.0) but STRING should contain '(1.0'.  The form of the
value separator generated by the r*c form is not defined, but any
blanks which might notionally be inserted in the input record would be
part of the separator and could not be part of the nonlimited character
constant read into STRING (Note 10.28).  Hence the first character in
string is '('.  Section 10.8.1 [176:19-20] states: "If the delimiters
are omitted, the character sequence is terminated by the first blank,
comma, slash, or end of record".  Hence the last character in STRING is
'0'.

(If the second interpretation of r*c in 000025 is correct) No.  This is
a non- standard conforming statement.

SUBMITTED BY: Robert Corbett
HISTORY:  98-155   m145 Submitted (part 4)
          WG5/N1410     Draft answer

----------------------------------------------------------------------

NUMBER: 000027
TITLE: Sequential formatted I/O: position of the left tab
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:

When a file is positioned within a record at the start of sequential
formatted
I/O, where is the left tab limit (see Section 10.6.1.1)?  Is it at the start
of
the record or at the point where the file was positioned at the start of
execution of the statement?

ANSWER:

DISCUSSION:
EDIT:

SUBMITTED BY: Robert Corbett
HISTORY:  98-155   m145 Submitted (part 5)

----------------------------------------------------------------------

NUMBER: 000028
TITLE: Implicitly Typed Statement Function Character Dummy
KEYWORDS: statement function, constant expression, implicit typing
DEFECT TYPE: Clarification
STATUS: Passed by J3 meeting

QUESTION:

Is the following program-unit standard-conforming?

SUBROUTINE sub(n)
  IMPLICIT CHARACTER*(n) (c)
  stmtfn(ch) = LEN(ch)
END

A quick survey of 6 compilers showed no consensus on whether this was
legal, with 3 accepting it (as standard-conforming), 2 rejecting it,
and 1 crashing with an internal error.  The standard seems to say
(middle of section 5.1.1.5, [51:32-33]) that if you explicitly
specify the length then it must be a constant specification
expression, but does not appear to constrain implicit lengths.

ANSWER:
No, the example is not standard-conforming.

DISCUSSION:
The quoted section of the standard says:
  "The length specified for a ... statement function dummy argument
   of type character shall be a constant specification expression."
The first paragraph of 5.3 says
  "In a scoping unit, an IMPLICIT statement specifies a type, and
   possibly type parameters, for all implicitly typed data entities
   ..."

Therefore the requirement that the character length of a statement
function or statement function dummy argument be constant applies to
implicitly typed entities as well as explicitly typed entities.

EDIT:

None.

SUBMITTED BY: Malcolm Cohen

HISTORY: 98-164 m145 Submitted
         01-149 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000029
TITLE: Nested Derived Types and Defined Assignment
KEYWORDS: derived type, defined assignment
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

According to Fortran 90, intrinsic assignment of derived
type entities does not invoke defined assignment for components of
these entities, even if it exists.  Should this situation have been
corrected in Fortran 95 to avoid breaking encapsulation of derived
types?

That is, in the example program below, is the final assignment
statement intended to invoke the user-defined assignment routine for
the "name" components of "a" and "b", or should it do pointer
assignment on the (PRIVATE) "value" components of the "name"
components?

MODULE lib_varying_string
  TYPE varying_string
    PRIVATE
    CHARACTER,POINTER :: value(:)
  END TYPE
  INTERFACE ASSIGNMENT(=)
    MODULE PROCEDURE assign_vs_to_vs
  END INTERFACE
CONTAINS
  SUBROUTINE assign_vs_to_vs(var,expr)
    TYPE(varying_string),INTENT(OUT) :: var
    TYPE(varying_string),INTENT(IN) :: expr
    ALLOCATE(var%value(SIZE(expr%value,1)))
    var%value = expr%value
  END SUBROUTINE
END
PROGRAM programme
  USE lib_varying_string
  TYPE mytype
    TYPE(varying_string) name
  END TYPE
  TYPE(varying_string) x,y
  TYPE(mytype) a,b
  x = y               ! invokes "assign_vs_to_vs(x,(y))".
  a%name = b%name     ! invokes "assign_vs_to_vs(a%name,(b%name))"
  a = b               ! in F90, pointer assigns the "value" components
END

ANSWER:

No, there is no ambiguity or error in the standard.

DISCUSSION:

Intrinsic assignment is not intended to invoke user-written
procedures. This would introduce anomalies with initialization by
DATA statements.

Library writers cannot in any case depend on defined assignment to
enforce encapsulation automatically, because the user can
deliberately (or accidentally) omit to import the defined assignment
from the module. (Also, other facilities such as TRANSFER may break
encapsulation).

In the example given, a defined assignment should be provided for
TYPE(mytype) by the programmer.

EDITS:

None.

NOTE: This is MTE work item M16 for Fortran 2000.

SUBMITTED BY: Malcolm Cohen

HISTORY: 97-197  m142  Submitted
         97-197  m145  Passed unanimously as amended {see 98-167
                       minutes}
         Failed WG5 letter ballot.
         00-330  m155  Option 0 answer passed unanimously by J3
                       meeting

----------------------------------------------------------------------

NUMBER: 000030
TITLE: Ordering requirements on definition of specification functions
KEYWORDS: Specification expressions, specification functions
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION: Consider the following program unit.

      MODULE MOD
        INTERFACE INT
          MODULE PROCEDURE F1, F2
        END INTERFACE
      CONTAINS
        INTEGER PURE FUNCTION F1(I)
          INTEGER :: A(INT(1_4)), B(INT(1_2))    ! A(1), B(19)
          INTEGER, PARAMETER :: KIND = SIZE(A)   ! KIND == 1
          INTEGER(KIND), INTENT(IN) :: I

          F1 = 17
        END FUNCTION F1

        INTEGER PURE FUNCTION F2(J)
          INTEGER :: C(INT(2_4))                 ! C(2)
          INTEGER, PARAMETER :: KIND = SIZE(C)   ! KIND == 2
          INTEGER(KIND), INTENT(IN) :: J

          F2 = 19
        END FUNCTION F2
      END MODULE MOD

In processing the references to "INT(1_4)" and "INT(1_2)" in F1, the
processor needs to determine whether the references are to the
intrinsic function, INT, or to one of the specific procedures, F1 or F2.
Determining that requires the processor to have determined the kind
type parameter of the dummy argument J, of F2.  In turn, that requires
the processor to determine whether the reference to "INT(2_4)" is a
reference to the intrinsic function, INT, or to one of the specific
procedures, F1 or F2.  Determining that requires the processor to
determine the kind type parameter of the dummy argument I, which requires
it to determine that "INT(1_4)" in F1 was a reference to the intrinsic
function INT.

After all this is determined, the processor can determine that the
reference to "INT(1_2)" in the declaration of B in F1 is a reference to
the specification function F2.

According to 7.1.6.1 [94:38-41],

     "If an initialization expression includes a reference to an inquiry
      function for a type parameter or an array bound of an object
      specified in the same <specification-part>, the type parameter or
      array bound shall be specified in a prior specification of the
      <specification-part>.  The prior specification may be to the left of
      the inquiry function in the same statement."

According to 7.1.6.2 [96:27-37],

     "A variable in a specification expression shall have its type and
      type parameters, if any, specified by a previous declaration in
      the same scoping unit, or by the implicit typing rules in effect
      for the scoping unit, or by host or use association.  If a variable
      in a specification expression is typed by the implicit typing rules,
      its appearance in any subsequent type declaration statement shall
      confirm the implied type and type parameters.

      If a specification expression includes a reference to an inquiry
      function for a type parameter or an array bound of an entity
      specified in the same <specification-part>, the type parameter or
      array bound shall be specified in a prior specification of the
      <specification-part>.  The prior specification may be to the left
      of the inquiry function reference in the same statement.  If a
      specification expression includes a reference to the value of an
      element of an array specified in the same <specification-part>,
      the array shall be completely specified in prior declarations."

The rules regarding references to variables in a specification expressions
and initialization expressions require a strict left-to-right, top-to-bottom
ordering between specification and inquiry.  Specification functions appear
to be unrestricted in this respect.

Assuming that the processor supports integers with kind type parameters
of 1, 2 and 4, was it the intent of the committee that the program unit
above should be standard-conforming?

ANSWER:
EDIT:
SUBMITTED BY: Henry Zongaro
HISTORY: 98-176   m146 Submitted

----------------------------------------------------------------------

NUMBER: 000031
TITLE: Association of pointer function result with INTENT(OUT) dummy
       argument
KEYWORDS: Pointer association, dummy argument association, intent
          attribute
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:  Consider the following program.

      PROGRAM P
        INTEGER, TARGET :: T

        CALL SUB(FPTR())
      CONTAINS
        FUNCTION FPTR()
          INTEGER, POINTER :: FPTR

          FPTR => T
        END FUNCTION FPTR
        SUBROUTINE SUB(IO)
          INTEGER, INTENT(OUT) :: IO

          IO = 17
        END SUBROUTINE SUB
      END PROGRAM P

According to 12.4.1 [200:30-32],

    "If a dummy argument is not a pointer and the corresponding
     actual argument is a pointer, the actual argument shall be
     currently associated with a target and the dummy argument
     becomes argument associated with that target."

According to 12.4.1 [201:19-21],

    "If a dummy argument has INTENT(OUT) or INTENT(INOUT), the actual
     argument shall be definable."

According to 5.1.2.3 [53:29-31],

    "The INTENT(OUT) attribute specifies that. . . any actual
     argument that becomes associated with such a dummy argument
     shall be definable."

The definition of "definable" supplied in Annex A (the term does not
appear to be defined in normative text) is:

    "A variable is <<definable>> if its value may be changed by the
     appearance of its <name> or <designator> on the left of an
     <assignment statement>."

According to this definition, "definable" is a property of variables
only.  In the example above, the actual argument is not a variable.
However, the actual argument is pointer associated with an object
that is definable.  The text cited from 5.1.2.3 refers to the
"actual argument that becomes associated with the dummy argument",
but the first piece of text cited from 12.4.1 makes it clear that
when the actual argument is a pointer, it is the target with which
it is associated that becomes argument associated with the dummy
argument, and not the actual argument itself.

Was it the intent of the committee that this program should not be
standard-conforming?

ANSWER: The program does not conform to the Standard. 12.4.1.1
[201:19-21] requires the actual argument to be definable and a
function result is not definable. For example, it is not permitted
on the left-hand side of an assignment statement, since it is not a
variable.

EDIT: None.

SUBMITTED BY: Henry Zongaro
HISTORY: 98-177      m146   Submitted
         WG5/N1414          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000032
TITLE: Is the TRANSFER function result undefined?
KEYWORDS:  transfer function, undefined, processor dependent
DEFECT TYPE:
STATUS: Passed by WG5 ballot

The result value section of the TRANSFER function says

"...If the physical representation of the result is longer than that
of SOURCE, the physical representation of the leading part is that of
SOURCE
and the remainder is undefined."
    ^^^^^^^^^^^^^^^^^^^^^^^^^^

and case (ii) gives an example of a transfer of 3 reals to 2
complexes with the imaginary part of the second complex being
undefined.

Where can you use this form of TRANSFER?  There's a general
prohibition about referencing undefined things.  Doesn't that apply
to expressions containing TRANSFER as well?   Something like
     X = transfer (four_bytes,eight_bytes)
or   X = transfer(transfer(four_bytes,eight_bytes), four_bytes)
reference the undefined part.  Maybe in the latter case we could
say that the "reference" in the outer transfer doesn't "require the
value" of all of its argument.  But that seems like an odd reading
to me.

We can't use it for functions like SIZE, because they only allow
their argument to be undefined if it is a single variable name
(13.8.5).

The only thing I can think of is passing to a procedure argument that
has no INTENT specified but that uses the defined part of the
argument as if it were INTENT(IN).  The intent can't be specified
because INTENT(IN) arguments must be defined on entry.

Question:  Should the phrase be changed from "the remainder is
undefined" to "the remainder is processor dependent"?

DISCUSSSION:
This is made more confusing by:
  "Any variable or function reference used as an operand shall be
   defined at the time the reference is executed." [97:1]
The mention of function reference is confusing, because a function
is not allowed to return without fully defining its result, viz
  "If the result variable is not a pointer, its value shall be
   defined by the function." [207:28]

ANSWER: Yes, for the reasons given. Edits are provided.

EDITS: Clause 13.14.110

   Page 272, line 4. Change 'undefined' to 'processor dependent'.

   Page 272, line 17. Change 'undefined' to 'processor dependent'.

SUBMITTED BY:  Dick Hendrickson

HISTORY: 98-183             Submitted
         WG5/N1414          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Passed by J3 letter ballot, as amended
         WG5/N1428          Passed by WG5 ballot

----------------------------------------------------------------------

NUMBER: 000066
TITLE: Errors in processing data transfer statements
KEYWORDS: ERR=; IOSTAT=; Data transfer statements
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

Consider the following program.

      INTEGER :: A(10), IDX, J
      OPEN(10, FORM='UNFORMATTED', ACCESS='SEQUENTIAL', STATUS='OLD',
     &         ACTION='READ')
      READ(10, IOSTAT=IOS) IDX, J, A(IDX)
      END

If an error occurs while processing the variable J in the data
transfer statement, does this program become non-standard conforming?

According to 9.4.3:

    "If an error condition or an end-of-file condition occurs during
     execution of an input/output statement, execution of the
     input/output statement terminates and if the input/output
     statement contains any implied-DOs, all of the implied-DO
     variables in the statement become undefined.  If an error
     condition occurs during execution of an input/output statement,
     the position of the file becomes indeterminate.

     If an error or end-of-file condition occurs on input, all input
     list items become undefined."

According to 9.4.4:

     "The effect of executing a data transfer input/output statement
      shall be as if the following operations were performed in the
      order specified:

      (1) Determine the direction of data transfer
      (2) Identify the unit
      (3) Establish the format if one is specified
      (4) Position the file prior to data transfer (9.2.1.3.2)
      (5) Transfer data between the file and the entities specified
          by the input/output list (if any) or namelist
      (6) Determine whether an error condition, an end-of-file
          condition, or an end-of-record condition has occurred
      (7) Position the file after data transfer (9.2.1.3.3)
      (8) Cause any variables specified in the IOSTAT= and SIZE=
          specifiers to become defined."

A simple reading of this seems to indicate that the point at which
the error occurs and is detected by a standard-conforming processor
is unspecified. Because IDX becomes undefined, the reference to IDX
in the variable A(IDX) is incorrect.  However, this is a very common
style of coding I/O operations in Fortran.

QUESTION 1:
Was it the committee's intent that such a program should not be
standard-conforming in the presence of an error condition?

QUESTION 2:
Does the fact that the error occurred before the item A(IDX) was
processed mean that there was no reference to IDX, and hence, that
the program is standard-conforming?

ANSWER 1: No.

ANSWER 2: Yes.

DISCUSSION:  The referenced paragraph (9.4.4) is misleading.  The
entire I/O list is not necessarily expected to be processed in the
presence of an error.

EDIT:
Section 9.4.4, list item 6  [150:33], delete "an error condition,",
and change ", or" to "or"

Section 9.4.4, add the following after list item (8):
 "If an error condition occurs during any of the above operations,
execution of the data transfer statement terminates, any variable
specified in an IOSTAT= specifier becomes defined, and the error
condition is processed as described in 9.4.3."

SUBMITTED BY:  Henry Zongaro

HISTORY:  99-177  m150  submitted
          99-212  m150  approved uc
          00-May        failed J3 letter ballot
          00-213  m153  passed unanimously
          00-254  m154  Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000067
TITLE: Writing zeros
KEYWORDS:  list-directed output, namelist output
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

The standard currently requires a real zero to be
written in exponential form when using list-directed
or namelist output.

QUESTION: Is this requirement intentional or an oversight?

ANSWER: The requirement is an oversight.

DISCUSSION:
The G edit descriptor was changed in Fortran 90 to format a real zero
as if an F edit descriptor were provided in most cases.  The same
change was not made for list-directed or namelist output, but should
have.

REFERENCES:  ISO/IEC 1539-1:1997(E),
             Sections 10.5.4.1.2, 10.8.2, and 10.9.2.1

EDITS:
[3:32+]   In section 1.5.1, add the following as list item (3):
    (3) List directed and namelist output statements produce a real
        constant zero for a real value that is zero, and for the real
        or imaginary part of a complex value that is zero.
        In Fortran 95, these real constants are produced with the
        effect of an F edit descriptor, instead of an E edit
        descriptor.

[4:24+]   In section 1.5.2, add the following as list item (7):
    (7) List directed and namelist output statements produce a real
        constant zero for a real value that is zero, and for the real
        or imaginary part of a complex value that is zero.  In
        Fortran 95, these real constants are produced with the effect
        of an F edit descriptor, instead of an E edit descriptor.

[177:41]  In section 10.8.2 (List-directed output), fifth paragraph,
    change "If the magnitude x is within this
    range" to "If the magnitude x is within this range or is zero"

[182:33]  In section 10.9.2.1 (Namelist output editing), third
    paragraph, change "If the magnitude x is within
    this range" to "If the magnitude x is within this range or is
    zero"

SUBMITTED BY:  Robert Corbett
HISTORY:  99-193    m150 Submitted
          99-213r1  m150 approved uc
          00-210    m153 Passed by J3 letter ballot
          00-268    m154 Failed WG5 letter ballot (N1395 & N1403)

----------------------------------------------------------------------

NUMBER: 000068
TITLE: Asterisks as I/O units
KEYWORDS: Asterisk, I/O, unit
DEFECT TYPE:   Erratum
STATUS: J3 consideration in progress

Question:

1.   Does the Fortran 95 standard require the external unit
     corresponding to the I/O unit identified by an asterisk for
     input or output to be the same as the external unit identified
     by some fixed nonnegative integer value?

2.   Can the I/O unit identified by an asterisk for input or output
     correspond to more than one external unit?

3.   If the external unit identified by an integer value that
     corresponds to the I/O unit identified by an asterisk for input
     or output is closed, does that cause the I/O unit identified by
     an asterisk to become disconnected?

Answer:

     1.   No.

     2.   No.

     3.   Yes.

Discussion:

The submitter states:  At least one Fortran 95 implementation uses -1
as the value of the I/O unit identified by an asterisk.  A carefully
constructed INQUIRE statement can expose this value to the user.  Many
users expect I/O to the units identified by asterisks to continue to
work even after the corresponding units identified by integer values
have been closed.

     1.   There is no requirement in the standard that the asterisk
correspond to an external-file-unit.

     2.   For the units identified by the asterisk, the text of
section 9.3.2 does not allow two or more units to be connected
simultaneously to the same external device or file [139:8-9].  An
edit is supplied to clarify this situation.

     3.   There might not be an external-file-unit that corresponds
to the io-unit specified by an asterisk, as clarified by the edit
below.  If there is, it is permissible to execute a CLOSE statement
on them as on any other unit.

REFERENCES:  ISO/IEC 1539-1:1997(E), Sections 9.3 and 9.4.4.2

EDITS:
  Add the following text to the end of the last paragraph before
section 9.3.1 [138:34+]:
     "An asterisk used in an input statement may identify the same
      <io-unit> as a particular <external-file-unit>.  An asterisk
      used in an output statement may identify the same <io-unit> as
      another particular <external-file-unit>."

SUBMITTED BY:  Robert Corbett
HISTORY:  99-192    m150 Submitted
          99-215r1  m150 approved uc
          00-208    m153 passed by J3 letter ballot
          00-268    m154 Failed WG5 letter ballot (N1395 & N1403)

----------------------------------------------------------------------

NUMBER: 000071
TITLE: Character array constructors
KEYWORDS: Character, array constructor, zero-size
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION:
The f95 standard appears to leave the length of zero-sized character
array constructors undefined.  The penultimate paragraph of clause
4.5 says

  "The type and parameters of an array constructor are those of the
   <ac-value> expressions."

If there are no elements, then the values of the type parameters
might not be defined.  The type and kind are always well defined at
compile time.  However, the length parameter for zero-sized character
array constructors is not obviously well-defined, even at run-time.

Zero-sized constructors are certainly allowed, as mentioned in the
antipenultimate paragraph of clause 4.5:

  "An empty sequence forms a zero-sized rank-one array."

Experimentation with different f90 compilers yields varying results.

QUESTION 1:
Is the following a valid program and, if so, what len value does it
print?

  program zero
    write (*,*) len( (/ ('abc', i = 1 , 0) /) )
  end

QUESTION 2:
Is the following a valid program and, if so, what value does it print?

    program zero_size
      integer :: n = 0
      call sub('abcdefghij', n)
    contains
      subroutine sub(string, n)
        character*(*) :: string
        integer :: n
        integer :: i
        write (*,*) len( (/ (string(:i+2), i = 1 , n) /) )
      end subroutine
    end program zero_size

QUESTION 3:
Is the following a valid program and, if so, what values does it print
for the lengths and for n_calls?

    program zero_size
      integer :: n = 0
      integer :: n_calls = 0
      call sub('abcdefghij', n)
      write (*,*) 'n_calls = ', n_calls
    contains
      subroutine sub(string, n)
        character*(*) :: string
        integer :: n
        integer :: i
        write (*,*) len( (/ (string(:f(i)), i = 1 , n), 'abcde' /) )
      end subroutine sub
      integer function f(i)
        f = 2*i + 5
        n_calls = n_calls + 1
      end function f
    end program zero_size

ANSWER:
(1) Yes.  The length is 3.
    Clause 4.5 says that
       "The type and type parameters of an array constructor are
        those of the <ac-value> expressions."
    There is no exclusion for <ac-value>s that contribute no elements
    to the value of the array constructor: thus <ac-value>s that are
    inside zero-trip implied DO loops still contribute their "type"
    information.

    The example array constructor has an <ac-value> that is the
    character literal 'abc'; this clearly has the character length of
    3 and therefore the array constructor has a character length of
    3.

    The description of how an <ac-value> that is an implied DO is
    handled confuses syntax and semantics: an edit is supplied to
    clarify this.

(2) No.  The edits below clarify this situation.

(3) Yes.  The length printed is 5, n_calls is still zero.
    Clause 4.5 says that
       "If the <ac-value> expressions are of type character, each
        <ac-value> expression in the <array-constructor> shall have
        the same character length parameter."

    The example array constructor has an <ac-value> that is the
    character literal 'abcde'; this clearly has the character length
    of 5 and therefore the array constructor has a character length
    of 5.

    No references to the function F are executed because these appear
    within a zero-trip implied DO loop.

EDITS:

In clause 4.5, in the paragraph beginning
   "If an <ac-value> is a scalar expression"
[46:1] replace:
   "an <ac-value> sequence"
with
   "a sequence of elements".

In clause 4.5, at the end of the paragraph which begins "If the
<ac-value> expressions are of type character" [45:38+], insert:

  "A zero-sized character array constructor shall have at least one
   <ac-value> that is an initialization expression, a <variable> that
   does not contain a <substring-range>, or a <variable> containing a
   <substring-range> in which all expressions are initialization
   expressions."

SUBMITTED BY: Richard Maine
HISTORY:  98-101   m144 submitted 20 Nov 1997
          99-207   m150 additional input
          99-217r3 m150 approved uc
          00-209   m153 passed by J3 letter ballot
                   m153 duplicated in interp 000071;  processing 000016
                        complete
          00-268   m154 Failed WG5 letter ballot (N1395 & N1403)

----------------------------------------------------------------------

NUMBER: 000073
TITLE: Is padding allowed in storage sequences?
KEYWORDS: alignment, padding, storage sequence
DEFECT TYPE:
STATUS: Passed by WG5 ballot

QUESTION:

1.  Is padding allowed in storage sequences?

Consider the common block

      CHARACTER C
      INTEGER I
      COMMON /CBLK/ C, I

2.  Is padding allowed between the variables C and I?

Consider the sequence type

      TYPE T
        SEQUENCE
        CHARACTER C
        INTEGER I
      END TYPE

3.  Is padding allowed between component C and component I?

Discussion:

A user recently complained that Sun f90 adds pad for alignment to
sequence types and common blocks.  He asserted that the Fortran
standard forbids padding storage sequences.

I have tested seven different implementations, and I found that all
but one use padding in the examples given.

The user based his assertion on the text of Section 14.6.3.1 of the
Fortran 95 standard.  He claimed the statements

   (7) A nonpointer scalar object of sequence type occupies a
       sequence of storage sequences corresponding to the sequence
       of its ultimate components

and

   The order of the storage units in such a composite storage
   sequence is that of the individual storage units in each of the
   constituent storage sequences taken in succession, ignoring any
   zero-sized constituent sequences.

made his case.  I pointed out that where the standard intends to
require storage units to be contiguous, it uses the word
"contiguous".  He was not satisfied by that answer.

The user pointed out that the definition of the size of a storage
sequence supports his assertion.  He claimed that the size of the
common block given above is one character storage unit plus one
numeric storage unit, and that that is the size of the common block

      INTEGER J
      CHARACTER D
      COMMON /CBLK/ J,D

which Sun f90 does not pad.  While that arithmetic of sizes makes
sense, I have been told informally by a committee member that that
was not the intent of the committee.  Note 5.33 lends support to his
statement.

I have been unable to find any for the first paragraph of Note 5.33
in the normative part of the standard.

I suggest moving the first paragraph of Note 5.33 to the normative
part of the standard.  I tried to provide a definition of addition
of sizes of different storage units that would imply the effect
stated in Note 5.33, but I failed.

ANSWER:

1.  Yes.
Padding between storage units is allowed unless those storage units
are explicitly required to be contiguous in Section 14.6.3.1 or they
are required to be contiguous in order to satisfy the storage
association rules given in Sections 14.6.3.2 and 14.6.3.3.

Note 5.33 (page 70) states: 'A common block is permitted to contain
sequences of different storage units'. This is a consequence of the
absence of any requirement on the types of the variables in a common
block. It further states 'provided each scoping unit that accesses
the common block specifies an identical sequence of storage units
for the common block'. This is an informal rewording of the rules on
common association which are found in sections 5.5.2.1 and 5.5.2.3,
and the rules on storage association which are in 14.6.3.

5.5.2.1 and 5.5.2.3 do not prohibit padding between sequences of
storage units, but any such padding is required to be consistent
between scoping units.

2.  Yes.

3.  Yes.

REFERENCES: ISO/IEC 1539-1:1997(E), Note 5.33 and Section 14.6.3.

EDITS: None.

SUBMITTED BY:  Robert Corbett
HISTORY: 99-190      m150   submitted (straw vote to allow padding
                                      11-0-0)
         WG5/N1414          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Passed by J3 letter ballot, as amended
         WG5/N1428          Passed by WG5 ballot

----------------------------------------------------------------------

NUMBER: 000074
TITLE: TARGET dummy arguments and POINTER expressions
KEYWORDS: TARGET, POINTER, dummy arguments
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:

Consider the following program.

PROGRAM questionable
  REAL,TARGET :: x
  CALL s1(f(x))
  CALL s2(f(x))
  CALL s3(f(x))
CONTAINS
  FUNCTION f(a)
    REAL,POINTER :: f
    REAL,TARGET :: a
    f => a
  END FUNCTION
  SUBROUTINE s1(variable)
    variable = 42                  ! statement 1
  END SUBROUTINE
  SUBROUTINE s2(variable)
    INTENT(OUT) variable
    variable = 42                  ! statement 2
  END SUBROUTINE
  SUBROUTINE s3(targ)
    REAL,TARGET :: targ
    REAL,POINTER :: p
    p => targ
    PRINT *,ASSOCIATED(p,x)        ! statement 3
  END SUBROUTINE
END

Is this program standard-conforming, and if so, what value is
printed?

The real question is whether an expression argument that is a pointer
function reference is treated as a variable (data-object) argument
with the variable being the target of the pointer expression.  (Or
whether it is dereferenced as usual in the absence of POINTER dummy
arguments).

Re (statement 1), the question is whether VARIABLE is definable when
argument-associated with "F()".

Re (statement 2), if the previous answer was Yes (VARIABLE is
definable), then presumably it can be made INTENT(OUT).  A random
sample of 4 compilers revealed that they considered it not to be
definable.

Re (statement 3), the question is whether P is pointer-associated
with X, not pointer-associated with X, or processor-dependent.  Of
the same random sample 3 thought it was associated with X, 1 thought
not.

ANSWER:

1. The call to s1 is not standard conforming. 12.5.2.1 says:

'A dummy data object whose intent is not specified is subject to the
limitations of the data entity that is the associated actual
argument.  That is, a reference to the dummy data object may occur
if the actual argument is defined and the dummy data object may be
defined if the actual argument is definable.'

Here the actual argument is a function result, which is not
definable.  For example, it is not permitted on the left-hand side
of an assignment statement, since it is not a variable.

2. The call to s2 is not standard conforming. 12.4.1.1 says:

'If a dummy argument has INTENT(OUT) or INTENT(INOUT), the actual
argument shall be definable.'

Again the actual argument is a function result, which is not
definable.

3. The call to s3 is standard conforming and the pointer assignment
in s3 causes p and x to become associated. This may be deduced from
12.4.1.1, which says [200:38-42]:

'If the dummy argument has the TARGET attribute and is either scalar
or is an assumed-shape array, and the corresponding actual argument
has the TARGET attribute but is not an array section with a vector
subscript (1) Any pointers associated with the actual argument become
associated with the corresponding dummy argument on invocation of the
procedure ...'

EDITS: None.
SUBMITTED BY:  Malcolm Cohen
HISTORY: 99-198      m150   submitted
         WG5/N1414          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000075
TITLE: Defined assignment and INTENT(IN) dummy arguments in PURE
       procedures
KEYWORDS: INTENT(IN), PURE, defined assignment, dummy arguments
DEFECT TYPE:
STATUS: Passed by WG5 ballot

QUESTION:

Consider the following module:

MODULE m
  TYPE t
    REAL,POINTER :: value
  END TYPE
  INTERFACE ASSIGNMENT(=)
    MODULE PROCEDURE t_asgn_t
  END INTERFACE
CONTAINS
  PURE SUBROUTINE t_asgn_t(lhs,rhs)
    TYPE(t),INTENT(OUT) :: lhs
    TYPE(t),INTENT(IN) :: rhs
    ALLOCATE(lhs%value)
    lhs%value = rhs%value
  END SUBROUTINE
  PURE FUNCTION t_plus_t(a,b)
    TYPE(t) t_plus_t,a,b
    INTENT(IN) a,b
    t_plus_t = a                                  !defined assignment
!Alternative: CALL t_asgn_t(t_plus_t,a)
    t_plus_t%value = t_plus_t%value + b%value
  END FUNCTION
END

According to F95 [212:33-45]
  "Constraint: In a pure subprogram any variable which ... is a dummy
   argument to a pure function ... shall not be used in the following
   contexts:
     ...
     (8) As the <expr> of an <assignment-stmt> in which the
         <variable> is of a derived type if the derived type
          has a pointer component at any level of component
          selection;
      ..."

Therefore it appears that the statement labelled "defined
assignment" is not allowed.  However, it is semantically equivalent
to the commented-out statement in the following line, which would
have been allowed.

Clearly intrinsic assignment in that context must be disallowed as it
implicitly does a pointer assignment which could be used to produce a
side-effect, but the standard appears to rule out defined assignment
as well (which if pure cannot cause any side-effect).

Is this intentional?

ANSWER: No. (8) should apply only to intrinsic assignment so the
        example is correct.

EDIT: Clause 12.6. Penultimate line of page 212 [212:44]. Change
<assignment-stmt> to 'intrinsic assignment statement'.

SUBMITTED BY:  Malcolm Cohen
HISTORY: 99-201      m150   submitted
         WG5/N1414          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Passed by J3 letter ballot
         WG5/N1428          Passed by WG5 ballot, as amended

----------------------------------------------------------------------

NUMBER: 000078
TITLE: Resolving generic procedure references
KEYWORDS: INTENT(IN), NULLIFY
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:

14.1.2.4 (Resolving procedure references) seems to fail to resolve the
following example.

Consider:
  INTERFACE sin
    CHARACTER FUNCTION sinch(c)
      CHARACTER,INTENT(IN) :: c
    END
  END INTERFACE
  PRINT *,sin(3.5)  ! Reference to which procedure?
END

According to rule (1)(a), SIN is established to be generic; thus references
are resolved by the rules in 14.1.2.4.1.

In 14.1.2.4.1:
   Rule (1) fails - the reference is not consistent with any specific
interface
            in the interface block for SIN.
   Rule (2) fails for the same reason.
   Rule (3) fails because there is no INTRINSIC statement.
   Rule (4) fails because there is no host scoping unit.

Is this program legal?
How should the reference to the generic procedure be resolved?

ANSWER:
EDIT:
SUBMITTED BY:  Malcolm Cohen
HISTORY:  99-202   m150 submitted

----------------------------------------------------------------------

NUMBER: 000081
TITLE: Definition status of derived-type objects with pointer
       components
KEYWORDS: Definition status, Derived type, Pointer component
DEFECT TYPE: Clarification
STATUS: Passed by J3 meeting

QUESTION:

Consider:
        TYPE t
          REAL,POINTER :: x
        END TYPE
        TYPE(t) var1,var2
        NULLIFY(var1%x)
        var2 = var1     ! Unfortunate.

According to 14.7.1,
  "An object is defined if and only if all of its subobjects are
   defined."

from which I conclude that the program fragment above is not
conforming.

Should the definition status of an object contain pointer components
depend on the pointer association status of its pointer components
and not their definition status?

ANSWER:

No, pointer components do not affect the definition status of an
object. Edits are supplied to clarify this situation.

EDITS:

[288:17] Replace with
  "(1) An array is defined if and only if all of its elements are
       defined.

   (2) A derived-type scalar object is defined if and only if all of
       its nonpointer components are defined.

   (3) A complex or character scalar object is defined if and only if
       all of its subobjects are defined."
{New definition of "defined"/"undefined" for things that have
 subobjects.}

[288:18-19] Replace "(2)" with "(4)".
{This comment is still true even if completely redundant. It would
 not hurt to delete it.  It probably doesn't belong in the above list
 anyway.}

SUBMITTED BY: Malcolm Cohen

HISTORY: 99-266   m151 submitted
         99-266r1 m151 approved uc
         00-135   m152 revised but withdrawn (no vote)
         01-165r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000085
TITLE: Public components of private types
KEYWORDS: Accessibility, Derived Types, Components
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

F90 interpretation 32 indicated that components of a derived type
may be accessible even in scopes where the derived type name is
inaccessible.  It added an edit to 12.1.2.2.1 of f90 (14.6.1.3 of
f95) saying
  "If a derived type name of a host is inaccessible, data entities of
   that type or subobjects of such data entities can still be
   accessible."

The discussions in the last 2 paragraphs of 4.4.1 of f95 appear to
treat the accessibility of the derived type and its components
as independent issues.  Drafts of f2k added a note to make the
independence clear.

However, 14.1.2.5 of f95 says "If the type is accessible...and the
definition of the type does not contain the PRIVATE statement
(4.4.1), the component name is accessible...."  This statement
appears to make accessibility of the type a condition for
accessibility of the component names, in contradiction with the
above cited edit from f90 interpretation 32.

The following code sample illustrates the issue.  This sample works
on several f90 compilers.

  module m
    type t
      integer :: i
    end type t
    type (t) :: a
  end module m

  program p
    use m, only: a
    a%i = 2
    write (*,*) a%i
  end program p

Question 1.  Is it allowed to access public components of a derived
type object when the type name is inaccessible as illustrated in the
above sample code?

Question 2.  Should there be an edit in 14.1.2.5 of f95 to clarify
this?

ANSWER: (1) Yes.
        (2) Yes.

DISCUSSION:

The quoted text from 14.1.2.5 does not specify the accessibility
of components when a type is not accessible.

EDIT:

[280:25-26] Replace
              "the type is accessible ... 14.6.1.3)"
            by
              "an entity of the type is accessible in another scoping
               unit"
{Whether by use or host association, or - if the type is accessible -
 by declaring a local variable of the type.}

SUBMITTED BY: Richard Maine

HISTORY: 99-101      m148   Submitted
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot
         01-160      m156   Passed unanimously at J3 meeting

----------------------------------------------------------------------

NUMBER: 000086
TITLE: Definition status requirements for defined operations
KEYWORDS: Defined operations
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:

7.1.7 "Evaluation of operations" states

  "This section applies to both intrinsic and defined operations.

   Any variable ... used as an operand in an expression shall be
   defined at the time the reference is executed."

(1) Was this particular requirement intended to apply to defined
    operations?  I.e., is the following example program invalid:

      MODULE m
        INTERFACE OPERATOR (.cand.)
          MODULE PROCEDURE default_cand
         END INTERFACE
       CONTAINS
         LOGICAL FUNCTION default_cand(a,b) RESULT(r)
           LOGICAL,INTENT(IN) :: a,b
           IF (a) THEN
             r = b
           ELSE
             r = .FALSE.
           END IF
         END FUNCTION
       END
       PROGRAM example1
         USE m
         LOGICAL :: false = .FALSE.
         LOGICAL :: undefined
         PRINT *, false .cand. undefined
       END

(2) If the answer to the question is Yes (and the program is therefore
    invalid), would the program be standard-conforming if the
    penultimate line were changed to
        PRINT *, default_cand(false,undefined)
    ?

(3) 7.1.7 goes on to state
    "When a structure is referenced, all of the components shall be
    defined."  Does this mean that pointer components must be
    associated with a defined target?  I.e. is the following program
    non-conforming?

       MODULE m2
         TYPE my_iptr
           PRIVATE
           INTEGER,POINTER :: ptr => NULL()
         END TYPE
         INTERFACE OPERATOR(.isnull.)
           MODULE PROCEDURE isnull_myip
         END INTERFACE
       CONTAINS
         LOGICAL FUNCTION isnull_myip(x)
           TYPE(my_iptr),INTENT(IN) :: x
           isnull_myip = ASSOCIATED(x%ptr)
         END FUNCTION
       END
       PROGRAM example2
         TYPE(my_iptr) a
         PRINT *,.isnull.a
       END

(4) If the program is not standard-conforming, would changing the
    penultimate line to
      "PRINT *,isnull_myip(a)"
    make it standard-conforming.

ANSWER:

(1) No, the requirement was not intentional.

(3) No, this was a mistake.

Discussion:

Usage of defined operations is intended to be equivalent to ordinary
function references.  All of the examples given above are
standard-conforming.

EDITS:

[97:1] Replace "in an expression" with "of an intrinsic operation".
{Only require operands to be defined for intrinsic operations.}

[97:5] Replace "all of its components" with "it".
{A structure may be referenced whenever it is defined.}

HISTORY: 00-292    m154  Submitted;  Passed by J3 meeting
         00-329    m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: 000087
TITLE: MOD and MODULO intrinsic functions with zero divisor
KEYWORDS: Intrinsic functions, MOD, MODULO
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Consider the programs:

      PROGRAM example1
        PRINT *,MODULO(3,0)
        PRINT *,'Test succeeded'
      END

      PROGRAM example2
        PRINT *,MOD(3,0)
        PRINT *,'Test succeeded'
      END

Are these programs standard-conforming, and should "Test succeeded" be
printed in each case?

Discussion:

13.14.74 says of MODULO: "If P=0, the result is processor dependent."

13.14.73 says of MOD: "If P=0, the result is processor dependent."

It appears that example1 and example2 are equally conforming.

Information:

Out of 7 Fortran 90/95 compilers, with
  example1: 5 compiled it ok, 3 of these crashed it at runtime
  example2: 2 compiled it ok, both of these crashed it at runtime

Out of 1 FORTRAN 77 compiler,
  example2 did not compile (error message).

Note that section 7.1.7 [97:6-7] states
  "The execution of any numeric operation whose result is not defined
   by the arithmetic used by the processor is prohibited."
This would seem to be contradictory, at least in spirit, to the
definitions of MOD and MODULO.

ANSWER:

No, these programs were not intended to be standard-conforming. The
processor should be allowed to optimise assuming that P is not zero.
Edits are supplied to correct this mistake in the standard.

EDIT:

  [257:30]    Append "P shall not be zero."
  [257:32]    Change "If P .ne. 0, the" to "The"
  [257:32-33] Delete "If P = 0, the result is processor dependent."
  [257:41]    Append "P shall not be zero."
  [258:2]     Delete "If P .ne 0,"
  [258:4]     Delete "If P = 0, the result is processor dependent."
  [258:5]     Change "If P .ne. 0, the" to "The"
  [258:5-6]   Delete "If P = 0, the result is processor dependent."

SUBMITTED BY: Malcolm Cohen

HISTORY: 00-325 m155 Passed unanimously as amended by J3 meeting

----------------------------------------------------------------------

NUMBER: 000088
TITLE: INTRINSIC statement and attribute
KEYWORDS: intrinsic
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Is it possible for a variable or external procedure that has the same
name as the specific name of an intrinsic function listed in section
13.13 of the Fortran 95 standard and not marked with a bullet to be
used as an actual argument?

For example, consider the following program:

  module SCREEN
    type :: COLOR
      integer :: RED, GREEN, BLUE
    end type COLOR
  contains
    subroutine SET_BACKGROUND ( WHAT )
      type(color), intent(in) :: WHAT
      ! Call to set the background color
    end subroutine SET_BACKGROUND
  end module SCREEN

  program TEST_SCREEN
    use SCREEN
    real, external :: DIM
    character(len=15) :: SIGN
    real :: SIN
    type(color) :: TAN = color(210,180,140)
    call color_intensity ( dim )
    call biblical ( sign )
    call cardinal ( sin )
    call set_background ( tan )
  end program TEST_SCREEN

Notice that the actual arguments have the names of specific intrinsic
functions listed in section 13.13 of the Fortran 95 standard, but
they do not appear in an INTRINSIC statement, nor are they given the
INTRINSIC attribute in a type declaration statement, as required by
the penultimate normative paragraph of 12.3.2.3 of the Fortran 95
standard [198:7-9].

ANSWER:

The answer to the question in the first paragraph is yes.

Fortran has no reserved words. In the scope of the above main program,
none of the names DIM, SIGN, SIN and TAN are names of intrinsic
procedures. The paragraph referenced reads:

   If the specific name of an intrinsic function (13.13) is used as an
   actual argument, the name shall either appear in an INTRINSIC
   statement or be given the INTRINSIC attribute in a type declaration
   statement in the scoping unit.

and tells us that SIN does not refer to the intrinsic procedure. The
names DIM, SIGN, and TAN can be indentified from their declarations
not to be intrinsic procedures. Since none of the names are those of
intrinsic procedures, the paragraph does not affect their use as the
names of actual arguments. The edit makes the meaning clearer.

EDIT:

Page 198, Subclause 12.3.2.3, replace lines 7-9 of page 198 [198:7-9]
by
  'If a specific intrinsic function (13.13) is used as an actual
   argument, it shall have been explicitly declared to have the
   INTRINSIC atrtribute.'

SUBMITTED BY: Van Snyder

HISTORY: 00-249   m154 Submitted
         01-136r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000089
TITLE: Rules allowing duplicate names
KEYWORDS: generic, duplicate names
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Under what conditions can a name in class (1) as described in 14.1.2
be used in more than one declaration?

The second complete paragraph after the list in 14.1.2, immediately
before note 14.2 [276:5-7 in 97-007r2] begins:

``Within a scoping unit, a name that identifies a local entity of one
class shall not be used to identify another local entity of the same
class, except in the case of generic names (12.3.2.1).''

Is the intent here that a generic name may be used only to identify
another generic interface, or that a generic name may be used to
identify any other entity in class (1)?

ANSWER:

The rules are laid out in 12.3.2.1, which is referenced. The
exceptional case is that a procedure is permitted to have the same
specific and generic name.

EDIT:

None.

SUBMITTED BY: Van Snyder

HISTORY: 00-246   m154 Submitted
         01-137r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000090
TITLE: What do ``Prior Specification'' and ``defined previously''
       mean?
KEYWORDS: initialization, prior specification, defined previously
DEFECT TYPE: Clarification
STATUS: Passed by J3 meeting

QUESTION 1

What is a ``prior specification?''

The last normative paragraph of section 7.1.6.1 of the Fortran 95
standard, immediately before note 7.14 [94:38-41 in 97-007r2] states:

``If an initialization expression includes a reference to an inquiry
function for a type parameter or an array bound of an object
specified in the same <specification-part>, the type parameter or
array bound shall be specified in a prior specification of the
<specification-part>.  The prior specification may be to the left of
the inquiry function in the same statement.''

The first two sentences of the last normative paragraph of section
7.1.6.2 of the Fortran 95 standard, immediately before note 7.16
[96:32-35 in 97-007r2] are similar, but refer to specification
expressions.

Unfortunately, there is no definition of ``prior specification.''
Consider:

1.  INTEGER :: P(complicated_expression_for_lower_bound_1:   &
               & complicated_expression_for_upper_bound_1,   &
               & complicated_expression_for_lower_bound_2:   &
               & complicated_expression_for_upper_bound_2) = &
               & RESHAPE( (/ 11, 21, 12, 22 /), SHAPE(P) )

(Notice the reference to P in the <initialization>.)

Some processors reason ``the `specification' of P is only the
specification of its name, kind, rank and array bounds, and therefore
is `prior' by the time the <initialization> is encountered,'' and
accept this.

Others reason ``the `specification' of P is the syntax term
<entity-decl> defined by syntax rule R504 on page 47, which includes
the <initialization>, and it is therefore not `prior' until the
<initialization> is completely specified,'' and do not accept this.

By way of further examples, which of the following are standard
conforming?

2.  INTEGER(selected_int_kind(4)) :: A(KIND(A))
3.  INTEGER :: A(2,2*SIZE(A,1)+1)
4.  CHARACTER :: C(10)*(SIZE(C,1))
5.  INTEGER :: P(10) = LBOUND(P,1)

The paragraphs cited above are silent concerning inquiry functions
that are not for type parameters or array bounds.  These include
BIT_SIZE, DIGITS, EPSILON, MAXEXPONENT, MINEXPONENT, PRECISION,
RADIX, RANGE and TINY.  The results of all of these are derived,
however, from the types and kind type parameters of their arguments.

Are the objects about which these functions inquire required to be
specified in a prior specification of the <specification-part>, and
is that specification allowed to be in the same statement so long as
it is to the left of the inquiry function of which it is an argument?

Which of the following are standard conforming?

6:  INTEGER :: B = BIT_SIZE(B)
7.  INTEGER :: B(BIT_SIZE(B))
8.  INTEGER :: D = DIGITS(D)
9.  INTEGER :: D(DIGITS(D))
10. REAL :: X = EPSILON(X)

One could construct obvious similar examples for the remainder of
inquiry functions that do not inquire about type parameters or array
bounds.

QUESTION 2

The second normative paragraph in subclause 5.1.2.1 [52:27-28 in
97-007r2] states "Any named constant that appears in the
initialization expression shall have been defined previously in the
same type declaration statement...."  The third normative paragraph
after syntax rule R531 in subclause 5.2.9 [61:4-7 in 97-007r2] is
similar.

Does "defined previously" mean that all of the properties of the
named constant shall have been defined previously, or that a
referenced property of it shall have been defined previously?  E.g.
if the KIND is needed, is it necessary for the value to have been
defined?

ANSWER 1

    A prior specification refers to a specification in a previous
    <entity-decl> or in a previous statement.  None of the examples
    are legal.

ANSWER 2

    In the referenced text (5.1.2.1), "Any named constant that
    appears ... shall have been defined previously" mean that all of
    the properties of the named constant shall have been defined
    previously;  therefore, if the KIND of a named constant is
    needed, is it necessary for the value of that named constant to
    have been defined previously also.

SUBMITTED BY: Van Snyder

HISTORY: 00-229   m154 Submitted
         00-324   m155 Amended
         01-138r1 m156 Passed by J3 meeting

----------------------------------------------------------------------

NUMBER: 000091
TITLE: Definition of "present" is defective
KEYWORDS: present, dummy argument
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

Subclause 12.4.1.5 begins with a definition of the term "present":

"A dummy argument is present in an instance of a subprogram if it is
associated with an actual argument and the actual argument either is a
dummy argument that is present in the invoking subprogram or is not a
dummy argument of the invoking subprogram."

This seems to be defective in that if the actual argument is a dummy
argument that is accessed by host association, it is not a dummy
argument OF the invoking subprogram, and therefore although it may be
"not present" in the procedure of which it is a dummy argument, it is
nonetheless "present" in an internal procedure of that procedure.

Consider:

  module M
  contains
    subroutine S1 ( A )
      integer, optional :: A
      call S11
    contains
      subroutine S11
        call S12 ( A )
      end subroutine S11
      subroutine S12 ( B )
        integer, optional :: B
        if ( present(B) ) print *, 'B is present'
      end subroutine S12
    end subroutine S1
  end module M

  program P
    use M, only: S1
    call S1
  end program P

Should this print "B is present" as implied by the above analysis?

ANSWER:

No, the program should not print anything.

DISCUSSION:

The lack of consideration of host association in the cited text is
accidental; an edit is supplied to correct this oversight.

EDITS:

[202:43-45] Replace the first sentence of 12.4.1.5 by
"A dummy argument is not <<present>> if it is
 (1) not associated with an actual argument, or
 (2) is associated with an actual argument that is
     (a) a dummy argument that is not present or
     (b) an entity that is host-associated with a dummy argument
         that is not present.
 Otherwise, it is present."

SUBMITTED BY: Van Snyder

HISTORY: 01-134   m156 Submitted
         01-134r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000092
TITLE: Values of the PAD= Specifier in the INQUIRE Statement
KEYWORDS: PAD=, INQUIRE
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

The normative text of the Fortran 90 and Fortran 95 standards
(9.6.1.22) specifies that the PAD= specifier in the INQUIRE statement
returns the value YES if there is no connection or if the connection
is for unformatted input/output.

This behavior is different from the results of almost every other
specifier for the INQUIRE statement if the property being inquired
about is unknown or undefined.  For those specifiers, the value
returned in the specifier's variable is either UNKNOWN or UNDEFINED.

Is the specified behavior of the PAD= specifier for an unformatted
file or an unconnected unit intentional?

ANSWER:

No, this specification is in error.  Edits are supplied to correct
this defect.

DISCUSSION:

The concept of padding input records does not make any sense if the
unit is connected for unformatted input/output or if the unit is not
connected.  A return value of YES does not reflect what is really
going on.  A return value of UNDEFINED is more appropriate in these
situations.

The normative text for this section in Fortran 95 is unchanged from
Fortran 90, so correcting this defect is an incompatibility with
Fortran 90.

EDITS:

The following edits are with respect to the Fortran 95 standard.

  [3:32+] Add the following list item to the list in section 1.5.1,
          "Fortran 90 compatibility".

          (3) The PAD= specifier in the INQUIRE statement in this
              standard returns the value UNDEFINED instead of YES if
              there is no connection or the connection is for
              unformatted input/output.

  [159:40-41] Replace the second sentence of the paragraph in section
              9.6.1.22 with the following.

              The <scalar-default-char-variable> in the PAD=
              specifier is assigned the value YES if the connection
              of the file to the unit included the PAD= specifier and
              its value was YES or if there was no PAD= specifier.
              If there is no connection or if the connection is not
              for formatted input/output, the
              <scalar-default-char-variable> is assigned the value
              UNDEFINED.

  [325:30] Change the entry in the table to:

           +--------+-----------+------------------------+-----------+
           | PAD=   | UNDEFINED | YES, NO, or UNDEFINED  | UNDEFINED |
           +--------+-----------+------------------------+-----------+

SUBMITTED BY: Craig T. Dedo

HISTORY: 01-172 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: 000093
TITLE: Allocatable arrays as actual arguments
KEYWORDS: Allocatable array, actual argument
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

There does not seem to be any requirement that an allocatable array be
allocated for it to be used as an actual argument.  Consider

    PROGRAM P
        ALLOCATABLE A(:,:)
        CALL S(A)
    CONTAINS
        SUBROUTINE S(X)
            DIMENSION X(:,:)
            PRINT *,SHAPE(X)
        END SUBROUTINE
    END

Is this a standard-conforming program?  If so, what does it print?

ANSWER:

No, this is not intended to be a standard-conforming program.  An
allocatable array must be allocated for it to be used as an actual
argument, except where otherwise specified in the standard (e.g. for
the ALLOCATED intrinsic function.  An edit is supplied to clarify
this intent.

EDIT:

[80:34] Change "; it" to
        ".  It shall not be supplied as an actual argument other than
         as specified for intrinsic inquiry functions.  It"

{Note to J3: there are quite of few of these, scattered across the
 early part of Ch13 so we cannot give a useful cross-reference.}

SUBMITTED BY: Malcolm Cohen

HISTORY: 01-184   m156 Passed unanimously at J3 meeting

======================================================================
Part 3: Unfinished F90 interpretations with their F90 interp number.
======================================================================

NUMBER: F90/000049
TITLE: Characteristics of function results
KEYWORDS: characteristics, function result, ENTRY statement, exact
dependence,
          association - partial, association - entry
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

QUESTION: Given a character function with an ENTRY statement, both results
must
have the same characteristics or be scalars without the POINTER attribute
and
have identical length.  Therefore:

          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN,ENT
            ...
            ENTRY ENT(M,N)
            ...
          END FUNCTION

is standard conforming.

Question 1:
          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN
            CHARACTER (LEN=M+N)::ENT
            ...
            ENTRY ENT(M,N)
            ...
          END FUNCTION

Is the code above standard conforming?

Question 2:
          FUNCTION FUN(M,N)
            CHARACTER (LEN=M+N)::FUN
            CHARACTER (LEN=N+M)::ENT
            ...
            ENTRY ENT(M,N)
            ...
          END

Is the code above standard conforming?

Question 3:
          FUNCTION FUN(M)
            CHARACTER (LEN=M+M)::FUN
            CHARACTER (LEN=M*2)::ENT
            ...
            ENTRY ENT(M)
            ...
          END

Is the code above standard conforming?

Question 4: What is the meaning of the phrase "the exact dependence on the
entities" in section 12.2.2?

ANSWER:

Answer 1. Yes
Answer 2. Yes
Answer 3. Yes
Answer 4.  The sentence containing the phrase "the exact dependence on the
entities" in section 12.2.2 is intended to convey that in those cases where
the
shape or character length type parameter is not constant, the corresponding
characteristic of the function result is not a value but the way the value
is
determined when the procedure is invoked.

Discussion: Only the mapping from program state to value is significant, not
the
particular form in which that mapping is expressed.

In question 3, for example, it is a characteristic of FUN and ENT that their
lengths are twice the value of M.  It is not required that the expressions
of
this mapping be identical, only that they yield the same results.  Thus,
twice
the value of M could be expressed as M+M for FUN and as M*2 for ENT.

The phrase "the exact dependence on the entities in the expression is a
characteristic" is used to give the processor the freedom to evaluate
lengths
and bounds in any convenient manner.  Since the characteristics must be the
same, the phrase implies, as a minimum, that the expressions be
algebraically
equivalent and use the same variables.  In an example such as:

            FUNCTION FUN(M)
            CHARACTER (LEN=M)::FUN
            CHARACTER (LEN=M + 0*K)::ENT
            ...
            ENTRY ENT(M, K)
            ...
            END

FUN and ENT do not have the same characteristics since their dependence on
"K"
is different.  Indeed, if on entry to FUN the length of FUN or ENT were
evaluated using the expression for the length of ENT the evaluation would
fail
since K is not associated with a value.

Clearly, it can be extremely difficult to determine on a static basis
whether
two expressions of a mapping are consistent, and there is no requirement in
the
standard that this be done.  It would be possible to check during execution
that
the values expressed are identical each time such a procedure is invoked,
but it
is expected that a more typical application of this requirement would be to
assume that it has been met and use one expression of this mapping as the
basis
for computing attributes of all of the result variables.

REFERENCES: ISO/IEC 1539:1991 (E) section 12.2.2 & 14.6.3.3
EDITS:  None
SUBMITTED BY: Y. Yoshida, X3J3/92-051 (121-ADT-11) pp.-13
HISTORY: 92-109A m121 Approved 19-0
         92-313  m123 response to ballot comments and
                      approved by uc
         93-105       Revised in response to ballot comments
         93-152  m125 New edit, rejected
         94-059  m128 New edit,
         94-252  m130 New response without edits, approved u.c.
         94-306  m131 X3J3 ballot approved 18-1
         95-044  m132 WG5 ballot failed, text in Answer 4 and discussion
needs
                      revision

----------------------------------------------------------------------

NUMBER: F90/000070
TITLE: Characteristics specified by interface bodies
KEYWORDS: characteristics, array bounds, array shape, function result
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION:
Section 12.3.2.2 indicates that an interface body specifies all of a
procedure's characteristics and that the characteristics must be consistent
with those in the procedure definition.  Are the following code fragments
standard conforming?

(a)      PROGRAM FRED
           INTERFACE
             SUBROUTINE SUB (ARR,J)
               INTEGER ARR(1:)
             END SUBROUTINE
           END INTERFACE
         INTEGER ARR(10)
         CALL SUB(ARR,2)
         END PROGRAM

         SUBROUTINE SUB(ARR, J)
           INTEGER ARR(J:)
           ...
         END SUBROUTINE SUB

(b)      FUNCTION C1( )
           CHARACTER(*) C1
           ...
         END FUNCTION C1
         FUNCTION C2(N)
           CHARACTER(N) C2
           ...
         END FUNCTION C2

         SUBROUTINE CALLER( )
           INTERFACE
             FUNCTION C1( )
               CHARACTER(*) C1
             END FUNCTION
             FUNCTION C2(N)
               CHARACTER(2) C2
             END FUNCTION
           END INTERFACE
           CHARACTER(5) CC
           CC=C1( )//C2(2)

ANSWER:

  (a)  This example is standard conforming.

  (b)  This example is not standard conforming.

Discussion:

(a) 12.2.1.1 states that the characteristics of a dummy data object include
its
shape, and that if the shape is assumed then that is a characteristic.
Section
2.4.5 states that the shape of an array is determined by its rank and extent
in
each dimension (but not by its bounds, 5.1.2.4.2).  Both the interface block
for
SUB and the definition of SUB describe the shape of ARR as assumed, so they
are
describing the same shape, and the program is standard conforming.

It is possible to read the second sentence in 12.2.1.1 as requiring bounds
to
match.  This was not intended.  An edit to that section (defect item 49) has
clarified that it is the shape resulting from the bounds specifications that
is
a characteristic and not the bounds themselves.

(b) Section 12.2.2 states that the characteristics of a function include
whether
or not the function result value is a character of assumed length.  So the
interface body for function C1 must indicate that C1 is of assumed length.
However, item (3) in 5.1.1.5 indicates that scoping units that invoke an
external character function of assumed length must have access to a
declaration
of the function name with a length type parameter value other than *.  An
edit
is included to clarify this restriction.

In addition, the interface for C2 does not conform to the standard as the
length
of C2 specified as 2 is not consistent with the length specified as N within
the
function definition.

REFERENCES: ISO/IEC 1539:1991 (E) sections 2.4.5, 5.1.1.5, 5.1.2.4.2,
            12.2.1.1, and 12.2.2.

EDITS: In section 5.1.1.5 item (3), add to the end [43:5]:

       "Note that the interface for such a function cannot be specified in
an
       interface body."

SUBMITTED BY: Graham Barber (a),  Janice Shepherd (b)
HISTORY: 92-264      Question (a) originally posed
         92-46       Question (b) originally posed in e-mail collection
         ui 48       (jw note)
         92-283      Response proposed
                m123 Approved by unanimous consent
         93-018      Response questioned by John Reid in
         93-103      Revised response proposed
                m124 Approved by unanimous consent
         93-111 m125 ballot, return to subgroup, Leonard comment,
                       coordinate with 0000049?
         94-060 m128 New edit in 0000049 referenced

----------------------------------------------------------------------

NUMBER: F90/000096
TITLE: Definition of "Declaration"
KEYWORDS: declaration, specification
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION:  "Declaration" is a significant concept of Fortran 90.

Section 5 is titled "Data object declarations and specifications" and what
were
in FORTRAN 77 "type statements" are now "type declaration statements".
5.1.1
states

    "A type specifier specifies the type of all entities declared in an
entity
    declaration list."

Nowhere, though, is there a definition of "declaration".

What does it mean, in Fortran 90, to "declare" something?

ANSWER: The edits below add a definition of "declaration" and, for clarity,
also add a definition of "specification".

Edits related to these definitions are also provided.

REFERENCES:

EDITS:

1. Replace the text of 2.5.3 "Declaration" [16:13-18] with:

    A data object declaration specifies the creation, attributes, and
    lifetime of the object.  Every data object must be declared.
Declarations
    can be explicit or contextual.  Data object attributes not specified
    explicitly are determined implicitly.  A declaration of a data object of
    derived type is also a declaration of all of its components.

    In a scoping unit, if a name appears as:

       (1) an object-name in an entity-decl in a type-declaration, SAVE,
              POINTER, or TARGET statement
       (2) a named-constant in a named-constant-def in a PARAMETER statement
       (3) an array-name in a DIMENSION or ALLOCATABLE statement
       (4) a variable-name in a common-block-object in a COMMON statement
       (5) the name of a variable that is wholly or partially initialized in
a
             DATA statement
       (6) the name of an object that is wholly or partially equivalenced in
an
             EQUIVALENCE statement
       (7) a dummy-arg-name in a FUNCTION, SUBROUTINE, ENTRY or
              statement-function statement
       (8) a result-name in a FUNCTION or ENTRY statement

        then those statements constitute an explicit declaration of a data
        object with that name in that scoping unit.

    otherwise: if a name that is not a procedure name, module name,
    program name, generic identifier, common block name, namelist group
name,
    construct name, or derived type name, appears in any statement and that
    name is not the name of a data object accessed by host or use
association

        then those appearances constitute a contextual declaration of a data
        object with that name in that scoping unit

2. In section 5.2.9 "DATA statement", in the fifth constraint
   following R537 [52:31-32]:

       delete "made accessible by use or host association,"

   as now redundant with the definitions of use and host association.

3. In 11.3.2 "USE statement", in the paragraph beginning "If two or more"
   in the third sentence [158:29-31]:

       change: through
           to: through explicit declaration,

4. In 12.1.2.2.1 "Host association" replace items 5 though 12 with the
   one new item [164:8-17]

      (5) An explicitly declared data object (2.5.3);

5. In Annex A, add to page 256 after "datum" [256:10+]

   Declaration(2.5.3): A declaration specifies the existence of a data
object.

6. In Annex A, add to page 260 after "size" [260:14+]

   Specification: A specification assigns attributes and properties to
names.

SUBMITTED BY: Dick Weaver
HISTORY: 92-232  Submitted
         92-232r Draft response, withdrawn
         93-144 m125 unanimous consent
         93-255r1 m127 ballot failed 16-7
         94-103 m128 revised response, approved uc
         94-116 m129 X3J3 ballot failed 16-7
         94-223 m130 revised response
         94-335 m131 alternate response proposed, withdrawn

----------------------------------------------------------------------

NUMBER: F90/000140
TITLE: TARGET attribute for a derived-type object with a pointer component
KEYWORDS: POINTER attribute, TARGET attribute, structure, structure
component
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION: Section 6.1.2 (page 63) states:

   "A structure component has the INTENT, TARGET, or PARAMETER attribute if
the
    parent object has the attribute."

A constraint following R505 (page 40) states:

   "Constraint: If the POINTER attribute is specified, the TARGET, INTENT,
    EXTERNAL, or INTRINSIC attribute must not be specified."

This would seem to imply that a derived-type object with a pointer component
could not have the TARGET attribute. Though it is informative, Annex C.4.6
(page 267) contains the following example:

       "TYPE CELL
                INTEGER :: VAL
                TYPE (CELL), POINTER :: NEXT_CELL
        END TYPE CELL
        TYPE (CELL), TARGET :: HEAD
        TYPE (CELL), POINTER :: CURRENT
        ...
        CURRENT => HEAD"

which allows the static head of a linked list or tree.  Does the structure
component HEAD % NEXT_CELL contradict the text cited above from section
6.1.2
or the cited constraint following R505?

ANSWER: No, the component reference does not contradict either the
constraint
or the cited text from 6.1.2.  The cited text from 6.1.2 is not needed and
an
edit provided deletes it.

Discussion: The constraints that follow a syntax rule, or a set of syntax
rules, are syntactic constraints and apply only to the syntax rules they
immediately follow.  Thus, the constraints that follow rules R501 through
R505 at the beginning of section 5 apply only to those rules.  This means
they
apply only to type declaration statements.  Since a derived type component
is
part of a derived type definition (which is not a type declaration
statement),
the constraints do not apply to derived type components.  The rule that
prevents an entity from having conflicting attributes when applied by
multiple specification statements is found in 5.2:

  "The combination of attributes that may be specified for a particular
   entity is subject to the same restrictions as for type declaration
   statements regardless of the method of specification."

The sentence from 6.1.2 cited in the question is not necessary (and is thus
deleted by an edit) because the "barrier" to a reference or definition of a
structure component is at the structure (parent) level and thus no
additional
"barrier" is needed at the component level. Thus, for example, specifying
an attribute such as TARGET at the structure level is sufficient; there
is no need to "trickle down" the attribute to components of the structure
(and indeed if a component were treated as an independent variable, the
combination of TARGET and POINTER would otherwise be prohibited). The
philosophy that an attribute applied at the structure (parent) level is all
that is needed is borne out by the following:

  TARGET:  Section 7.5.2, second constraint states:
    "The <variable> must have the TARGET attribute or be a subobject of
     an object with the TARGET attribute ..."

  PARAMETER: Rule R601 and the constraints associated with it state that
neither
    an <array-variable-name> nor a <scalar-variable-name> can have
    the PARAMETER attribute and that a <subobject> must not be a subobject
    designator whose parent is a constant.

  INTENT(IN): The response to defect item 135 added a constraint to 5.1.2.3
    that states that a dummy argument with the INTENT(IN) attribute, or a
    subobject of such an object, must not appear in any assignment context.

EDIT:
In section 6.1.2, in the paragraph following the last constraint [63:15-17],
  delete the sentence that starts:

      "A structure component has the INTENT..."

SUBMITTED BY: J. Martin in response to email May 7, 1993 from Yukimasa
Yoshida
HISTORY: 93-179  m125 canceled, interpretation number then reassigned
         93-181  m125 Response, Withdrawn to remove suggested edit.
         93-223r m126 Response proposed, approved uc
         93-255r1 m127 ballot failed 18-5
         94-339  m131 Revised response proposed, approved 14-2
         95-034r1 m132 X3J3 ballot failed 8-12
         95-033   m132 Revised response, straw vote on intent 5-2-7
         95-092   m132 Revised discussion, approved u.c.
         95-101   m133 X3J3 ballot failed 11-7

----------------------------------------------------------------------

NUMBER: F90/000145
TITLE: Expressions in <type-spec> of a FUNCTION statement
KEYWORDS: expression - specification, expression - initialization,
          FUNCTION statement, host association, use association
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION: The syntax rule R1217 shows that the type and type parameters of a
function can be specified in the FUNCTION statement (12.5.2.2).

(a) If a <type-spec> appears in a FUNCTION statement, can the initialization
and specification expressions of that <type-spec> involve names of entities
that are declared within the function or are accessible there by host or
use association?

(b) Section 5.1 states:

      "The <specification-expr> (7.1.6.2) of a <type-param-value> (5.1.1.5)
       or an <array-spec> (5.1.2.4) may be a nonconstant expression
       provided the specification expression is in an interface body
       (12.3.2.1) or in the specification part of a subprogram."

As a FUNCTION statement is not part of the specification part of a
subprogram, this text in the standard appears to distinguish between
FUNCTION statements that are in interface blocks and ones that are not.
This text seems to prohibit such examples as:

         INTEGER I
          ...
         CONTAINS
           CHARACTER*(I+1) FUNCTION F()
              ...
              COMMON // I
              ...

where it can be confusing as to which I is being referenced in the FUNCTION
statement.  While host association does not apply to interface bodies, for
consistency should the text quoted from Section 5.1 have been "... is in
the specification part of an interface body (12.3.2.1) or in the
specification part of a subprogram."?

(c) Section 7.1.6.1 states:

      "If an initialization expression includes a reference to an inquiry
      function for a type parameter or an array bound of an object specified
      in the same <specification-part>, the type parameter or array bound
must
      be specified in a prior specification of the <specification-part>."

Was this text intended to apply to FUNCTION statements even though they are
not part of any <specification-part>, thus disallowing fragments such as:

      INTEGER (KIND=KIND(X)) FUNCTION F()
        INTEGER(KIND=KIND(0)) X
        ...

Similar text appears in Section 7.1.6.2.

ANSWER:
(a) A specification expression in the <type-spec> of a FUNCTION statement
may
involve names of entities that are declared within the function or are
accessible there by host or use association, but an initialization
expression in
such a <type-spec> may only involve names that are accessible by host
or use association.

(b) No.  It was not the intent of the standard to distinguish between the
two
types of FUNCTION statements cited.  As elaborated in the discussion of part
(a), the standard intended to allow the <type-spec> expression of a FUNCTION
statement to be a nonconstant expression.  The sentence cited is corrected
with
a supplied edit.

(c) Yes, the text cited from 7.1.6.1 was intended to apply to FUNCTION
statements.  The sentence quoted and the corresponding sentence in 7.1.6.2
are
corrected with supplied edits.  The code fragment is not standard
conforming.

Discussion:

(a) An initialization expression is a constant expression with an additional
rule relating to exponentiation (7.1.6.1).  Since it is a constant
expression,
the only names it can contain are the names of named constants, structure
constructors, intrinsic procedures, and variables whose type parameters or
bounds are inquired about.

    * Named constant

      Section 5.1.2.1 states:

       "A named constant must not be referenced in any ... context unless
        it has been defined in a prior PARAMETER statement or type
declaration
        statement using the PARAMETER attribute, or made accessible by use
        association or host association."

      Since the FUNCTION statement is the first statement of the scoping
unit,
      there can be no prior PARAMETER statement or type declaration
statement
      using the PARAMETER attribute, so the first clause does not apply.
      A named constant can appear in a <type-spec> of a function statement
      if it is accessible within the function by host or use association.

    * Structure constructor

      Rule R502 shows that the only opportunities for expressions to appear
in
      <type-spec>s are in a <kind-selector> or in a <char-selector>.
However,
      a structure constructor can not appear in a <kind-selector> because
rule
      R505 shows that a <kind-selector> must be an integer expression.
      Similarly, R506 shows that any initialization expression in a
      <char-selector> must be type integer.  Therefore, a structure
constructor
      can not appear in an initialization expression in the <type-spec> of a
      FUNCTION statement.

    * Intrinsic procedure

      The intrinsic procedure names or classes of intrinsic procedures that
may
      appear in an initialization expression are given in 7.1.6.1.

    * Variables whose type parameters or bounds are inquired about

      The text from section 7.1.6.1 as cited in question (c) was
      intended to apply to initialization expressions in the <type-spec>
      of a FUNCTION statement.  With the correction supplied, this
      means that if a variable appears as the argument to an inquiry
      intrinsic in the <type-spec> of a FUNCTION statement, the function
      must be a module procedure or an internal procedure, and the
      variable must exist in (be accessible from) the host scoping unit.

Rule R502 defines <type-spec>.  The only opportunity for a <type-spec> to
contain a <specification-expr> is when the data type is character
(<type-param-value> may be a <specification-expr>).  Section 7.1.6.2 states
that
a specification expression is a restricted expression that is scalar, of
type
integer, and each operation must be intrinsic.  In addition, rule (2) of
7.1.6.2
states that a primary of a specification expression can be a dummy argument
that
has neither the OPTIONAL nor INTENT(OUT) attribute.  The following code
fragment
demonstrates a use of such a dummy argument:

              CHARACTER*(N+1) FUNCTION S(N)
              INTEGER, INTENT(IN) :: N

Rule (2) also states that the primary can be a subobject of such a dummy
argument.  Section 6.1.2 indicates that a structure component must not be
referenced or defined before the declaration of the parent object.  Similar
rules are needed to prevent a substring from being referenced ahead of the
declaration of its parent, and an array element or array section from being
referenced ahead of the declaration of the array.  Edits are provided to
supply
these rules.  Since a subobject can not be referenced before its parent
object
is declared and the FUNCTION statement is the first statement of the
subprogram,
the parent's declaration could not have occurred.  Thus a subobject must not
be
referenced in the <type-spec> on a FUNCTION statement for objects declared
within the function.

Rule (3) states that a primary can be a variable that is in a common block.
The
following code fragment demonstrates a use of such a common block member:

              CHARACTER*(N+1) FUNCTION S()
              ...
              COMMON N

As in rule (2), rule (3) allows a subobject of such a variable but for the
same
reasons as above, such a subobject designator can not appear in the
<type-spec>
expression of a FUNCTION statement.

Rule (4) states that a primary may be a variable that is accessible by use
association or host association.  The following code fragments demonstrate
uses
of such variables:

              PROGRAM MAIN
              INTEGER :: N = 21
              ...
              CONTAINS
                CHARACTER(LEN = 2*N) FUNCTION SS(K)    ! N is host
associated.
                ...
                END FUNCTION
              END PROGRAM

    and

              MODULE MOD
              INTEGER K
              DATA K /20/
              END MODULE

              CHARACTER*(K*2) FUNCTION CHECK(STR)      ! K is use
associated.
              USE MOD
              ...
              END FUNCTION

Rule (4) also states that the primary can be a subobject of such a use or
host
associated variable.

A structure constructor can not appear in a FUNCTION <type-spec>
specification
expression because the expression must be of type integer and any operations
(which might yield an integer value from one or more structure constructors)
must be intrinsic.

Other rules of 7.1.6.2 state which intrinsic procedure names or classes of
intrinsic procedures may appear in a specification expression.

Section 7.1.6.2 also states:

        A variable in a specification expression must have its type and
        type parameters, if any, specified by a previous declaration in
        the same scoping unit, or by the implicit type rules currently
        in effect for the scoping unit, or by host or use association.

The discussion above regarding specification expressions has already ruled
out
"previous declarations" so the first clause of the cited sentence does not
apply.  The other clauses apply equally to a FUNCTION statement <type-spec>
and
to type declaration statements inside the function.

(b) When the discussion for part (a) is applied to the code fragment
provided,
it means that the 'I' referenced in the <type-spec> of the FUNCTION
statement is
the common block member.

EDITS:
1. Section 5.1, in the first sentence of the paragraph that starts
   "The <specification-expr> (7.1.6.2)" [40:39-41],

    change "in an interface body (12.3.2.1) or in the specification part of
a
            subprogram"

       to  "contained in an interface body (12.3.2.1), is contained in the
            specification part of a subprogram, or is in the <type-spec> of
a
            FUNCTION statement (12.5.2.2)"

2. Section 6.1.1, add to the end of the paragraph before the examples
[62:29]

    "A substring must not be referenced or defined before the
     declaration of the type and type parameters of the parent string,
     unless the type and type parameters are determined by the implicit
     typing rules of the scope."

3. Section 6.2.2, add after the sentence "An array section is an array."
   [64:16]
           "An array element or array section must not be referenced
            or defined before the declaration of the array bounds."

4. Section 7.1.6.1, in the paragraph after the constraints [78:21-22]

    change "object specified in the same <specification-part>, the
             type parameter or array bound must be specified in
             a prior specification of the <specification-part>."

    to     "object declared in the same scoping unit, the type
            parameter or array bound must be specified in a
            specification prior to the initialization expression."

5. Section 7.1.6.2, in the 2nd paragraph after the constraint [79:28-29]

    change "entity specified in the same <specification-part>, the
             type parameter or array bound must be specified in
             a prior specification of the <specification-part>."

    to     "entity declared in the same scoping unit, the type
            parameter or array bound must be specified in a
            specification prior to the specification expression."

SUBMITTED BY: Janice C. Shepherd
HISTORY: 93-193   m126 submitted
         94-023r1 m128 response, approved uc
         94-116r1 m129 X3J3 ballot failed 22-1
         94-336   m131 revised response, approved u.c
         95-034r1 m132 X3J3 ballot failed 15-5
         95-281   m135 revised response, reworded edit 3, WG5 approved
(N1161)
         96-      m136 X3J3 ballot failed 15-1, WG5 approval removed.

----------------------------------------------------------------------

NUMBER: F90/000164
TITLE: Use of ONLY with multipart definitions
KEYWORDS: ONLY, module, derived type
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION: Sections 11.3.1 and 11.3.2, among others, describe how
accessibility
of data objects, derived type definitions, etc.  can be controlled via the
ONLY
clause of the USE statement and via the PUBLIC and PRIVATE accessibility
attributes/statements.  But these sections do not describe what happens when
a
definition consists of multiple parts and only some of the parts have their
accessibility controlled.  Examples include, but are not limited, to the
following:

Example 1:
              MODULE MOD
              INTEGER, PARAMETER :: MAX_SIZE = 100
              INTEGER, DIMENSION(MAX_SIZE) :: ARRAY
              END MODULE

              PROGRAM MAIN
              USE MOD, ONLY: ARRAY
              ...
              END PROGRAM

Since the declaration of ARRAY depends on the value of MAX_SIZE, is it valid
to
only allow access to ARRAY?  Is the array constructor for ARRAY, for
example,
accessible to the main program?

Example 2:
              MODULE MOD

              TYPE INNER
                INTEGER I
              END TYPE

              TYPE OUTER
                INTEGER K
                TYPE(INNER) COMP
              END TYPE

              END MODULE

              PROGRAM MAIN
                USE MOD, ONLY: OUTER
                ...
              END MODULE

The derived type OUTER in module MOD has a component of derived type INNER.
However, when the main program accesses the module, it restricts access to
only
derived type OUTER.  Since OUTER depends on the definition of INNER, is it
valid
to only allow access to OUTER?  If it is not valid, is it only an error if
something in the main program actually tries to use OUTER?  Can you write a
structure constructor for OUTER in the main program?  If it is valid, can
component I of substructure COMP be referenced?

Example 3:
              MODULE MOD

              TYPE DEF
                INTEGER K
                REAL    R
              END TYPE

              TYPE(DEF) VAR

              END MODULE

              PROGRAM MAIN
                USE MOD, ONLY: VAR
                ...
              END MODULE

In this example, only the variable VAR from the module is accessible; its
type
is not.  Is this valid?  If it is valid, can only the structure name VAR be
referenced or can its components also be referenced?  If only the structure
name
VAR can be referenced, what is the meaning when the structure name is
included
in a namelist object list for input and/or output?

Example 4:
              MODULE MOD
              INTEGER, PARAMETER :: MAX_SIZE = 100
              INTEGER, DIMENSION(MAX_SIZE) :: ARRAY
              PRIVATE MAX_SIZE
              END MODULE

              PROGRAM MAIN
              USE MOD
              ...
              END PROGRAM

Another way to limit access to items in modules is via the PRIVATE
attribute/statement.  Since the declaration of ARRAY depends on the value of
MAX_SIZE, is it valid to only allow access to ARRAY?  Is the array
constructor
for ARRAY, for example, accessible to the main program?

ANSWER:
EDIT(S):
SUBMITTED BY: Larry Rolison
HISTORY: 94-038 m128 submitted

----------------------------------------------------------------------

NUMBER: F90/000180
TITLE: Unambiguous generic references
KEYWORDS: host association, generic name
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION: Consider the following example:

     SUBROUTINE S()

       INTERFACE GEN1
         FUNCTION F1(I)
         END FUNCTION
         FUNCTION F2(I,J)
         END FUNCTION
       END INTERFACE

       INTERFACE GEN2
         FUNCTION G1()
         END FUNCTION
         FUNCTION G2(I)
         END FUNCTION
       END INTERFACE

       CALL SS()

       CONTAINS

          SUBROUTINE SS()

             INTERFACE GEN1
               FUNCTION F3(I,J,K)
               END FUNCTION
               FUNCTION F4(II)
               END FUNCTION
             END INTERFACE

             INTERFACE GEN2
               SUBROUTINE G3()
               END SUBROUTINE
             END INTERFACE

              A = GEN1(1,2,3)  ! CALL TO F3
              A = GEN1(1,2)    ! CALL TO F2
              A = GEN1(1)      ! CALL TO F4
              CALL GEN2()      ! CALL TO G3
         END SUBROUTINE

      END

There are rules in section 14.1.2.3 that determine within a scoping unit
what
procedures can have the same generic specification.  These rules directly
mention access of a generic procedure via use association, but they make no
mention of generic names accessed via host association.

There is evidence that the rules in section 14.1.2.3 were not intended to
apply
to generic interfaces accessed by host association.  Section 14.1.2.4.1
indicates that a call to a generic name can be resolved to a generic name in
the
host if the scoping unit and the host scoping unit both agree that the
generic name is the name of a function or a subroutine.  This indicates that
in
the example above, the definition of 'GEN2' is valid, even though 'G1' and
'G2'
are functions while 'G3' is a subroutine.  If the rules set out in 14.1.2.3
were
to apply then the definition of 'GEN2' would be invalid.

Do the rules in 14.1.2.3 apply to generic procedures accessed via host
association?

ANSWER: No.  The rules in 14.1.2.3 were intended to apply to only those
specific
procedures declared to be generic in a scoping unit and those accessed via
use
association.  Edits are included to clarify this.

EDITS:
1. Add to the end of the first sentence of section 14.1.2.3 [242:27]

   "when the generic interfaces for each of the specific procedures are
   declared in the same scoping unit or accessed via use association."

2. Add to the end of the first paragraph of section 14.1.2.3 [242:32]

    "When a generic procedure is accessed from a host scoping unit, the
steps
    for resolving a procedure reference as described in 14.1.2.4.1 have the
    same effect as if the rules restricted which specific versions from the
    host scoping unit can be accessed via the generic reference."

SUBMITTED BY: Janice C. Shepherd
HISTORY: 94-239r3 m130 submitted with suggested answer, approved u.c.
         94-306   m131 X3J3 ballot, failed 15-4

----------------------------------------------------------------------

NUMBER: F90/000190
TITLE: Subobjects of constants in a DATA statement
KEYWORDS: DATA stmt, constant
DEFECT TYPE: Interpretation
STATUS: J3 consideration in progress

QUESTION: Consider the following syntax rules from Section 5.2.9:

  R532 <data-stmt-value>    is  [<data-stmt-repeat>*] <data-stmt-constant>
  R533 <data-stmt-constant> is  <scalar-constant>
                                ...
  R534 <data-stmt-repeat>   is  <scalar-int-constant>

and the following constraint

  Constraint:  A <scalar-int-expr> of a <data-implied-do> must involve as
               primaries only constants or DO variables of the containing
               <data-implied-do>s, and each operation must be intrinsic.

In all cases, the rules reduce to "constant".  The definition of "constant"
is provided by R305:

  R305 <constant>           is   <literal-constant>
                            or   <named-constant>

  R307 <named-constant>     is   <name>

The above two rules seem to indicate that if an identifier appears where
"constant" is allowed in the DATA statement rules cited above, the
identifier
must be a name; that is, it can not be the subobject of a named constant.

Is this analysis correct?

ANSWER:  Yes, your analysis is correct.  A <data-stmt-repeat>, a
<data-stmt-constant>, and a constant appearing in a <scalar-int-expr> of a
DATA implied-DO can be a name (of a named constant) but not a subobject
designator.

Discussion: There is no intent in the standard to extend the above rules
over
what was provided in the FORTRAN 77 standard.  So, for example, the
following
program fragment is not standard conforming:

           INTEGER, PARAMETER :: PARR(3) = (/ 1, 2, 3 /)
           INTEGER            :: ARRAY(3)
           DATA (ARRAY(I), I = PARR(1), 3) / PARR(1), PARR(2)*PARR(3) /

EDITS: None
SUBMITTED BY: Larry Rolison
HISTORY: 94-302 m131 submitted, with proposed response
         94-360 m131 alternate answer proposed, failed 7-7
         94-302 m131 original answer, approved 14-2
         95-034 m132 X3J3 ballot failed 15-5

----------------------------------------------------------------------

NUMBER: F90/000191
TITLE: Interaction of SEQUENCE derived types and rename
KEYWORDS: SEQUENCE, derived type, use association, derived type
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION:  Consider the following:

   MODULE M
     TYPE T
       SEQUENCE
       TYPE (T), POINTER :: P
     END TYPE
   END MODULE

   USE M, T2=>T
   TYPE T
    SEQUENCE
       TYPE (T2), POINTER :: P
   END TYPE
   TYPE (T) X
   TYPE (T2) Y
   X = Y
   END

Section 4.4.2, 'Determination of derived types', seems to indicate that
types T
and T2 in the main program refer to the same type.  Note that both types
have
structure components that agree in order, name, and attributes.  However,
considering type T in the context of module M only, type T is a derived type
that contains one component that is a pointer to itself.  In the context of
the
main program, type T is a derived type that contains one component that is a
pointer to a different derived type.

Are types T and T2 considered to be the same type?

ANSWER:  Yes, T and T2 are the same type.  An edit is provided to clarify
this
conclusion.

Discussion: The first sentence in section 4.4.2 states, "a particular type
name
may be defined at once in a scoping unit." However, by the use of rename,
it's
possible for a scoping to have access to two separately defined derived
types,
that were originally defined the same name, by two different local names.
For
derived types made accessible by use association, the derived type name
referred
to in section 4.4.2 is <type-name> in the corresponding <derived-type-stmt>.
Edits are provided to clarify this.

EDITS:
1.  In section 4.4.2, add the following to the end of the first paragraph:
    [35:39]

     "In addition, two derived types accessible in the same scope might be
the
      same if one or both are accessible by use association."

2.  In section 4.4.2, after the second paragraph, add the following
independent
    paragraph: [35:46]

     "Note that the criterion that the two types have the same name applies
     to the <type-name> of the respective <derived-type-stmt>."

SUBMITTED BY: Janice C. Shepherd
HISTORY: 94-273   m130 submitted
         94-377   m131 Response submitted, approved  u.c.
         95-034r1 m132 X3J3 ballot failed 15-5

----------------------------------------------------------------------

NUMBER: F90/000196
TITLE: Inaccessibility of intrinsic procedures
KEYWORDS: intrinsic procedure, INTRINSIC attribute, generic identifier,
  names class
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION: Section 14.1.2 states:

  "Note that an intrinsic procedure is inaccessible in a scoping
   unit containing another local entity of the same class and having
   the same name. For example, in the program fragment

  SUBROUTINE SUB
   ...
   A = SIN (K)
   ...
   CONTAINS
     FUNCTION SIN(X)
       ...
     END FUNCTION SIN
  END SUBROUTINE SUB

  any reference to function SIN in subroutine SUB refers to the
  internal function SIN, not to the intrinsic function of the same
  name."

Are the following two comments about this text correct?

(1) The example is not strictly correct because the resolution of the
procedure reference "SIN" depends on the contents of the first "...":

  (1a) If "..." does not contain an "INTRINSIC SIN" statement, the behavior
  is as specified: In SUB, the name SIN is established specific due to
  condition 14.1.2.4 part (2b), it is not established generic, and
  the internal function SIN is referenced due to 14.1.2.4.2 part (3).

  (1b) If "..." does contain an "INTRINSIC SIN" statement, SIN is
established
  specific as above, but also established generic due to condition
  14.1.2.4 (1b). So the reference is resolved according to 14.1.2.4.1
  part (2): the intrinsic function SIN is called.
  ( At least if there is a suitable specific function for data )
  ( object K. If not, the reference is resolved according to   )
  ( 14.1.2.4.1 (4) which also requires a consistent reference. )

(2) The first sentence of the cited text is wrong (incomplete), because it
does not consider the case of generic identifiers:

 * Intrinsic procedures are local entities of class (1).
 * Generic identifiers are local entities of class (1).
 * Various instances in the standard indicate that it is possible
   to extend the generic interface of intrinsic procedures.

Consequently, in the example

      MODULE my_sin
       CONTAINS
        LOGICAL FUNCTION lsin (x)
          LOGICAL, INTENT(IN) :: x
          ...
        END FUNCTION lsin
      END MODULE my_sin

      SUBROUTINE sub
        USE my_sin
        INTERFACE SIN
          MODULE PROCEDURE lsin
        END INTERFACE SIN
        ...
      END SUBROUTINE sub

the intrinsic procedure SIN remains accessible in SUB although that scoping
unit contains another local entity of class (1) named SIN.

ANSWER: Comment 1 is incorrect.  See the answer to (1b).

Comment 1a is correct.

Comment 1b is incorrect.

SIN is a local name for the internal procedure, which is a specific
procedure,
and adding an "INTRINSIC SIN" statement is prohibited by 14.1.2, 3rd
paragraph.

Comment 2 is correct.  Edits to remove the contradiction are included below.

EDITS:
1.In section 14.1.2, 4th paragraph [241:36], change
          "having the same name" in the first sentence
      to
          "having the same name, except when the other local entity
           and the intrinsic are both generic procedures"

2.In Section 14.1.2, 3rd paragraph [241:33], change
          "in the case of"
      to
          "when both are"

SUBMITTED BY: Michael Hennecke (hennecke@rz.uni-karlsruhe.de)
HISTORY: 95-252 m135 submitted
         95-281 m135 response WG5 approved (N1161)
         96-    m136 X3J3 ballot failed 16-0, possible error in 2nd edit,
                     WG5 approval removed. Barber edit applied

----------------------------------------------------------------------

NUMBER: F90/000197
TITLE: Relationship of NEAREST and SPACING
KEYWORDS: NEAREST, SPACING, "machine representable"
DEFECT TYPE:
STATUS: Passed by WG5 ballot

QUESTION: The example in the SPACING intrinsic function description
states:

  SPACING(3.0) has the value 2**(-22) for reals whose model is as
  at the end of 13.7.1.

The example in the NEAREST intrinsic function description states:

  NEAREST(3.0, 2.0) has the value 3 + 2**(-22) on a machine whose
  representation is that of the model at the end of 13.7.1.

Must the delta computed by NEAREST (the 2**(-22) shown in the
example) be the value SPACING would return if given the same (first)
argument as passed to NEAREST?

ANSWER:  No.

DISCUSSION:

The result of NEAREST depends on the characteristics of machine
numbers, whereas the result of SPACING depends on the characteristics
of model numbers.  If there are one or more machine numbers in
between two adjacent model numbers, the results of SPACING and
NEAREST will not be consistent with each other.

EDIT(S): None.

SUBMITTED BY: Larry Rolison
HISTORY: 95-030      m132   submitted
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Passed by J3 letter ballot
         WG5/N1428          Passed by WG5 ballot

----------------------------------------------------------------------

NUMBER: F90/000204
TITLE: Meaning of "same variable" description of MVBITS
KEYWORDS: MVBITS
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION: Section 13.13.74 states "TO ... may be the same
variable as FROM".  Given the following statements, which
pairs of variables are the same?

              INTEGER :: I(10), J(10)
              EQUIVALENCE (I,J)
              INTEGER, TARGET :: T(2:11)
              INTEGER, POINTER :: P1(:), P2(:)
              P1 => T
              P2 => T(2:11)

              I and I                P1 and T
              I(1) and I(1)          P1 and T(2:11)
              I(1:10) and I(1:10)    P2 and T
              I(1:1) and I(1:1:-1)   P2 and T(2:11)
              I and I(1:10)          P1 and P2
              I and J
              I(1) and J(1)
              I(1:10) and J(1:10)
              I(1:1) and J(1:1:-1)
              I and J(1:10)

ANSWER:

Discussion: <possible response in 95-253 item 85>

EDITS:

SUBMITTED BY: /jor in response to IBM public comments
HISTORY: 95-299 m135 submitted

----------------------------------------------------------------------

NUMBER: F90/000205
TITLE: Restrictions on EXTERNAL
KEYWORDS: EXTERNAL attribute, external subprogram
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION: Let the following two procedures not be contained within a
main program, a module, or another subprogram.  In this case they are
<<external subprogram>>s by the definitions of Fortran 90, section
2.2:

  SUBROUTINE subroutine_subprogram ( )
  ! ...
  END SUBROUTINE subroutine_subprogram

  FUNCTION function_subprogram ( )
    INTEGER :: function_subprogram
  ! ...
  END FUNCTION function_subprogram

They are also external procedures, since F90 section 2.2.3.1 (and
12.1.2.2) states that

   "An <<external procedure>> is a procedure that is defined by an
    external subprogram or by means other than Fortran."

External functions may be given the EXTERNAL attribute in form of an
<attr-spec> (R503), external procedures may be given the EXTERNAL
attribute by an <external-stmt> (R1207)  [F95: R1208].

QUESTION 1: Is it correct that the current definitions in F90 do
allow the EXTERNAL attribute to be specified for the name of the
external subprogram in which such a declaration is contained?  In
other words, is the following code standard-conforming?

  SUBROUTINE subroutine_subprogram ( )
    EXTERNAL subroutine_subprogram
  ! ...
  END SUBROUTINE subroutine_subprogram

  FUNCTION function_subprogram ( )
    INTEGER, EXTERNAL :: function_subprogram
  ! ...
  END FUNCTION function_subprogram

QUESTION 2: If the answer to question 1 is YES: was this the
intention, or should it be prohibited that an EXTERNAL attribute is
given to the name of an external subprogram by declarations within
that subprogram?

ANSWER:

1.  No, the EXTERNAL attribute may not be specified for the name of
an external subprogram within that subprogram.

2.  Not applicable.

DISCUSSION:

Appearance of a name as the <function-name> in a <function-stmt> or
the <subroutine-name> in a <subroutine-stmt>, that is not in an
<internal-subprogram-part> or a <module-subprogram-part>, explicitly
specifies that the name is that of an external procedure and has the
EXTERNAL attribute.

The second constraint in 5.1 states
   "An entity shall not be explicitly given any attribute more than
    once in a scoping unit."
Section 5.2 makes it clear that this applies to EXTERNAL statements.

Therefore, the EXTERNAL statements in the example are duplicate
specifications and so not standard-conforming.

EDIT: None.

SUBMITTED BY: Michael Hennecke (hennecke@rz.uni-karlsruhe.de)
HISTORY: 96-         m136   submitted
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: F90/000206
TITLE: Collating sequence inconsistencies
KEYWORDS: Collating sequence, ACHAR, CHAR, ICHAR
DEFECT TYPE:
STATUS: J3 consideration in progress

[F95 CD 36:28+] says that "A <<collating sequence>> is a one-to-one
mapping of the characters into the nonnegative integers such that
each character corresponds to a different nonnegative integer."

QUESTION 1:
Does this definition imply that the one-to-one mapping is dense?
That is, is there a requirement that if the default CHARACTER type
has <n> characters, the corresponding collating sequence maps to
0..<n>-1 ?

QUESTION 2:
If the answer to question 1 is NO: is it correct that the restriction
  0 <= i <= <n>-1
on argument I of the intrinsic procedure CHAR (13.14.19) is
inappropriate?

QUESTION 3:
If the answer to question 1 is NO: is it correct that the
description of the <<Result Value>> of the intrinsic procedure ICHAR
(13.14.45),
  0 <= ICHAR(C) <= <n>-1
is inappropriate?

QUESTION 4:
Shouldn't argument I of the intrinsic procedure ACHAR (13.14.2) be
restricted to the nonnegative integers?

ANSWER:

(1) No, the definition in isolation would not require a "dense"
    mapping.  However, in conjunction with the requirements on the
    CHAR and ICHAR intrinsic functions, the mapping is required to
    be "dense".
(2) No, they are part of the specification of the required mapping.
(3) No.
(4) No.  For characters that are not part of the ASCII character set,
    IACHAR  returns a processor-dependent value that need not be in
    the ASCII collating sequence.  ACHAR, being the inverse of
    IACHAR, should accept such values.

EDIT: None.

SUBMITTED BY: Michael Hennecke (hennecke@rz.uni-karlsruhe.de)
HISTORY: submitted Feb. 17, 1996    (first appeared in 96-006r2)
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: F90/000207
TITLE: Integer bit-model inconsistency
KEYWORDS: Bit manipulation procedures, models for integer data
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION: Is the following observation true?

[F90 185:last sentence of 13.5.7] and [WG5/N1176, 219:22+] says
``In particular, whereas the models are identical for w_{z-1}=0,
  they do not correspond for w_{z-1}=1 and ...''

This statement assumes r==2 in the model for integer data defined in
13.7.1, it is not true for general r. The above sentence should be
changed to something like

``In particular, whereas the models are identical for r=2 and
  w_{z-1}=0, they do not correspond for r/=2 or w_{z-1}=1, and ...''

ANSWER: Yes.

DISCUSSION:

We want to allow BCD machines to be able to do bit manipulation
efficiently, without requiring them to perform binary-decimal
conversions around each use of a bit manipulation intrinsic.  This
will necessarily lose the connection between the bit settings and
the values.

EDIT:

[219:23] Insert "r==2 and" at the beginning of the line, and
         Insert "r/=2 or" after "for".

SUBMITTED BY: Michael Hennecke (hennecke@rz.uni-karlsruhe.de)
HISTORY: submitted Mar. 12, 1996      (first appeared in 96-006r2)
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: F90/000208
TITLE: nonadvancing output followed by list directed output
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
    Section 10.8.2, last sentence.  If nonadvancing output is
    followed by list-directed output, is a blank required before
    the first character written?  (I assume that if the first
    character of the current record is not a blank, list-directed
    output is not required, though possibly permitted, to replace
    that character with a blank.)

ANSWER: No.

DISCUSSION:

If the list-directed WRITE does not start a new record before output
of the first list item, it need not output a blank.  [178:24] states
"each output record begins with a blank".

If the first character of the current record is not a blank, the
processor must ensure that compliance with [178:24] is achieved by
beginning a new record before the output of any list item.

EDIT: None.
SUBMITTED BY: Robert Paul Corbett (robert.corbett@Eng.sun.com)
HISTORY: submitted Mar. 13, 1996      (first appeared in 96-006r2)
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: F90/000209
TITLE: STOP|PAUSE in I/O statement
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
    Section 9.7.  May a function referenced in an I/O statement
    execute a STOP or PAUSE statement?  If STOP statements are
    permitted, what is the state of the file at the end of
    execution?
ANSWER:
EDIT:
SUBMITTED BY: Robert Paul Corbett (robert.corbett@Eng.sun.com)
HISTORY: submitted Mar. 13, 1996 (first appeared in 96-006r2)

----------------------------------------------------------------------

NUMBER: F90/000210
TITLE: nonadvancing write followed by list directed write
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
    If a program does a nonadvancing WRITE followed by a
    list-directed WRITE, must the list-directed WRITE write to the
    current record or may it start a new record?

    For what it's worth, CRI f90 starts a new record.

ANSWER:

The processor may start a new record whenever it deems it necessary,
subject to the restrictions at [177:34-36], which states
    "The processor may begin new records as necessary ..."
This includes at the beginning of a list-directed WRITE.

EDIT: None.

SUBMITTED BY: Robert Paul Corbett (robert.corbett@Eng.sun.com)
HISTORY: submitted Mar. 13, 1996      (first appeared in 96-006r2)
         WG5/N1404          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: F90/000211
TITLE: Multiple MODULE PROCEDURE specs
KEYWORDS: MODULE PROCEDURE, generic interface, USE association
DEFECT TYPE:
STATUS: J3 consideration in progress

WG5/N1176 (X3J3/96-007) says [194:21-23]:
"Constraint:
   A <procedure-name> in a <module-procedure-stmt> shall not be one
   which previously had been specified in any <module-procedure-stmt>
   with the same generic identifier in the same specification part."

QUESTION:

1. Is it correct that this constraint does not preclude the following?

    MODULE foo1
     INTERFACE generic_spec
      MODULE PROCEDURE proc1
     END INTERFACE
    CONTAINS
     SUBROUTINE proc1
     END SUBROUTINE proc1
    END MODULE foo1

    MODULE foo2
     USE foo1
     INTERFACE generic_spec
      MODULE PROCEDURE proc1
     END INTERFACE
    END MODULE foo2

   Although foo2 clearly violates the uniqueness conditions in 14.1.2.3,
   it seems that it does not violate a Constraint. (Actual compilers do
   not seem to detect this form of violation of 14.1.2.3 at compile-time.)

2. If the answer to (1) is YES, wouldn't it be sensible to extend that
   constraint to cases where a "previous" specification of <procedure-name>
   in a <module-procedure-stmt> with the same generic identifier in the
   specification part of an accessible module had occurred,
   _and_ that <procedure-name> and generic-spec have PUBLIC accessibility?

   Probably the wording might be quite complicated because of the
   possibility of <access-spec>s if FOO1 and <rename>s in FOO2,
   but the essence should be straightforward...

The situation in (1) is very similar to the following example, which _is_
detected as erroneous by the compilers I tried:

    MODULE foo1
    CONTAINS
     SUBROUTINE proc1
     END SUBROUTINE proc1
    END MODULE foo1

    MODULE foo2
     USE foo1, ONLY: proc1
     USE foo1, ONLY: proc2 => proc1
     INTERFACE generic_spec
      MODULE PROCEDURE proc1
      MODULE PROCEDURE proc2
     END INTERFACE
    END MODULE foo2

In both cases, the specific <procedure-name>s (and the <generic-spec>) are
accessible in MODULE foo2, and the interfaces are explicit anyway.

ANSWER:
EDIT:
SUBMITTED BY: Michael Hennecke (hennecke@rz.uni-karlsruhe.de)
HISTORY: submitted Apr. 12, 1996 (first appeared in 96-006r2)

----------------------------------------------------------------------

NUMBER: F90/000212
TITLE: EQUIVALENCE of Data Objects of Different Types or Kinds
KEYWORDS: EQUIVALENCE limitations
DEFECT TYPE:
STATUS: J3 consideration in progress

    Section 5.5.1 acknowledges that it is possible to construct equivalences
    between data objects of different types or kinds:
    "If equivalenced objects have differing type or type parameters, the
     EQUIVALENCE statement does not cause type conversion or imply
mathematical
     equivalence."  [56:35-36]

    However, section 5.5.1 also has severe restrictions on equivalences
between
    data objects of differing types and kinds.  Following rule R547, there
are
    a series of constraints.  Constraints 3 through 6 read:

    Constraint:  If an <equivalence-object> is of type default integer,
default
    real, double precision real, default complex, default logical, or
numeric
    sequence type, all of the objects in the equivalence set must be these
    types.

    Constraint:  If an <equivalence-object> is of type default character or
    character sequence type, all of the objects in the equivalence set must
be
    of these types.

    Constraint:  If an <equivalence-object> is of a derived type that is not
    a numeric sequence or character sequence type, all of the objects in the
    equivalence set must be of the same type.

    Constraint:  If an <equivalence-object> is of an intrinsic type other
than
    default integer, default real, double precision real, default complex,
    default logical, or default character, all of the objects in the
    equivalence set must be of the same type with the same kind type
parameter
    value.

    Question 1) Why are these constraints in the standard?  What useful
                purpose do they serve?  What problems do they prevent or
solve?

    Question 2) Could a standard-conforming processor relax or eliminate one
                or more of these constraints, as an extension, without
                sacrificing full conformance to the standard?

    Question 3) Can a data object of sequence derived type be equivalenced
to
                another data object of a different sequence derived type?

Assume that a processor has among its intrinsic types INTEGER (1) (8 bits),
INTEGER (2) (16 bits), and INTEGER (4) (32 bits).  Given the following
definitions, is the EQUIVALENCE statement standard conforming?

TYPE T1
    SEQUENCE
    INTEGER (1) I1_ARRAY (36)
END TYPE

TYPE T4
    SEQUENCE
    INTEGER (4) I4_ARRAY (9)
END TYPE

TYPE (T1) OBJECT_1
TYPE (T4) OBJECT_4

EQUIVALENCE (OBJECT_1, OBJECT_4)

    Question 5) Can an object of sequence derived type be equivalenced to an
                array of intrinsic type?

Assume the definitions of question 3.  Is the following EQUIVALENCE
statement standard conforming?
INTEGER (4) :: I4_ARRAY_9 (9)

EQUIVALENCE (OBJECT_1, I4_ARRAY_9)

    Question 6) Can an object of sequence derived type be equivalenced to a
                scalar of intrinsic type?

ANSWER:
EDIT:
SUBMITTED BY: Craig Dedo (Craig.Dedo@mixcom.com)
HISTORY: submitted Jan. 23, 1996 (first appeared in 96-006r2)

----------------------------------------------------------------------

======================================================================
Part 4: Interpretation Requests of Japan
======================================================================

NUMBER: JP-04
TITLE: Construction of derived-type values
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-4)
  4.4.4 Construction of derived-type values
  Before NOTE 4.34:

  "Where a component in the derived type is a pointer, the
   corresponding constructor expression shall evaluate to an object
   that would be an allowable target for such a pointer in a pointer
   assignment statement(7.5.2)."

  Change `an object' to `a result value'.  A value of an expression
  can not be an object, by definition.

ANSWER:   Agreed.

EDIT: [45:8] Replace "an object" by "a result value".

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: JP-05
TITLE: Construction of array values
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-5)
  4.5 Construction of array values,

  "The ac-do-variable of an ac-implied-do that is in another
   ac-implied-do shall not appear as the ac-do-variable of the
   containing ac-implied-do."

  This sentence should be a Constraint.

ANSWER:   Agreed.

EDIT:
[45:36+] Add:
"Constraint:  The ac-do-variable of an ac-implied-do that is in
 another ac-implied-do shall not appear as the ac-do-variable of the
 containing ac-implied-do."

[46:3-5] Delete the sentence "The ac-do-variable ... ac-implied-do.".

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: JP-06
TITLE: Type declaration statements
KEYWORDS: Object name, Type declaration
DEFECT TYPE: Erratum
STATUS: Passed by J3 meeting

QUESTION:

JP-6)
  5.1 Type declaration statements

  As for the 16th and 19th constraint after R506:

  the 16th [48:25]:
  "Constraint: The function-name shall be the name of an external
   function, an intrinsic function, a function dummy procedure, or a
   statement function."

  Because the syntactic class `object-name' is only defined as a
  `name' in the standard, the following constraint should be added
  here:
  Constraint: The object-name shall be the name of a data object.
  [48:26+]

  After that, in the 19th [48:31]:
  "Constraint: initialization shall not appear if object-name is dummy
   argument, a dummy argument, a function result, an object in a named
   common block unless the type declaration is in a block data program
   unit, an object in blank common, an allocatable array, an external
   name, an intrinsic name, or an automatic object."

  In the above, `a function result,' should be removed.

  If we can not add the constraint above, `a statement function'
  should be added in the 19th constraint.

DISCUSSION:

There is a typographical error in the quoted 19th constraint in the
question in that "dummy argument" appears twice.

ANSWER:

Yes, we agree that the constraint above should be added.
However, the 19th constraint should not be modified since
a function result is a data object that cannot be initialized.

EDIT:

  [48:26+] Add:
           "Constraint: The object-name shall be the name of a data
            object."

SUBMITTED BY: Japan

HISTORY: 99-208        Submitted
         99-221        Classed as Fortran 95 Interpretation.
         WG5-N1411     draft answer
         01-151r1 m156 Passed unanimously by J3 meeting

----------------------------------------------------------------------

NUMBER: JP-08
TITLE: Type declaration statements
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-8)
  5.1 Type declaration statements

  After NOTE 5.3 [49:8]:

  "If a length-selector (5.1.1.5) is a nonconstant expression, ..."

  Change `length-selector' to `char-selector', `char-len-selector' or
  `character-length'.

ANSWER:  Agreed, but with 'char-length' as the substitute text.
EDIT:
[49:5] Replace "length-selector" by "char-length or
       char-len-param-value".

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: JP-12
TITLE: Bounds of each dimension of an array pointer
KEYWORDS:
DEFECT TYPE:
STATUS: Passed by WG5 ballot

QUESTION:
JP-12)
  5.1.2.4.3 (2) after R518 (Page 55  Line 41) states that:

  "(2) They are specified in a pointer assignment statement. ..."

  In this description, the term "pointer assignment statement" should
  be changed to "pointer assignment".

  Reason : The bounds of each dimension of an array pointer may be
  specified not only in a pointer assignment statement but also in a
  derived-type intrinsic assignment statement with a component of an
  array pointer.

ANSWER:   Agreed

EDIT:
[55:41] Delete "statement" and replace "in a" with "by".

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Passed by J3 letter ballot
         WG5/N1428          Passed by WG5 ballot

----------------------------------------------------------------------

NUMBER: JP-16
TITLE: Multiple occurrence of namelist-group-name in NAMELIST
       statement
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-16)
  5.4 2nd paragraph after R545 and constraints (Page 66  Line 11)
  states that:

  "Any namelist-group-name may occur in  more than one NAMELIST
   statement in a scoping unit."

  Can a namelist-group-name occur more than once in one NAMELIST
  statement ?

  Is the following NAMELIST statement standard conforming ?

     NAMELIST /NLIST/ A, B   /NLIST/ C, D

  If this is standard conforming, is it the same as the
  following ?

     NAMELIST /NLIST/ A, B, C, D

ANSWER:    Yes, the rules should be analogous to those for named
           common blocks at [69:16-19].

EDIT:
[66:11]  Replace "in more than one" by "more than once in one or
         more"
[66:11]  Replace "statement" by "statements"

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: JP-17
TITLE: Multiple occurrence of namelist group object in namelist group
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-17)
  5.4 3rd paragraph after R545 and constraints states that:

  "A namelist group object may be a member of more than one
   namelist group."

  Can a namelist group object occur more than once in one
  namelist group?

  Is the following NAMELIST statement standard conforming?

        NAMELIST /NLIST/A,B,A

ANSWER:       No.

EDIT:
[66:14]  Add new sentence at the end of the line:
         "A namelist group object shall not appear more than once in
          a single namelist group."

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot

----------------------------------------------------------------------

NUMBER: JP-24
TITLE: The bnf term shared-term-do-construct
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-24)
  In 8.1.4.2, second constraint below R833 states that:

  "The do-term-shared-stmt shall be identified with a label
   and all of the label-do-stmts of the shared-term-do-construct
   shall refer to the same label."

  This implies a label-do-stmts of the outer-most outer-shared-
  do-construct will permit not to refer to the same label, because
  shared-term-do-construct does not include outer-most outer-
  shared-do-construct.

  So the term "shared-term-do-construct" should be changed to
  "inner-share-do-construct and outer-shared-do-construct."

DISCUSSION:  There is a typographical error in the question - "8.1.4.2"
should read "8.1.4.1.2".

The following amplification of the question was provided at the August
2000 WG5 meeting:

The present BNF does not preclude the following as a single construct:

do 10 i=1,5     ! outer
 do 20 j=1,5    ! outer
  do 20 k=1,5   ! outer
   do 20 l=1,5  ! inner
     ...
20 continue     ! shared

ANSWER:      Agreed.  There is a minor typo in the suggested replacement
text.
EDIT:    [127:29.5] Replace "shared-term-do-construct" by
         "inner-shared-do-construct and outer-shared-do-construct".

         {The intention is to alter the second line of the second constraint
         following R833.  The line numbering is awry in the F95 copy being
         used.}

SUBMITTED BY: Japan
HISTORY: 99-208 Submitted
         99-221 Classed as Fortran 95 Interpretation.
         WG5-N1411 draft answer

----------------------------------------------------------------------

NUMBER: JP-31
TITLE: Signs of literal constants
KEYWORDS:
DEFECT TYPE:
STATUS: J3 consideration in progress

QUESTION:
JP-31)
  The fourth sentence of 10.8 and sixth sentence of 10.9:

  "Each value is either a null value or one of the forms:
        c
        r*c
        r*
   where c is a literal constant or a nondelimited character constant
   and r is an unsigned, nonzero, integer literal constant."

  "a literal constant" should be "an optionally signed literal
  constant"

ANSWER: Add the phrase, "if integer or real" to that last phrase
        above.

EDIT:
[175:5]  Replace "constant or" by "constant, optionally signed if
         integer or real, or"
[178:40] Replace "constant or" by "constant, optionally signed if
         integer or real, or"

Note for F2000:  The phrase "literal constant" [73:34] in F95 is not
                 the BNF term <lit-constant> but F95 doesn't say if
                 "literal constant" is signed.

SUBMITTED BY: Japan
HISTORY: 99-208             Submitted
         99-221             Classed as Fortran 95 Interpretation.
         WG5-N1411          Draft answer
         00-260      m154   Passed by J3 meeting
         00-329      m155   Failed J3 letter ballot
