To: J3                                                     J3/25-175
From: generics
Subject: Miscellaneous edits to incorporate templates
Date: 2025-September-29
References: 25-007r1, 25-135r2, 25-136r2, 25-172, 25-173, 25--174, 25-140

1. Introduction
===============

This is the 6th of 6 papers that provide edits for the approved syntax
for templates. This paper describes various edits occurring outside the
new new clause introduced in papers 1-5 that are necessary to incorporate
the syntax and semantics for templates.

2. Misc edits for templates
===========================

Clause 3:  Terms and definitions
--------------------------------

[5:5+] Insert new glossary term:

  "3.7.2b
   [deferred argument association]
   association between an instantiation argument and a deferred
   argument (Sec. ???)"

[10:9+] Insert new glossary term

  "3.34.1
  [deferred constant]
  a deferred argument with the PARAMETER attribute"


[11:32+] Insert new glossary terms

  "3.46b
   [deferred argument]
   named entity that appears in a <deferred-arg-list> (R???) (Sec. ???)"

[17:18+] Insert new glossary term

  "3.85b
  [instantiation argument]
  entity that determines deferred argument association"


[24:3] 3.120 scoping unit: Change "or subprogram" to "subprogram,
       template construct, or requirement construct", such that the
       entire definition reads

   "BLOCK construct, derived-type definition, interface body, program
   unit (3.113), subprogram, template construct, or requirement
   construct, excluding all nested scoping units in it"


[27:12] 3.139 subprogram: Change "or subroutine-subprogram (R1537)" to
        ", subroutine-subprogram (R1537), templated-function-subprogram, or
        templated-subroutine-subprogram", such that the entire
        definition now reads:

        "<function-subprogram> (R1532), <subroutine-subprogram> (R1537),
        <templated-function-subprogram> (R???), or
        <templated-subroutine-subprogram> (R???)"


[32:16+] Insert new glossary term

  "3.151b
  [ultimately defined prior]
  an entity that is accessed by host association and whose definition
  appears before the scoping unit in which it is reference or is
  ultimately defined prior in the host scoping unit"

Clause 5: Fortran concepts
--------------------------


[44:20-28] In 5.1 High level syntax, extend R508
           specification-construct to include new syntax terms:
           <template>, <require-stmt>, <requirement> and
           <instantiation-stmt>, such that it now reads:

   "R508 <specification-construct> <<is>> <derived-type-def>
                                   <<or>> <enum-def>
                                   <<or>> <enumeration-type-def>
                                   <<or>> <generic-stmt>
                                   <<or>> <interface-block>
                                   <<or>> <parameter-stmt>
                                   <<or>> <procedure-declaration-stmt>
                                   <<or>> <other-specification-stmt>
                                   <<or>> <type-declaration-stmt>
                                   <<or>> <template>
                                   <<or>> <require-stmt>
                                   <<or>> <requirement>
                                   <<or>> <instantiate-stmt>
   "

{ Allowing REQUIRE outside of templates is not something that has been
  discussed in plenary, but seems to be a natural thing to allow to
  generics subgroup.  It would provide a means for library developer
  to ensure that their product meets certain requirements without
  regard to any specific (external) template.}

[44:37-38] Extend R512 to include templated procedures such that it
           now reads:


   "R512 <internal-subprogram>
         <<is>> <function-subprogram>
         <<or>> <subroutine-subprogram>
         <<or>> <templated-subroutine-subprogram>
         <<or>> <templated-function-subprogram>"


* 5.3.2 Statement order

[48:1+] Update first line in table 5.1, to include TEMPLATE such that
        it now reads:

   "PROGRAM, FUNCTION, SUBROUTINE, MODULE, SUBMODULE, TEMPLATE, or
    BLOCK DATA statement."

[48:9+] Add a new column to Table 5.2 Statements allowed in scoping units,
with heading "Template".  The row entries are:

   "
     - USE                   Yes
     - IMPORT                Yes
     - ENTRY                 No
     - FORMAT                No
     - Misc. decl.s(1)       Yes (2)
     - DATA                  No
     - Derived-type          Yes
     - Interface             Yes
     - Executable            No
     - CONTAINS              Yes
     - Statement function    No
    "

[48:9+]  Add a new footnote to table 2:

    "(2) Only named constants may be declared in templates."

{Note: It is unfortunate that adding a new column may not readily fit
and that a substantial redesign of Table 2 may become necessary.}


[49:2] 5.3.3 The END statement: After "module subprogram", insert ",
       templated subprogram" such that the entire sentence reads:

       "Each program unit, module subprogram, templated subprogram,
       and internal subprogram shall have exactly one END statement."

[49:7] After "end-module-statement", insert ", end-template-statement,
       end-requirement-stmt" such that the sentence now reads:

        "The end-module-stmt, end-template-statement,
        end-requirement-stmt, end-submodule-stmt, and
        end-block-data-stmt statements are nonexecutable."

* 5.4.1.1 General

[51:27+]  After 5.4.1.3 Derived type, add a new subclause:

  "5.4.1.3+ Deferred type

  Deferred types are deferred arguments that are types in templates,
  templated procedures, or requirements.  Deferred types are described
  further in tt.xx."


Clause 6: Lexical tokens and source form
----------------------------------------

[62:4] 6.2.6 Delimiters
   Change  "or /)"  to  "/), {, or }." such that the entire sentence reads:

  "A lexical token that is a delimiter is
   a (, ), /, [, ], {, }, (/, or /)."


Clause 7: Types
---------------

[68:16-19] In section 7.3.2.1 Type specifier syntax, insert
           <deferred-type> in R702 <type-spec> such that it reads:

   " R702 <type-spec> <<is>> <intrinsic-type-spec>
       <<or>> <derived-type-spec>
       <<or>> <deferred-type>
       <<or>> <enum-type-spec>
       <<or>> <enumeration-type-spec> "

[68:20] In C703, after derived-type-spec, insert 'or deferred-type'
        such that it reads:

  "(R702) The <derived-type-spec> or <deferred-type> shall not specify
   an abstract type (7.5.7) except when it appears as an
   <instantiation-arg>."

[68:21-30] In R703 <declaration-type-spec> insert '<<or>> TYPE (
           <deferred-type> )' after 'derived-type-spec' such that R703
           now reads:

    "R703 <declaration-type-spec> <<is>> <intrinsic-type-spec>
       <<or>> TYPE ( <intrinsic-type-spec> )
       <<or>> TYPE ( <derived-type-spec> )
       <<or>> TYPE ( <deferred-type> )
       <<or>> TYPE ( <enum-type-spec> )
       <<or>> TYPE ( <enumeration-type-spec> )
       <<or>> CLASS ( <derived-type-spec> )
       <<or>> CLASS ( <deferred-type> )
       <<or>> CLASS ( * )
       <<or>> TYPE ( * )
       <<or>> TYPEOF ( <data-ref> )
       <<or>> CLASSOF ( <data-ref> )"

[68:31] Change C705 wording to be consintent with constraints just
        after it:

  "C705 (R703) CLASS(<derived-type-spec>) shall specify an extensible
  type (7.5.7)."

{This is just a wording change, but the original is so glaringly
different than the nigh identical constraint that follows, that
generics subgroup thought it should be updated.}

[68:34+] After C705, insert a new constraint:

   "C705+ (R703) CLASS(<deferred-type>) shall specify an extensible
    type (7.5.7)."

[69:1+] After C706 introduce a new constraint

   "C706+ (R703) TYPE(<deferred-type>) shall not specify an abstract type
   (7.5.7)."

[80:27+] In 7.5.2.1 Syntax of a derived-type definition, insert a new
         constraint on R728 after C737:

   "C737b (R728) <parent-type-name> shall not be a <deferred-type>."


Clause 8: Attribute declarations and specifications
---------------------------------------------------

[113:15] In 8.5.2 Accessibility attribute, in C817, insert "or
         template" after "module", so that it now reads:

  "C817 An access-spec shall appear only in the specification-part of a
       module or template construct."


[118:14] In 8.5.8.1 General, change the last entry for <array-spec>
     from:

            "<<or>> <assumed-rank-spec>"
     to
            "<<or>>   <assumed-or-implied-rank-spec>".

[118:19] Modify R818 to disambiguate lower and upper explicit bounds
         such that it reads:

 "R818 <explicit-shape-bounds-spec>
       <<is>> [ <lower-explicit-bounds-expr> : ]
                    <upper-explicit-bounds-expr>
       <<or>> <lower-bound> : <explicit-bounds-expr>
       <<or>> <explicit-bounds-expr> : <upper-bound>

[118:21+] After R818, insert new rules:

    "R818b <lower-explicit-bounds-expr> <<is>> <explicit-bounds-expr>
     R818c <upper-explicit-bounds-expr> <<is>> <explicit-bounds-expr>"

{If we omit <explicit-bounds-expr>, it means the upper bounds.  But
this complicates wording for a constraint that needs to distinguish
this case.}

[121:21] In 8.5.8.6 Implied-shape array, change "the constant-expr in
         its declaration" to "a constant expression".  Such that it
         now reads:

    "An implied-shape array is a named constant that takes its shape
    from a constant expression."

[121:21] After first sentence, insert new sentence:

     "If it is a deferred constant, it takes its shape from the
      associated instantiation argument, otherwise it takes its shape
      from the constant expression in its declaration."

{Note that this change is a bit larger than strictly necessary.  It is
needed for deferred constants, but it seems natural to include
ordinary constant here.}

[121:27-29] Delete the first sentence of p3 starting with "The extent
            of ...".

[121:30] Change name of section 8.5.8.7 from "Assumed-rank entity" to
         "Assumed-rank or implied-rank entities".

[121:30+] Insert new section heading: 8.5.8.7.1 "Assumed-rank entity"

[121:34] Modify text of the last sentence of p1 change
       "assumed-rank-spec" to "assumed-or-implied-rank-spec", such
       that it now reads:

   "An assumed-rank entity is declared with an <array-spec>
    that is an <assumed-or-implied-rank-spec>.


    R827 assumed-or-implied-rank-spec is ..

    C839 An assumed-rank entity shall be an associate name or a dummy
         data object that does not have the CODIMENSION or VALUE
         attribute.

    C840 An assumed-rank variable name shall not appear in a
         designator or expression except as an actual argument that
         corresponds to a dummy argument that is assumed-rank, the
         argument of the function C_LOC or C_SIZEOF from the intrinsic
         module ISO_C_BINDING (18.2), the first dummy argument of an
         intrinsic inquiry function, or the selector of a SELECT RANK
         statement.

    C841 If an assumed-size or nonallocatable nonpointer assumed-rank
         array is an actual argument that corresponds to a dummy
         argument that is an INTENT (OUT) assumed-rank array, it shall
         not be polymorphic, finalizable, of a type with an
         allocatable ultimate component, or of a type for which
         default initialization is specified.

[122:8+] Insert new section

    "8.5.8.7.2 Implied-rank entity

     An implied-rank entity is an entity whose rank becomes defined
     only within the instantiation of a template.  The following are
     implied-rank entities:

       - deferred constant declared with <assumed-or-implied-rank-spec>

       - variable, dummy argument, or deferred constant whose rank is
         declared to be a deferred integer, scalar constant expression

       - variable, dummy argument, or deferred constant whose shape is
         declared to be a deferred integer, rank-1 array expression.

{When SELECT GENERIC RANK appears for generic procedures, we will need
to integrate with templates so that it also works with implied-rank
entities.}

    NOTE

        The following are examples of implied-rank entities

        TEMPLATE EXAMPLE(C, S, N)
           DEFERRED INTEGER, PARAMETER :: S(*)
           DEFERRED INTEGER, PARAMETER :: C(..) ! implied-rank
           INTEGER, PARAMETER :: B(S) = 1       ! implied-rank
           REAL, PARAMETER, RANK(RANK(C)) :: D  ! implied rank
        END TEMPLATE

[127:3] In 8.5.17 RANK clause, in C864, replace "a dummy data object
        or" with "a named constant, a dummy data object, or" such that
        it now reads:

    "C864  An entity declared with a rank-clause shall be a named constant,
           dummy data object or have the ALLOCATABLE or POINTER attribute."

{This change is a bit larger than strictly necessary for generic
programming.  We only need to allow it for deferred constants, but it
seems natural to allow for ordinary named constants as well.}

[127:6] In p2, after "it is a deferred-shape array;" insert "
        otherwise, if it is a named constant, it specifies that it is
        an implied-shape array with all lower bounds equal to one;"
        such that the entire sentence reads:

    "If the rank is zero the entity is scalar; otherwise, if it has
    the ALLOCATABLE or POINTER attribute, it specifies that it is a
    deferred-shape array; otherwise, if it is a named constant, it
    specifies that it is an implied-shape array with all lower
    bounds equal to one; otherwise, it specifies that it is an
    assumed-shape array with all the lower bounds equal to one".

[128:36-37] In 8.6.1 Accessibility Statement, in constraint C873, after
            "a module", insert " or template" twice, such that the
            constraint reads:

  "C873 (R831) An <access-stmt> shall appear only in the
        <specification-part> of a module or template. Only one
        accessibility statement with an omitted <access-id-list> is
        permitted in the <specification-part> of a module or
        template."

[129:1-2] In constraint, C874, replace "or namelist group" with
          "namelist-group, requirement, or template" such that the
          entire constraint now reads:

   "C874 (R831) Each <access-name> shall be the name of a module,
         variable, procedure, nonintrinsic type, named constant,
         namelist group, requirement, or template."

[129:2+] Introduce new constraint:

   "C874+ (R831) <access-name> shall not be a deferred argument nor a
                 host associated entity."


[129:7] In second sentence of p1, insert "or template" after "in the
         module" in both locations such that the sentence now reads:

    "An access-stmt without an access-id list specifies the default
    accessibility of the identifiers of entities declared in the
    module or template, and of entities accessed from a module whose
    name does not appear in any access-stmt in the module or
    template."

[129:9] In last sentence of paragraph 1, insert "or template" after
         "in a module" such that the sentence now reads:

    "If no such statement appears in a module or template, the default
    is public accessibility."

[129:16] In first sentence of paragraph 2, insert "or template" after "in
       the module" such that the sentence now reads:

    "If an identifier is accessed by use association and not declared
    in the module or template, and the name of every module from which
    it is accessed appears in an access-stmt in the scoping unit, its
    default accessibility is PRIVATE if the access-spec in every such
    access-stmt is PRIVATE, or PUBLIC if the access-spec in any such
    access-stmt is PUBLIC.

[129:19+] Introduce a new paragraph after paragraph 2.

    "In a template, deferred arguments and entities accessed by host
     association do not have an accessibility attribute."


[136:30-32] In 8.7 IMPLICIT Statement, replace the last sentence of
            paragraph 3 with

   "If a mapping is not specified for a letter, the default mapping of
     - a program unit, or
     - an interface body outside a template scoping unit or templated
       subprogram
    is default integer if the letter is I, J, ..., or N and default real
    otherwise.

    If a mapping is not specified for a letter, the default mapping for
    a BLOCK construct, internal subprogram, or module subprogram is the
    mapping in the host scoping unit.

    The mapping for a template construct, a templated subprogram, or
    an interface body that appears within a template or templated
    subprogram is the null mapping.
   "

[139:7] In section 8.8 IMPORT Statement, in second sentence of p2,
        after "module procedure interface body", insert " or an
        interface body that appears in a deferred interface block."
        The sentence will then read:

    "This is the default for an interface body that is not a module
     procedure interface body or an interface body that appears in a
     deferred interface block."

[139:14] In sentence 2 of p4, replace "or submodule" with "submodule,
         or an interface body that appears in a deferred interface
         block", such that it now reads:

    "This is the default for a derived-type definition, internal
     subprogram, module procedure interface body, module subprogram,
     submodule, or an interface body that appears in a deferred
     interface block."

Clause 10: Expressions and  assignment
--------------------------------------

[187:4] In, 10.1.12 Constant expression remove " or" from end of item
        (14), and " or" to end of item (15) and then introduce a new
        item for deferred constant.  The lines should now read:

  (14) an ac-do-variable within an array constructor where each
       scalar-int-expr of the corresponding ac-implied-do-control is
       a constant expression,
  (15) a constant expression enclosed in parentheses, or
  (16) a deferred constant,

{This change is possibly not necessary.  Subgroup is not certain.}


Clause 11: Execution control
----------------------------

[225:17+] In section 11.1.11.1 Purpose and form of the SELECT TYPE
          construct, insert entry in R1156 type-guard-stmt:

  "<<or>> CLASS IS ( <deferred-type> ) [ <select-construct-name> ]"

Such that the entire rule becomes:

  "R1156 <type-guard-stmt>
      <<is>> TYPE IS ( <type-spec> ) [ <select-construct-name> ]
      <<or>> CLASS IS ( <derived-type-spec> ) [ <select-construct-name> ]
      <<or>> CLASS IS ( <deferred-type> ) [ <select-construct-name> ]
      <<or>> CLASS DEFAULT [ <select-construct-name> ]"

[226:9+] Add new constraint on R1156 type-guard-statement:

    "C1169b (R1156) <deferred-type> shall specify an extensible type."


Clause 14: Program units
------------------------

[326:12+] In 14.2.1 Module syntax and semantics, add the following
          lines to rule 1408 module-subprogram:

      "<<or>> <templated-function-subprogram>
       <<or>> <templated-subroutine-subprogram>"

  such that the rule now reads:

    "R1408 <module-subprogram>
              <<is>> <function-subprogram>
              <<or>> <subroutine-subprogram>
              <<or>> <separate-module-subprogram>
              <<or>> <templated-function-subprogram>
              <<or>> <templated-subroutine-subprogram>"

[327:2] In section 14.2.2 The USE statement and use assocation,
        replace ", and namelist groups" with " namelist groups,
        templates, and templated procedures" such that the entire
        sentence now reads:

    "The USE statement provides the means by which a scoping unit
    accesses named data objects, nonintrinsic types, procedures,
    abstract interfaces, generic identifiers, namelist groups,
    templates, and templated procedures in a module."


Clause 15: Procedures
---------------------

In 15.4.2.1 Interfaces and scopes insert a new bullet:

[333:24] Replace ", or" with "," at end of 2nd bullet.
[333:26] Replace "." with ", or" at end of 3rd bullet
[333:26+] Insert new bullet

       "an instantiation of a templated procedure, or a procedure
        accessed from the instantiation of a template."

[334:30+] In section 15.4.3.2 Interface block, in rule 1503
          interface-stmt, add a new line:

       " <<or>> DEFERRED INTERFACE"

such that the rule now reads:

    "R1503 <interface-stmt> <<is>> INTERFACE [ <generic-spec> ]
                            <<or>> ABSTRACT INTERFACE
                            <<or>> DEFERRED INTERFACE"

[335:23+] Introduce new constraint on rule 1503 interface-stmt:

      "C1503b Each <subroutine-name> or <function-name> of an
       <interface-body> that appears in a deferred interface block
       shall be the name of a deferred argument of the scoping unit in
       which the <interface-body> appears."

[336:2] In last sentence of p2, replace "with neither Abstract nor"
        with "without ABSTRACT, DEFERRED, or" such that the sentence
        now reads:

    "An interface block without ABSTRACT, DEFERRED, or a generic
     specification is a specific interface block."

[336:3+] Insert a new paragraph:

    "An interface block introduced by DEFERRED INTERFACE is a deferred
     interface block. An interface body in a deferred interface block
     specifies a deferred procedure."

[340:8+] In 15.4.3.4.5 Restrictions on generic declarations, insert 4
          new paragraphs and a note:


   "The kind of an entity is deferred if the kind depends on the value
    of a deferred argument or depends on a deferred attribute of an
    entity.

    An entity whose kind is deferred only has the same kind as another
    entity if the kind of both entities is declared with syntactically
    equivalent expressions where the declaration is either in the type
    declaration of the entity, or in default kind declaration.

    The rank of an entity is deferred if the rank depends on the value
    of a deferred argument or depends on a deferred attribute of an
    entity.

    An entity whose rank is deferred only has the same rank as another
    entity if:
      - both entities are declared with the RANK clause with
        syntactically equivalent expressions for the rank,
      - both are declared with syntactically equivalent <array-spec>s, or
      - one entity is declared with a RANKOF clause that references
        the other.
      - the two entities have the same rank as some other entity.

  NOTE Some examples of implied-rank entities are shown in the
       following example template. C is explicitly declared
       as implied-rank. B is implied-rank because its rank depends on
       the size of the deferred argument S. X, Y and Z are implied-rank
       because their ranks depend on the value of the deferred argument N.

    TEMPLATE EXAMPLE(C, S, N)
      DEFERRED INTEGER, PARAMETER :: C(..) ! implied-shape & implied-rank
      DEFERRED INTEGER, PARAMETER :: S(*), N
      INTEGER, PARAMETER :: B(S) = 1 ! explicit-shape & implied-rank
    CONTAINS
      SUBROUTINE SUB(X)
        INTEGER, RANK(N) :: X ! assumed-shape & implied-rank
        INTEGER :: Y([(i, i = 1, N)]) ! explicit-shape & implied-rank
        INTEGER, RANK(N), ALLOCATABLE :: Z ! deferred-shape & implied-rank
        call sub_explicit(C) ! valid, element order association
        ! call sub_assumed(C) ! invalid, rank expressions don't match
        ! call sub_same_rank(C) ! invalid, rank expressions don't match

        call sub_explicit(X) ! valid, element order association
        ! call sub_assumed(X) ! invalid, rank expressions don't match
        call sub_same_rank(X) ! valid, rank expressions match

        call sub_explicit(Y) ! valid, element order association
        ! call sub_assumed(Y) ! invalid, rank expressions don't match
        ! call sub_same_rank(Y) ! invalid, rank expressions don't match
      END SUBROUTINE
      SUBROUTINE SUB_EXPLICIT(X)
        INTEGER :: X(10)
      END SUBROUTINE
      SUBROUTINE SUB_ASSUMED(X)
        INTEGER :: X(:)
      END SUBROUTINE
      SUBROUTINE SUB_SAME_RANK(X)
        INTEGER, RANK(N) :: X
      END SUBROUTINE
    END TEMPLATE"

[344:19+] In section 15.5.1 Syntax of a procedure reference, append
          two new lines to R1522 procedure-designator:

      "  <<or>> <deferred-proc>
         <<or>> <inline-instantiation>"

  such that the rule now reads:

   "R1522 <procedure-designator> <<is>> <procedure-name>
                                 <<or>> <proc-component-ref>
                                 <<or>> <data-ref> % binding-name
                                 <<or>> <deferred-proc>
                                 <<or>> <inline-instantiation>"

[355:5+] Extend R1524 <actual-arg> with <deferred-proc> and
         <inline-instantiation> such that it now reads:

   "R1524 actual-arg <<is>> <expr>
                     <<or>> <variable>
                     <<or>> <procedure-name>
                     <<or>> <proc-component-ref>
                     <<or>> <conditional-arg>
                     <<or>> <alt-return-spec>
                     <<or>> <deferred-proc>
                     <<or>> <inline-instantiation>"

[363:15+] In section 15.6.2.1 General, append new line to R1530
          prefix-spec:

    " <<or>> TEMPLATE "

such that the entire rule now reads:

      "R1530 prefix-spec <<is>> declaration-type-spec
                         <<or>> ELEMENTAL
                         <<or>> IMPURE
                         <<or>> MODULE
                         <<or>> NON_RECURSIVE
                         <<or>> PURE
                         <<or>> RECURSIVE
                         <<or>> SIMPLE
                         <<or>> TEMPLATE


[363:33+] Insert new constraint on R1530:

     "C1560b (R1530) TEMPLATE shall not appear except in a
              <templated-function-stmt> or a
              <templated-subroutine-stmt>."


[365:11] In section 15.6.2.2 Function subprogram, in C1573, after "in
         the end-function-stmt" insert " in function-subprogram" such
         that the constraint now reads:

     "C1573 (R1536) If a function-name appears in the
      end-function-stmt in a function-subprogram , it shall be
      identical to the function name specified in the function-stmt."

[366:15] In section 15.6.2.3 Subroutine subprogram, in C1576, after
         "in the end-subroutine-stmt" insert " in
         subroutine-subprogram" such that the constraint now reads:

     "C1576 (R1540) If a subroutine-name appears in an
      end-subroutine-stmt in a subroutine-subprogram, it shall be
      identical to the subroutine-name specified in the subprogram's
      subroutine-stmt."

{Note: A rule is referenced in C1573 but not C1576.  This edit makes
this consistent.}

Clause 16: Intrinsic procedures and modules
-------------------------------------------

* 16.9.57 CO_REDUCE(A,OPERATION,...)

[410:24] After second sentence in Arguments paragraph, insert a new
         sentence:

      "It shall not be of a deferred type."

 such that the entire paragraph now reads:

     "A   shall not be polymorphic. It shall not be of a type with an
          ultimate component that is alloc atable or a pointer. It
          shall not be of a deferred type.  It shall have the same
          shape, type, and type parameter values, in corres ponding
          references. It shall not be a coindexed object. It is an
          INTENT (INOUT) argument.  If A is scalar, the computed value
          is the result of the reduction operation of applying OPERA
          TION to the values of A in all corresponding references. If
          A is an array, each element of the computed value is equal
          to the result of the reduction operation of applying
          OPERATION to corresponding elements of A in all
          corresponding references.  The computed value is assigned to
          A if no error condition occurs, and either RESULT_IMAGE is
          absent, or the executing image is the one identified by
          RESULT_IMAGE. Otherwise, A becomes undefined."

[576:17+] Insert new subclause:

     "19.5.1.2b Deferred argument association

         Deferred argument association is described in tt.xx.
     "


Annex A:
--------

* A.2 Processor Dependencies

[597:43] Replace final period "." with semicolon ";".

[597:43+] Append a new bullet in the list of processor dependencies

    * the names of the dummy arguments of a deferred procedure without
      an explicit specification (tt.8.2.4).

===END===
