
                                                         J3/04-364

Date:   17-Jul-2004
To:     J3 Members
From:   interp/Stan Whitlock
Subj:   F95 interp letter ballot #8 - due 16-Aug-2004


Enclosed is the eighth letter ballot on Fortran 95 interpretations.

The rules we operate by say:

    o   J3 votes on the answer at a J3 meeting; a simple majority

        vote marks the answer as "passed by J3 meeting".

    o   Between J3 meetings the chair of /interp sends a J3 letter

        ballot to J3 to approve interp answers that have been "passed

        by J3 meeting".  The letter ballot runs for 30 days.  Not

        voting on three of four consecutive J3 letter ballots is

        grounds to terminate J3 membership.  An interp answer passes

        by a 2/3rds vote;  a no vote must be accompanied by an

        explanation of the changes necessary to change the member's

        vote to yes.


        J3/interp reserves the right to recall an interp answer for

        more study even if the answer passes.


23 Fortran 95 interpretations are currently "passed by J3 meeting"

after J3 meeting #168.  This is the letter ballot phase to go from

"passed by J3 meeting" to "passed by J3 letter ballot".  2 interps

below are either duplicates or subsumed by another interp and are

not part of this ballot but ae included here for completeness.


The following Fortran 95 interpretations are being balloted:


Yes   No    Number       Title

---   ---   000004     Value returned by MAXVAL/MINVAL

---   ---   000006     Character length specification of a function result

---   ---   000008     Optional arguments to MAX/MIN

---   ---   000017     Characteristics of an array function result

---   ---   000023     Termination of the previous record by a WRITE

                        statement

---   ---   000030     Ordering requirements on definition of

                        specification functions

SSS   SSS   000031     Association of pointer function result with

                        INTENT(OUT) dummy argument - subsumed by interp #74

---   ---   000068     Asterisks as I/O units

---   ---   000074     TARGET dummy arguments and POINTER expressions

---   ---   000078     Resolving generic procedure references

---   ---   000096     End-of-record and PAD

DDD   DDD   000098     Are dummy functions returning assumed-length

                        character legal? - duplicate of interp #6

---   ---   000102     mask-expr evaluated only once

---   ---   000103     Derived type name DOUBLEPRECISION

---   ---   000104     Representation method of result of REAL

---   ---   F90/000049 Characteristics of function results

---   ---   F90/000070 Characteristics specified by interface bodies

---   ---   F90/000096 Definition of "Declaration"

---   ---   F90/000140 TARGET attribute for a derived-type object with a

                        pointer component

---   ---   F90/000180 Unambiguous generic references

---   ---   F90/000206 Collating sequence inconsistencies

---   ---   F90/000207 Integer bit-model inconsistency

---   ---   F90/000208 nonadvancing output followed by list directed output

---   ---   F90/000210 nonadvancing write followed by list directed write

---   ---   JP-24        The bnf term shared-term-do-construct



The text of these interpretations is attached.  Each interpretation

starts with a row of "-"s.


Please mark the above -Y- in the Yes column for "yes", -C- in the Yes

column for "yes with comment", or -N- in the No column for a "no"

answer {be sure to include your reasons with "no"} and send only the

above text {not this entire mail message} with any comments to


        j3@j3-fortran.org


by 11:59:59PM, PDT, Monday, 16-Aug-2004, in order to be counted.  Ballots

before or during the next J3 #169 meeting 9-13-Aug-2004 would be appreciated.



Thanks                         /Stan



----------------------------------------------------------------------



NUMBER: 000004

TITLE: Value returned by MAXVAL/MINVAL

KEYWORDS: MAXVAL, MINVAL

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



The Result Value section of the MAXVAL intrinsic function description

uses the phrasing:



  or has the value of the negative number of the largest magnitude

  supported by the processor for numbers of the type and kind type

  parameter of ARRAY if ARRAY has size zero



This phrasing has generated at least the two following views on the

return value:



 * If the machine supports the IEEE standard then the implementation

   should return -inf.

 * For portability, the implementation should return -HUGE(ARRAY).



These views lead to the following questions:



1. Is the intent of the standard to describe the result in terms of

   machine values rather than model values?



2. If the answer to 1 is "yes", how are programmers expected to use

   this intrinsic function portably?



ANSWER:



1.   Yes.  Processors may support values that are not present in the

model of 13.7.1.  IEEE -inf is an example of such a number and this

may be returned on a machine that supports the IEEE standard.  If the

negative number of the largest magnitude in the model had been

intended, the model would have been mentioned as, for example, in the

definition of HUGE (13.14.39).



2.   A simple example of its use is to test whether a set of numbers

SET1 has a value greater than any value in the set SET2.  Consider

the expression MAXVAL (SET1) > MAXVAL (SET2).  If SET1 is empty and

SET2 is not, this value is correctly false even if all of the values

are outside the model with values less than -HUGE (SET1).



     All of the reduction functions (e.g., MAXVAL, SUM) return values

when the arguments are zero-sized arrays that may be the same as the

values returned for some non-zero-sized arguments.



NOTE:



The NO votes in 00-254 were concerned that IEEE Infinities are not model

numbers and are therefore not valid results for MINVAL and MAXVAL.  The

IEEE 754 standard is neither integrated into nor required by Fortran 95.

However concessions were made to allow some IEEE exceptional values to

be used by standard-conforming processors, like limited support for -0.0.



Fortran 2003 uses the same words in MAXVAL and MINVAL as in Fortran 95.



EDITS: None.



SUBMITTED BY:  Larry Rolison



HISTORY:  97-240    m143  submitted

          00-160r2  m153  Passed 7-5

          00-254    m154  Failed J3 letter ballot

          04-298r1  m168  Passed J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000006

TITLE: Character length specification of a function result

KEYWORDS: character, function result

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Consider the following program:



      PROGRAM main

      CHARACTER(8) arg, func

      EXTERNAL func

      CALL sub(arg, func)

      END PROGRAM



      SUBROUTINE sub(arg, func)

      CHARACTER(*) arg, func

      CHARACTER(8) str

      str = func(arg)

      ...

      END SUBROUTINE



      CHARACTER(8) FUNCTION func(arg)

      CHARACTER(*) arg

      ...

      END FUNCTION



Some implementations reject the reference to FUNC in subroutine SUB

and some do not.  The implementations that do not reject the reference

to FUNC use essentially the following as the argument for allowing

the reference:



  The rules for when an asterisk can be used to specify character

  length are specified in section 5.1.1.5 (middle of page 51 of

  the Fortran 95 standard).



    * The first rule states that an asterisk may be used to declare a

      dummy argument of a procedure.  It is clear that FUNC is a

      dummy argument of SUB.



    * The third rule says that in an external function, the length of

      the result may be specified within the function itself with an

      asterisk but if the result length is so specified, any invoker

      of the function must specify the character length of the

      function result as something other than an asterisk.  But the

      function that is being invoked in the above example does not

      declare its result length using the asterisk, so this rule does

      not apply.



Is the above sample program a standard conforming program with

respect to the concept of declaring the function result length in the

invoking program as an asterisk?



ANSWER:



Yes. When item (1) on page 51 is applied to the argument func of sub,

it tells us that its length is 8 for the call from the main program.



NOTE:



The NO votes in 01-380 raised the concern that this answer introduced a

binary incompatibility with FORTRAN 77.  FORTRAN 77 features continue to

work in Fortran 95;  Fortran 95 features may not always work in FORTRAN 77.



EDITS: None



SUBMITTED BY: Larry Rolison



HISTORY: J3/97-242  m143  submitted

         WG5-N1456        Draft answer

         01-305r1   m158  Passed by J3 meeting

         01-380     m159  Failed J3 letter ballot

         04-299r1   m168  Passed J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000008

TITLE: Optional arguments to MAX/MIN

KEYWORDS: intrinsic function, MAX, MIN, optional, argument

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



It appears that there is a missing "optional" in the description of

the optional arguments [, A3, ...] in the MAX and MIN functions.  In

the Fortran 90 standard, the MAX/MIN descriptions said "optional

arguments.  A3, ...", but those words do not appear 13.14.64 of the

Fortran 95 standard.



Section 13.3 [217:27+] states



  ...optional arguments... are identified by the notation "optional"

  in the argument descriptions.



and goes on to describe another notation for the arguments that are

listed as optional.  But it doesn't say anything about arguments

given in [...] and NOT also listed as optional.



Suggested change to the argument descriptions for MAX and MIN:



Arguments.

A1, A2     shall both have the same type which shall be integer or

           real and they shall both have the same kind type parameter.



A3, ... (optional)  shall have the same type and kind type parameter

           as A1.



ANSWER:



There is an anomaly in the presentation of MAX and MIN but the intent

is clear, ie, dummy arguments A3 and beyond are optional.



EDITS:  None



NOTE:



The same descriptive form reported here in Fortran 95 appears in

Fortran 2003 for MAX and MIN.



SUBMITTED BY:  Larry Rolison / Dick Hendrickson



HISTORY: 97-245     m143  submitted

         04-300r1   m168  Passed J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000017

TITLE: Characteristics of an array function result

KEYWORDS: Characteristics, function

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



Sections 12.2.1.1 and 12.2.2 of the Fortran 95 standard define rules

for dummy arguments and function returns in the presence of explicit

interfaces that allow array bounds expressions to be evaluated on

either the calling side or the called side of a call.  The

interpretation provided for RFI 000049 on the X3J3 website clarifies

and reinforces the conditions that permit evaluation on either side

of the call.  The erratum published in the same file for RFI 000070

changes the semantics of dummy arguments.  The erratum does not

explicitly mention function results, but it might be considered to

imply a similar change to the semantics of function results.



The erratum provided for RFI 000070 refers to altered text for the

interpretation provided for RFI 000049.  The version of the

interpretation that appears in the file on the X3J3 website does not

contain the altered text.



The definition of characteristics of function results as stated in

Section 12.2.2 of the Fortran 95 standard permits more efficient

implementation of array-valued functions, at least for some

architectures, than the definition implied by the erratum provided

for RFI 000070.  For Sun, it is more efficient for the calling

routines to allocate space for array results than to have the called

routines allocate the space.  In order for the calling routine to

allocate space for an array result, it must know the size of the

array.  To determine the size of the array, it must evaluate the

array bounds expressions given in the explicit interface for the

function.



Section 12.2.2 of the Fortran 95 standard requires the values of the

nonconstant bounds expressions given in an explicit interface to be

the same as the values of the bounds expressions given in the

corresponding function definition.  Thus, the values of the

nonconstant bounds expressions used to determine the size of the

array result can be passed to the called routine, avoiding any need

for the called routine to re-evaluate those expressions. Because

Fortran 95 allows user-defined routines to appear in bounds

expressions, evaluating the bounds expressions more than once per

call could prove inefficient and confusing.



The change implied by the erratum provided for RFI 000070 would

remove the nonconstant bounds expressions from the characteristics of

function results. The shape would still be a characteristic, but the

same shape can be produced by many different values of the bounds

expressions.  Thus, the values of the nonconstant bounds expressions

used in the called routine may differ from the values of the

corresponding expressions in the explicit interface.



For example, consider the explicit interface



      INTERFACE

        FUNCTION FOO(F, G, H)

          INTERFACE

            PURE INTEGER FUNCTION F()

            END FUNCTION

            PURE INTEGER FUNCTION G()

            END FUNCTION

            PURE INTEGER FUNCTION H()

            END FUNCTION

          END INTERFACE

          CHARACTER*(F()) FOO(G():H())

        END FUNCTION

      END INTERFACE



The definition given in Section 12.2.2 of the Fortran 95 standard

requires the values of the length and bounds expressions in the

interface to be the same as the values of the corresponding length

and bounds expressions in the function definition.



Under the definition implied by the erratum provided for RFI 000070,

the shapes must match, but the values of the nonconstant bounds

expressions need not. Thus, the function definition might be



      FUNCTION FOO(F, G, H)

        INTERFACE

          PURE INTEGER FUNCTION F()

          END FUNCTION

          PURE INTEGER FUNCTION G()

          END FUNCTION

          PURE INTEGER FUNCTION H()

          END FUNCTION

        END INTERFACE

        CHARACTER*(F()) FOO(G()-1:H()-1)

        . . .

      END FUNCTION



In this case, the values of the bounds expressions used in the called

routine must be the values of the expressions specified in the

function definition, not the values of the expressions specified in

the interface block.



QUESTION:



If a bound of a function result array is not a constant expression,

is the exact dependence on the entities in the expression a

characteristic of the function result?



ANSWER:



No. According to Corrigendum 1, the correct statement is now:



"If a bound of a function result array is not an initialization

expression, the exact dependence on the entities in the expression is

a characteristic of the function result."



EDITS: None



REFERENCES: 95-006a, F90/000027, F90/000049 & F90/000070, 04-295,

N1416 (Corrigendum 1).



SUBMITTED BY:  Robert Paul Corbett



HISTORY: 98-114       submitted

         04-313 m168  Passed J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000023

TITLE: Termination of the previous record by a WRITE statement

KEYWORDS: Nonadvancing, Record termination, WRITE

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Suppose a sequential formatted file is positioned within a record as

a result of a nonadvancing READ.



1. If the next operation performed on the file is a WRITE, can the

   current record be terminated at its current position before the

   next record is written?  Section 9.2.1.3.2 appears to preclude the

   record from being terminated, but at least one Fortran 90

   implementation does the record in such an instance.



2. If next operation is a nonadvancing WRITE and the number of

   characters written does not extend to the end of the current

   record, are the remaining characters at the end of the record

   preserved?



ANSWER:



1. No.  If the current record were to be terminated, the file

   position would be changed.  Section 9.2.1.3.2 [136:37-39] states:

   "For sequential access on input, if there is a current record, the

   file position is not changed.  Otherwise, the file is positioned

   at the beginning of the next record and this record becomes the

   current record."



2. Yes.  The remaining characters in the record are preserved.



   Consider the following different, but related, example:



        program write_write

        write (10,"(a,t1,a,a)") "XXXXXXXXX", "ABC", "DEF"

        write (10,"(a,t1,a)",advance='no') "XXXXXXXXX", "ABC"

        write (10,"(a)") "DEF"

        end



   The output from this program is



        ABCDEFXXX

        ABCDEFXXX



   From the description of Position editing (10.6.1) it is clear

   that the output following the tab does not cause the deletion

   of the final XXX characters from the record.  The fact that the

   second output record is created by a non-advancing write

   followed by an advancing write is not operationally different

   from the single advancing write that created the first record.



   The fundamental difference between this example and the question

   considered in the interp is the mechanism by which the current

   location in the record is established prior to the final

   advancing write statement. It would be inconsistent to have one

   case preserve previously existing characters in the record and

   the other case to require the opposite.  To avoid this

   inconsistency, the answer to Question 2 is Yes.



EDITS:  None



SUBMITTED BY: Robert Corbett



HISTORY:  98-155    m145  Submitted (part 1)

          WG5/N1410       Draft answer

          01-151r1  m156  Passed unanimously by J3 meeting

          01-224r1  m157  Failed J3 letter ballot

          04-301    m168  Passed J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000030

TITLE: Ordering requirements on definition of specification functions

KEYWORDS: Specification expressions, specification functions

DEFECT TYPE: Erratum

STATUS: Passed by J3 meeting



QUESTION:



Consider the following program unit.



      MODULE MOD

        INTERFACE INT

          MODULE PROCEDURE F1, F2

        END INTERFACE

      CONTAINS

        INTEGER PURE FUNCTION F1(I)

          INTEGER :: A(INT(1_4)), B(INT(1_2))    ! A(1), B(19)

          INTEGER, PARAMETER :: KIND = SIZE(A)   ! KIND == 1

          INTEGER(KIND), INTENT(IN) :: I



          F1 = 17

        END FUNCTION F1



        INTEGER PURE FUNCTION F2(J)

          INTEGER :: C(INT(2_4))                 ! C(2)

          INTEGER, PARAMETER :: KIND = SIZE(C)   ! KIND == 2

          INTEGER(KIND), INTENT(IN) :: J



          F2 = 19

        END FUNCTION F2

      END MODULE MOD



In processing the references to "INT(1_4)" and "INT(1_2)" in F1, the

processor needs to determine whether the references are to the

intrinsic function, INT, or to one of the specific procedures, F1 or

F2.  Determining that requires the processor to have determined the

kind type parameter of the dummy argument J, of F2.  In turn, that

requires the processor to determine whether the reference to

"INT(2_4)" is a reference to the intrinsic function, INT, or to one

of the specific procedures, F1 or F2.  Determining that requires the

processor to determine the kind type parameter of the dummy argument

I, which requires it to determine that "INT(1_4)" in F1 was a

reference to the intrinsic function INT.



After all this is determined, the processor can determine that the

reference to "INT(1_2)" in the declaration of B in F1 is a reference

to the specification function F2.



According to 7.1.6.1 [94:38-41],



     "If an initialization expression includes a reference to an

      inquiry function for a type parameter or an array bound of an

      object specified in the same <specification-part>, the type

      parameter or array bound shall be specified in a prior

      specification of the <specification-part>.  The prior

      specification may be to the left of the inquiry function in the

      same statement."



According to 7.1.6.2 [96:27-37],



     "A variable in a specification expression shall have its type and

      type parameters, if any, specified by a previous declaration in

      the same scoping unit, or by the implicit typing rules in effect

      for the scoping unit, or by host or use association.  If a

      variable in a specification expression is typed by the implicit

      typing rules, its appearance in any subsequent type declaration

      statement shall confirm the implied type and type parameters.



      If a specification expression includes a reference to an inquiry

      function for a type parameter or an array bound of an entity

      specified in the same <specification-part>, the type parameter

      or array bound shall be specified in a prior specification of

      the <specification-part>.  The prior specification may be to

      the left of the inquiry function reference in the same

      statement.  If a specification expression includes a reference

      to the value of an element of an array specified in the same

      <specification-part>, the array shall be completely specified

      in prior declarations."



The rules regarding references to variables in a specification

expressions and initialization expressions require a strict

left-to-right, top-to-bottom ordering between specification and

inquiry.  Specification functions appear to be unrestricted in this

respect.



Assuming that the processor supports integers with kind type

parameters of 1, 2 and 4, was it the intent of the committee that the

program unit above should be standard-conforming?



ANSWER:



No, it is not the intent that the above program unit be standard

conforming.  The required complexity of implementation is not

justified.  The standard has no prohibition against it, but the

lack of such a prohibition was an oversight.  The edits below

correct this oversight.



EDITS:



Add the following new paragraph immediately before Note 7.14:



  If an initialization expression in a module includes a reference to

  a generic, that generic shall have no specific procedures defined

  in the module subsequent to the initialization expression.



Add the following new paragraph immediately before Note 7.16:



  If a specification expression in a module includes a reference to

  a generic, that generic shall have no specific procedures defined

  in the module subsequent to the specification expression.



SUBMITTED BY: Henry Zongaro



HISTORY: 98-176   m146 Submitted

         04-312R1 m168 Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000031

TITLE: Association of pointer function result with INTENT(OUT) dummy

       argument

KEYWORDS: Pointer association, dummy argument association, intent

          attribute

DEFECT TYPE: Interpretation

STATUS: Subsumed by interp #74



QUESTION:  Consider the following program.



      PROGRAM P

        INTEGER, TARGET :: T



        CALL SUB(FPTR())

      CONTAINS

        FUNCTION FPTR()

          INTEGER, POINTER :: FPTR



          FPTR => T

        END FUNCTION FPTR

        SUBROUTINE SUB(IO)

          INTEGER, INTENT(OUT) :: IO



          IO = 17

        END SUBROUTINE SUB

      END PROGRAM P



According to 12.4.1 [200:30-32],



    "If a dummy argument is not a pointer and the corresponding

     actual argument is a pointer, the actual argument shall be

     currently associated with a target and the dummy argument

     becomes argument associated with that target."



According to 12.4.1 [201:19-21],



    "If a dummy argument has INTENT(OUT) or INTENT(INOUT), the actual

     argument shall be definable."



According to 5.1.2.3 [53:29-31],



    "The INTENT(OUT) attribute specifies that. . . any actual

     argument that becomes associated with such a dummy argument

     shall be definable."



The definition of "definable" supplied in Annex A (the term does not

appear to be defined in normative text) is:



    "A variable is <<definable>> if its value may be changed by the

     appearance of its <name> or <designator> on the left of an

     <assignment statement>."



According to this definition, "definable" is a property of variables

only.  In the example above, the actual argument is not a variable.

However, the actual argument is pointer associated with an object

that is definable.  The text cited from 5.1.2.3 refers to the

"actual argument that becomes associated with the dummy argument",

but the first piece of text cited from 12.4.1 makes it clear that

when the actual argument is a pointer, it is the target with which

it is associated that becomes argument associated with the dummy

argument, and not the actual argument itself.



Was it the intent of the committee that this program should not be

standard-conforming?



ANSWER:



See the answer to interpretation #74.



EDITS: None



SUBMITTED BY: Henry Zongaro



HISTORY: 98-177      m146   Submitted

         WG5/N1414          Draft answer

         00-260      m154   Passed by J3 meeting

         00-329      m155   Failed J3 letter ballot

         01-200      m157   Passed by J3 meeting 10-2

         01-275      m158   Failed J3 letter ballot

                     m168   Subsumed by interp #74



----------------------------------------------------------------------



NUMBER: 000068

TITLE: Asterisks as I/O units

KEYWORDS: Asterisk, I/O, unit

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



Question:



1.   Does the Fortran 95 standard require the external unit

     corresponding to the I/O unit identified by an asterisk for

     input or output to be the same as the external unit identified

     by some fixed nonnegative integer value?



2.   Can the I/O unit identified by an asterisk for input or output

     correspond to more than one external unit?



3.   If the external unit identified by an integer value that

     corresponds to the I/O unit identified by an asterisk for input

     or output is closed, does that cause the I/O unit identified by

     an asterisk to become disconnected?



ANSWER:



     1.   No.



     2.   No.



     3.   Not addressed by Fortran 95.



DISCUSSION:



The submitter states:  At least one Fortran 95 implementation uses -1

as the value of the I/O unit identified by an asterisk.  A carefully

constructed INQUIRE statement can expose this value to the user.  Many

users expect I/O to the units identified by asterisks to continue to

work even after the corresponding units identified by integer values

have been closed.



     1.   There is no requirement in the standard that the asterisk

correspond to an external-file-unit; it is, however, permissible.



     2.   For the units identified by the asterisk, the text of

section 9.3.2 does not allow two or more units to be connected

simultaneously to the same file [139:8-9].



     3.   Fortran 95 does not specify the behavior in this instance.



REFERENCES:  ISO/IEC 1539-1:1997(E), Sections 9.3 and 9.4.4.2



EDITS:  None



SUBMITTED BY: Robert Corbett



HISTORY:  99-192    m150  Submitted

          99-215r1  m150  approved uc

          00-208    m153  passed by J3 letter ballot

          00-268    m154  Failed WG5 letter ballot (N1395 & N1403)

          WG5/N1452       Suggested revision (expanded discussion)

          01-296r1  m158  Passed by J3 meeting

          01-380    m159  Failed J3 letter ballot

          04-306r1  m168  Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000074

TITLE: TARGET dummy arguments and POINTER expressions

KEYWORDS: TARGET, POINTER, dummy arguments

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Consider the following program.



PROGRAM questionable

  REAL,TARGET :: x

  CALL s1(f(x))

  CALL s2(f(x))

  CALL s3(f(x))

CONTAINS

  FUNCTION f(a)

    REAL,POINTER :: f

    REAL,TARGET :: a

    f => a

  END FUNCTION

  SUBROUTINE s1(variable)

    variable = 42                  ! statement 1

  END SUBROUTINE

  SUBROUTINE s2(variable)

    INTENT(OUT) variable

    variable = 42                  ! statement 2

  END SUBROUTINE

  SUBROUTINE s3(targ)

    REAL,TARGET :: targ

    REAL,POINTER :: p

    p => targ

    PRINT *,ASSOCIATED(p,x)        ! statement 3

  END SUBROUTINE

END



Is this program standard-conforming, and if so, what value is

printed?



The real question is whether an expression argument that is a pointer

function reference is treated as a variable (data-object) argument

with the variable being the target of the pointer expression.  (Or

whether it is dereferenced as usual in the absence of POINTER dummy

arguments).



Re (statement 1), the question is whether VARIABLE is definable when

argument-associated with "F()".



Re (statement 2), if the previous answer was Yes (VARIABLE is

definable), then presumably it can be made INTENT(OUT).  A random

sample of 4 compilers revealed that they considered it not to be

definable.



Re (statement 3), the question is whether P is pointer-associated

with X, not pointer-associated with X, or processor-dependent.  Of

the same random sample 3 thought it was associated with X, 1 thought

not.



ANSWER:



1. The call to s1 is not standard conforming. 12.5.2.1 says:



'A dummy data object whose intent is not specified is subject to the

limitations of the data entity that is the associated actual

argument.  That is, a reference to the dummy data object may occur

if the actual argument is defined and the dummy data object may be

defined if the actual argument is definable.'



Here the actual argument is a function result, which is not

definable.  For example, it is not permitted on the left-hand side

of an assignment statement, since it is not a variable.  (Being

"defined" or "undefined" is fundamentally a concept that applies only

to variables.)



2. The call to s2 is not standard conforming. 12.4.1.1 says:



'If a dummy argument has INTENT(OUT) or INTENT(INOUT), the actual

argument shall be definable.'



Again the actual argument is a function result, which is not

definable.



3. The call to s3 is standard conforming and the pointer assignment

in s3 causes p and x to become associated. This may be deduced from

12.4.1.1, which says [200:38-42]:



'If the dummy argument has the TARGET attribute and is either scalar

or is an assumed-shape array, and the corresponding actual argument

has the TARGET attribute but is not an array section with a vector

subscript (1) Any pointers associated with the actual argument become

associated with the corresponding dummy argument on invocation of the

procedure ...'



EDITS: None.





SUBMITTED BY:  Malcolm Cohen



HISTORY: 99-198      m150   submitted

         WG5/N1414          Draft answer

         00-260      m154   Passed by J3 meeting

         00-329      m155   Failed J3 letter ballot

         04-311      m168   Passed by J3 meeting vote - alternate answer

                             removed



----------------------------------------------------------------------



NUMBER: 000078

TITLE: Resolving generic procedure references

KEYWORDS: INTENT(IN), NULLIFY

DEFECT TYPE: Erratum

STATUS: Passed by J3 meeting



QUESTION:



14.1.2.4 (Resolving procedure references) seems to fail to resolve

the following example.



Consider:

  INTERFACE sin

    CHARACTER FUNCTION sinch(c)

      CHARACTER,INTENT(IN) :: c

    END

  END INTERFACE

  PRINT *,sin(3.5)  ! Reference to which procedure?

END



According to rule (1)(a), SIN is established to be generic; thus

references are resolved by the rules in 14.1.2.4.1.



In 14.1.2.4.1:

   Rule (1) fails - the reference is not consistent with any

            specific interface in the interface block for SIN.

   Rule (2) fails for the same reason.

   Rule (3) fails because there is no INTRINSIC statement.

   Rule (4) fails because there is no host scoping unit.



Is this program legal?

How should the reference to the generic procedure be resolved?



ANSWER:



This program was intended to be valid.

The reference is to the intrinsic SIN.

An edit is supplied to clarify this.



DISCUSSION:



(1) INTERFACE OPERATOR(+) does not hide the intrinsic operator.

(2) CHARACTER SIN does not hide the intrinsic function.



Given that, it would seem perverse for

    INTERFACE SIN

to completely block the intrinsic.  Indeed, according to interp

F90/000054 the intrinsic is still accessible in this kind of

situation.



Furthermore, it is clear from the original version of Fortran 90 that

a user generic was not intended to hide the intrinsic.  This text was

modified by interpretation F90/000083 which allowed the user to

override an intrinsic function by providing a specific function with

the same argument characteristics.  The failure of the current

14.1.2.4.1 to resolve the above example was an inadvertent side-effect

of that change.



EDITS:



[279:36+] Append new paragraph

  "If (1), (2), (3) and (4) do not apply, the name is that of an

intrinsic procedure, and the reference is consistent with the

interface of that intrinsic procedure, then the reference is to that

intrinsic procedure."



SUBMITTED BY:  Malcolm Cohen



HISTORY:  99-202   m150 submitted

          04-296r1 m168 Passed J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000096

TITLE: End-of-record and PAD

KEYWORDS: End-of-record, PAD

DEFECT TYPE: Erratum

STATUS: Passed by J3 meeting



Subclause 9.4.3 specifies:



  If an end-of-record condition occurs during execution of a

  nonadvancing input statement, the following occurs: if the PAD=

  specifier has the value YES, the record is padded with blanks

  (9.4.4.4.2) to satisfy the input list item and corresponding data

  edit descriptor that require more characters than the record

  contains;



There appears to be a problem if a list item does not correspond to

exactly one edit descriptor.



QUESTION:



If an End-of-record condition occurs during execution of a

nonadvancing input statement and the PAD= specifier has the value YES



  (1) do enough blanks get supplied for the next data edit descriptor

      and whatever part of the list item corresponds to that edit

      descriptor, or

  (2) do enough blanks get supplied for the remainder of the list item

      and as many edit descriptors as necessary, or

  (3) do enough blanks get supplied to process the rest of the input

      list?



ANSWER:



The situation can only arise for list items of complex type, because list

items of derived type are processed as if their components had appeared as

list items -- see [149:8-10].  It is clear from text at [150:15] and

[153:13] that blanks are not supplied for more than one list item.  So the

answer to part (3) of the question is "no".  Since the texts at [150:15]

and [153:13] also refer to a single format item, this leaves the answer

to parts (1) and (2) of the question ambiguous: Is it one list item, or

one edit descriptor?



The answer is that enough blanks are supplied by the processor to satisfy

all of the edit descriptors for a list item.



EDITS:



97-007r2



[150:15] and [153:13-14]: Replace "corresponding data edit descriptor" by

"its corresponding data edit descriptors" twice.



03-007r2:



Fortran 2003 introduced the concept of an "effective list item," which

should be exploited to clarify this question.



[198:12] Replace "input item and its corresponding data edit descriptor"

by "effective input item and its corresponding data edit descriptors".



[218:6-7] Replace "input list item (9.5.3.4.2) and corresponding data

edit descriptor that requires" by "effective input item (9.5.2) and its

corresponding data edit descriptors that require".



SUBMITTED BY: Van Snyder



HISTORY:      01-340   m158   submitted

              04-303   m168   Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000098

TITLE: Are dummy functions returning assumed-length character legal?

KEYWORDS: DUMMY FUNCTION, ASSUMED-LENGTH CHARACTER

DEFECT TYPE: Interpretation

STATUS: Duplicate of interp #6



QUESTION: Are dummy functions returning assumed-length character

          legal?



Consider the following program:



        character*5 f

        external f

          call ss3(f)

        end

        subroutine ss3(ff)

        character*(*) ff, a*10

        external ff

          a = ff()//'99999999'

          print *, '<', a, '>'

        end

        function f()

        character*(*) f

          f = '123'

        end



The issue is the call to the dummy function 'ff' in subroutine 'ss3'.

Some compilers issue an error message. Others print the result:

 <123  99999>



There appear to be two relevant, contradictory passages in the F95

standard. Refer to section 5.1.1.5. <> means italics, [] means

obsolescent font.



The third constraint says "A function name shall not be declared with

an asterisk <char-len-param-value> [unless it is the name of the

result of an external function or the name of a dummy function.]



Before note 5.6 on the next page, the third bullet says:

(3) [In an external function, the name of the function result may be

specified with a character length parameter value of *; in this case,

any scoping unit invoking the function shall declare the function

name with a character length parameter value other than * or access

such a definition by host or use association. When the function is

invoked, the length of the result variable in the function is assumed

from the value of this type parameter.]



According to the standard, the use in the example program is legal,

because 'ff' is the name of a dummy function. But it seems clear that

the standard intended that the length of the variable returned by

a character function be known at compile time; it is not known in the

case where the function is a dummy function.



ANSWER:



See the answer to interpretation #6.



EDITS: None



SUBMITTED BY:  Larry Meadows



HISTORY:  02-157  m160  Submitted

                  m168  Duplicate of interp #6



----------------------------------------------------------------------



NUMBER: 000102

TITLE: mask-expr evaluated only once

KEYWORDS: WHERE

DEFECT TYPE: Erratum

STATUS: Passed by J3 meeting



QUESTION:



Is a mask-expr required to be evaluated in a WHERE such as:



      WHERE ( (/ .TRUE., .TRUE. /) )

        A = A + 1

      ELSE WHERE (MASKF())

        A = MAX

      END WHERE



where an optimizing compiler might notice that the ELSEWHERE

branch will never be executed ?



Page 112, line 38 says of the mask expression in ELSEWHERE statements



"The mask-expression is evaluated only once."



ANSWER:



No, it is not required to evaluate the mask-expr in a WHERE. An edit

is supplied to correct this oversight.



EDITS:



[112:30-31]  Change "only once" to "at most once"



[112:38]  Change "only once" to "at most once"



SUBMITTED BY: Matthijs van Waveren



HISTORY: 03-239  m165  Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: 000103

TITLE: Derived type name DOUBLEPRECISION

KEYWORDS: Derived type

DEFECT TYPE: Erratum

STATUS:           Passed by J3 meeting



QUESTION:



Consider:

  TYPE doubleprecision

    REAL x

  END TYPE



According to 4.4.1, the name of a derived type "shall not be the same as

the name of any intrinsic type defined in this standard" ([38:34-35]).

However, the intrinsic types are only "integer", "real", "complex",

"logical" and "character" (4.3, [31:2-4]).  Therefore this derived type

definition would appear to be allowed.



Was it intended to allow a derived type to be named DOUBLEPRECISION?



ANSWER:



No, this was not intended.  An edit is provided to correct this inadvertent

omission.



EDITS:



[38:34] Before "the same" insert "DOUBLEPRECISION or".

{This is the same as the edit to F2003 in 03-219.}



SUBMITTED BY: Malcolm Cohen



HISTORY:  03-242  m165  Passed by J3 meeting vote



-----------------------------------------------------------------------



NUMBER: 000104

TITLE:  Representation method of result of REAL

KEYWORDS: "Representation method" KIND REAL

DEFECT TYPE: Interpretation

STATUS: Passed byJ3 meeting



QUESTIONS:



Subclause numbers refer to 97-007r2.



The second and third sentences of subclause 4.3.1.2 are





       A processor shall provide two or more approximation methods that

       define sets of values for data of type real. Each such method has

       a representation method and is characterized by a value for a type

       parameter called the kind type parameter.





1. Does this imply that there is a one-to-one correspondence between kind

type parameter values and representation methods?



Since the second quoted sentence says "a value," not "some values,"

assume the answer to this question is "yes."



Subclause 7.1.4.2 specifies the type and kind type paramter value for the

result of an operation.



2. Is a processor allowed to use a representation method that corresponds

to a different kind type parameter value of the same type, or no kind

type parameter value, at least if neither the precision nor exponent

range of the different representation method is less than the one

specified in 7.1.4.2?



Subclause 7.1.4.1 specifies the type and kind type paramter value for a

variable.



3. Is a processor allowed to use a representation method that corresponds

to a different kind type parameter value of the same type, or no kind

type parameter value, at least if neither the precision nor exponent

range of the different representation method is less than the one

specified in 7.1.4.1?



Subclause 7.1.4.1 specifies the type and kind type parameter value for a

result of a function.



4. Is a processor allowed to use a representation method that corresponds

to a different kind type parameter value of the same type, or no kind

type parameter value, at least if neither the precision nor exponent

range of the different representation method is less than the one

specified in 7.1.4.1?



Subclause 13.14.28 specifies that the result of DBLE is the same as the

result of REAL with a KIND argument having the value KIND(0.0d0).



Subclause 13.14.88 specifies that the kind type parameter value of the

result of REAL is that specified by the KIND argument.



5. Is a processor allowed to use a representation method for the result

that corresponds to a different kind type parameter value of the same

type, or no kind type parameter value, at least if neither the precision

nor exponent range of the different representation method is less than

the one specified in 13.14.88?



ANSWER:



The answer to question 1 is yes, since each valid real kind type parameter value

characterizes a representation method for an approximation method (4.3.1.2).



Clause 1.4 says

   'This standard does not specify ...

   (6) The physical properties of the representation of quantities and the

   method of rounding, approximating, or computing numeric values on a

   particular processor,

   ...'

The processor is therefore free to use different precision for intermediate real

calculations, which answers all the other questions.



EDITS: None



SUBMITTED BY: Van Snyder



HISTORY:  04-283  m168  submitted

          04-307  m168  Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000049

TITLE: Characteristics of function results

KEYWORDS: characteristics, function result, ENTRY statement, exact

          dependence, association - partial, association - entry

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Given a character function with an ENTRY statement, both results must

have the same characteristics or be scalars without the POINTER

attribute and have identical length.  Therefore:



          FUNCTION FUN(M,N)

            CHARACTER (LEN=M+N)::FUN,ENT

            ...

            ENTRY ENT(M,N)

            ...

          END FUNCTION



is standard conforming.



Question 1:

          FUNCTION FUN(M,N)

            CHARACTER (LEN=M+N)::FUN

            CHARACTER (LEN=M+N)::ENT

            ...

            ENTRY ENT(M,N)

            ...

          END FUNCTION



Is the code above standard conforming?



Question 2:

          FUNCTION FUN(M,N)

            CHARACTER (LEN=M+N)::FUN

            CHARACTER (LEN=N+M)::ENT

            ...

            ENTRY ENT(M,N)

            ...

          END



Is the code above standard conforming?



Question 3:

          FUNCTION FUN(M)

            CHARACTER (LEN=M+M)::FUN

            CHARACTER (LEN=M*2)::ENT

            ...

            ENTRY ENT(M)

            ...

          END



Is the code above standard conforming?



Question 4: What is the meaning of the phrase "the exact dependence

on the entities" in section 12.2.2?



ANSWER:



Answer 1. Yes

Answer 2. Yes

Answer 3. Yes

Answer 4.  The sentence containing the phrase "the exact dependence

on the entities" in section 12.2.2 is intended to convey that in

those cases where the shape or character length type parameter is not

constant, the corresponding characteristic of the function result is

not a value but the way the value is determined when the procedure is

invoked.



Discussion: Only the mapping from program state to value is

significant, not the particular form in which that mapping is

expressed.



In question 3, for example, it is a characteristic of FUN and ENT

that their lengths are twice the value of M.  It is not required that

the expressions of this mapping be identical, only that they yield

the same results.  Thus, twice the value of M could be expressed as

M+M for FUN and as M*2 for ENT.



The phrase "the exact dependence on the entities in the expression is

a characteristic" is used to give the processor the freedom to

evaluate lengths and bounds in any convenient manner.  Since the

characteristics must be the same, the phrase implies, as a minimum,

that the expressions be algebraically equivalent and use the same

variables.  In an example such as:



            FUNCTION FUN(M)

            CHARACTER (LEN=M)::FUN

            CHARACTER (LEN=M + 0*K)::ENT

            ...

            ENTRY ENT(M, K)

            ...

            END



FUN and ENT do not have the same characteristics since their

dependence on "K" is different.  Indeed, if on entry to FUN the

length of FUN or ENT were evaluated using the expression for the

length of ENT the evaluation would fail since K is not associated

with a value.



Clearly, it can be extremely difficult to determine on a static basis

whether two expressions of a mapping are consistent, and there is no

requirement in the standard that this be done.  It would be possible

to check during execution that the values expressed are identical

each time such a procedure is invoked, but it is expected that a more

typical application of this requirement would be to assume that it

has been met and use one expression of this mapping as the basis for

computing attributes of all of the result variables.



REFERENCES: ISO/IEC 1539:1991 (E) section 12.2.2 & 14.6.3.3



EDITS:  None



SUBMITTED BY: Y. Yoshida, X3J3/92-051 (121-ADT-11) pp.-13



HISTORY: 92-109A m121 Approved 19-0

         92-313  m123 response to ballot comments and

                      approved by uc

         93-105       Revised in response to ballot comments

         93-152  m125 New edit, rejected

         94-059  m128 New edit,

         94-252  m130 New response without edits, approved u.c.

         94-306  m131 X3J3 ballot approved 18-1

         95-044  m132 WG5 ballot failed

         006Ar1  m168 Passed by J3 meeting vote as in 02-006Ar1



----------------------------------------------------------------------



NUMBER: F90/000070

TITLE: Characteristics specified by interface bodies

KEYWORDS: characteristics, array bounds, array shape, function result

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Section 12.3.2.2 indicates that an interface body specifies all of a

procedure's characteristics and that the characteristics must be

consistent with those in the procedure definition.  Are the following

code fragments standard conforming?



(a)      PROGRAM FRED

           INTERFACE

             SUBROUTINE SUB (ARR,J)

               INTEGER ARR(1:)

             END SUBROUTINE

           END INTERFACE

         INTEGER ARR(10)

         CALL SUB(ARR,2)

         END PROGRAM



         SUBROUTINE SUB(ARR, J)

           INTEGER ARR(J:)

           ...

         END SUBROUTINE SUB



(b)      FUNCTION C1( )

           CHARACTER(*) C1

           ...

         END FUNCTION C1

         FUNCTION C2(N)

           CHARACTER(N) C2

           ...

         END FUNCTION C2



         SUBROUTINE CALLER( )

           INTERFACE

             FUNCTION C1( )

               CHARACTER(*) C1

             END FUNCTION

             FUNCTION C2(N)

               CHARACTER(2) C2

             END FUNCTION

           END INTERFACE

           CHARACTER(5) CC

           CC=C1( )//C2(2)



ANSWER:



  (a)  This example is standard conforming.



  (b)  This example is not standard conforming.



Discussion:



(a) 12.2.1.1 states that the characteristics of a dummy data object

include its shape, and that if the shape is assumed then that is a

characteristic.  Section 2.4.5 states that the shape of an array is

determined by its rank and extent in each dimension (but not by its

bounds, 5.1.2.4.2).  Both the interface block for SUB and the

definition of SUB describe the shape of ARR as assumed, so they are

describing the same shape, and the program is standard conforming.



(b) Section 12.2.2 states that the characteristics of a function

include whether or not the function result value is a character of

assumed length.  So the interface body for function C1 must indicate

that C1 is of assumed length. However, item (3) in 5.1.1.5 indicates

that scoping units that invoke an external character function of

assumed length must have access to a declaration of the function name

with a length type parameter value other than *. This is explained in

Note 5.6, (which has been removed in Fortran 2003).



In addition, the interface for C2 does not conform to the standard as

the length of C2 specified as 2 is not consistent with the length

specified as N within the function definition.



[Possible F2003 edit: Reinstate Note 5.6 of Fortran 95 in B.2.5.

of Fortran 2003.]



REFERENCES: ISO/IEC 1539:1991 (E) sections 2.4.5, 5.1.1.5, 5.1.2.4.2,

            12.2.1.1, and 12.2.2.



EDITS: None



SUBMITTED BY: Graham Barber (a),  Janice Shepherd (b)

HISTORY: 92-264      Question (a) originally posed

         92-46       Question (b) originally posed in e-mail

         ui 48       (jw note)

         92-283      Response proposed

                m123 Approved by unanimous consent

         93-018      Response questioned by John Reid in

         93-103      Revised response proposed

                m124 Approved by unanimous consent

         93-111 m125 ballot, return to subgroup, Leonard comment,

                       coordinate with 0000049?

         94-060 m128 New edit in F90/000049 referenced

         04-295 m168 Passed by J3 meeting vote





----------------------------------------------------------------------



NUMBER: F90/000096

TITLE: Definition of "Declaration"

KEYWORDS: declaration, specification

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:  "Declaration" is a significant concept of Fortran 90.



Section 5 is titled "Data object declarations and specifications" and

what were in FORTRAN 77 "type statements" are now "type declaration

statements".  5.1.1 states



    "A type specifier specifies the type of all entities declared in

     an entity declaration list."



Nowhere, though, is there a definition of "declaration".



What does it mean, in Fortran 90, to "declare" something?



ANSWER:



That is correct, the standard does not define the term "declaration".  It is

used both in the sense of explicit specification, and of implicit declaration

via usage or context.  Both of these meanings fall within the normal English

meaning of the term.



The suggestion that the standard should define the term "declaration" may be

considered for a future revision of the standard.



EDITS: None.



SUBMITTED BY: Dick Weaver



HISTORY: 92-232  Submitted

         92-232r Draft response, withdrawn

         93-144 m125 unanimous consent

         93-255r1 m127 ballot failed 16-7

         94-103 m128 revised response, approved uc

         94-116 m129 X3J3 ballot failed 16-7

         94-223 m130 revised response

         94-335 m131 alternate response proposed, withdrawn

         04-309 m168 Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000140

TITLE: TARGET attribute for a derived-type object with a pointer

       component

KEYWORDS: POINTER attribute, TARGET attribute, structure, structure

          component

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Section 6.1.2 (page 63) states:



   "A structure component has the INTENT, TARGET, or PARAMETER

    attribute if the parent object has the attribute."



A constraint following R505 (page 40) states:



   "Constraint: If the POINTER attribute is specified, the TARGET,

    INTENT, EXTERNAL, or INTRINSIC attribute must not be specified."



This would seem to imply that a derived-type object with a pointer

component could not have the TARGET attribute. Though it is

informative, Annex C.4.6 (page 267) contains the following example:



       "TYPE CELL

                INTEGER :: VAL

                TYPE (CELL), POINTER :: NEXT_CELL

        END TYPE CELL

        TYPE (CELL), TARGET :: HEAD

        TYPE (CELL), POINTER :: CURRENT

        ...

        CURRENT => HEAD"



which allows the static head of a linked list or tree.  Does the

structure component HEAD % NEXT_CELL contradict the text cited above

from section 6.1.2 or the cited constraint following R505?



ANSWER:



No, the component reference does not contradict either the

constraint or the cited text from 6.1.2.  The cited text from 6.1.2 has been

clarified by F95 interpretation 000100.



Discussion: The constraints that follow a syntax rule, or a set of

syntax rules, are syntactic constraints and apply only to the syntax

rules they immediately follow.  Thus, the constraints that follow

rules R501 through R505 at the beginning of section 5 apply only to

those rules.  This means they apply only to type declaration

statements.  Since a derived type component is part of a derived type

definition (which is not a type declaration statement), the

constraints do not apply to derived type components.  The rule that

prevents an entity from having conflicting attributes when applied by

multiple specification statements is found in 5.2:



  "The combination of attributes that may be specified for a

   particular entity is subject to the same restrictions as for type

   declaration statements regardless of the method of specification."



EDITS: None.



SUBMITTED BY: J. Martin in response to email May 7, 1993 from

              Yukimasa Yoshida



HISTORY: 93-179  m125 canceled, interpretation number then reassigned

         93-181  m125 Response, Withdrawn to remove suggested edit.

         93-223r m126 Response proposed, approved uc

         93-255r1 m127 ballot failed 18-5

         94-339  m131 Revised response proposed, approved 14-2

         95-034r1 m132 X3J3 ballot failed 8-12

         95-033   m132 Revised response, straw vote on intent 5-2-7

         95-092   m132 Revised discussion, approved u.c.

         95-101   m133 X3J3 ballot failed 11-7

         04-310   m168 Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000180

TITLE: Unambiguous generic references

KEYWORDS: host association, generic name

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:



Consider the following example:



     SUBROUTINE S()



       INTERFACE GEN1

         FUNCTION F1(I)

         END FUNCTION

         FUNCTION F2(I,J)

         END FUNCTION

       END INTERFACE



       INTERFACE GEN2

         FUNCTION G1()

         END FUNCTION

         FUNCTION G2(I)

         END FUNCTION

       END INTERFACE



       CALL SS()



       CONTAINS



          SUBROUTINE SS()



             INTERFACE GEN1

               FUNCTION F3(I,J,K)

               END FUNCTION

               FUNCTION F4(II)

               END FUNCTION

             END INTERFACE



             INTERFACE GEN2

               SUBROUTINE G3()

               END SUBROUTINE

             END INTERFACE



              A = GEN1(1,2,3)  ! CALL TO F3

              A = GEN1(1,2)    ! CALL TO F2

              A = GEN1(1)      ! CALL TO F4

              CALL GEN2()      ! CALL TO G3

         END SUBROUTINE



      END



There are rules in section 14.1.2.3 that determine within a scoping

unit what procedures can have the same generic specification.  These

rules directly mention access of a generic procedure via use

association, but they make no mention of generic names accessed via

host association.



There is evidence that the rules in section 14.1.2.3 were not intended

to apply to generic interfaces accessed by host association.  Section

14.1.2.4.1 indicates that a call to a generic name can be resolved to

a generic name in the host if the scoping unit and the host scoping

unit both agree that the generic name is the name of a function or a

subroutine.  This indicates that in the example above, the definition

of 'GEN2' is valid, even though 'G1' and 'G2' are functions while 'G3'

is a subroutine.  If the rules set out in 14.1.2.3 were to apply then

the definition of 'GEN2' would be invalid.



Do the rules in 14.1.2.3 apply to generic procedures accessed via host

association?



ANSWER:



Yes. [277:12-14] explains that the rules apply for all accessible

generic interfaces, including those accessible by host association.

The example program is not valid.



EDITS: None.



SUBMITTED BY: Janice C. Shepherd



HISTORY: 94-239r3 m130 submitted with suggested answer, approved u.c.

         94-306   m131 X3J3 ballot, failed 15-4

             04-308r1 m168 Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000206

TITLE: Collating sequence inconsistencies

KEYWORDS: Collating sequence, ACHAR, CHAR, ICHAR

DEFECT TYPE: interpretation

STATUS: Passed by J3 meeting



[F95 CD 36:28+] says that "A <<collating sequence>> is a one-to-one

mapping of the characters into the nonnegative integers such that

each character corresponds to a different nonnegative integer."



QUESTION 1: Does this definition imply that the one-to-one mapping is

dense? That is, is there a requirement that if the default CHARACTER

type has <n> characters, the corresponding collating sequence maps

to 0..<n>-1 ?



QUESTION 2:

If the answer to question 1 is NO: is it correct that the restriction

  0 <= i <= <n>-1

on argument I of the intrinsic procedure CHAR (13.14.19) is inappropriate?



QUESTION 3: If the answer to question 1 is NO: is it correct that the

description of the << Result Value>> of the intrinsic procedure ICHAR

(13.14.45), 0 <= ICHAR(C) <= <n>-1 is inappropriate?



QUESTION 4: Shouldn't argument I of the intrinsic procedure ACHAR

(13.14.2) be restricted to the nonnegative integers?



ANSWER:



(1) Yes. In the context of Fortran the character collating sequence is

    an ordered list of the characters in the character set associated

    with a list of integers denoting the position of each

    corresponding character in the ordered list of characters. The

    position number 0 is associated with the first character in the

    list. As position numbers, the list of integer values is

    necessarily dense. These position numbers are referenced in the

    descriptions of the CHAR and ICHAR intrinsic functions. The

    position numbers may be, but are not necessarily, equivalent to

    the bit patterns used to represent the associated characters in

    the computer hardware.



(2) Moot because the answer to (1) is Yes.



(3) Moot because the answer to (1) is Yes.



(4) No.  For characters that are not part of the ASCII character set,

    IACHAR  returns a processor-dependent value that need not be in

    the ASCII collating sequence.  ACHAR, being the inverse of

    IACHAR, should accept such values.





EDITS: None.



SUBMITTED BY: Michael Hennecke (hennecke@rz.uni-karlsruhe.de)



HISTORY: submitted Feb. 17, 1996    (first appeared in 96-006r2)

         WG5/N1404          Draft answer

         00-260      m154   Passed by J3 meeting

         00-329      m155   Failed J3 letter ballot

         04-304      m168   Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000207

TITLE: Integer bit-model inconsistency

KEYWORDS: Bit manipulation procedures, models for integer data

DEFECT TYPE: Erratum

STATUS: Passed by J3 meeting



QUESTION: Is the following observation true?



[F90 185:last sentence of 13.5.7] and [WG5/N1176, 219:22+] says ``In

particular, whereas the models are identical for w_{z-1}=0, they do

not correspond for w_{z-1}=1 and ...''



This statement assumes r==2 in the model for integer data defined in

 13.7.1, it is not true for general r. The above sentence should be

 changed to something like



``In particular, whereas the models are identical for r=2 and

  w_{z-1}=0, they do not correspond for r/=2 or w_{z-1}=1, and ...''



ANSWER: Yes.



DISCUSSION:



The integer model in 13.7.1 describes integer values using a

signed-magnitude, base r representation. The bit model in 13.5.7

describes a method for characterizing a sequence of bits. The two

models do not generally correspond and the final sentence of 13.5.7 is

defective.



EDITS: [219:22-24] Remove the sentence beginning "In particular..."



SUBMITTED BY: Michael Hennecke



HISTORY: submitted Mar. 12, 1996      (first appeared in 96-006r2)

         WG5/N1404         Draft answer

         00-260      m154  Passed by J3 meeting

         00-329      m155  Failed J3 letter ballot

         WG5/N1452         Suggested revision

         01-292      m158  Passed by J3 meeting 11-1

         01-380      m159  Failed J3 letter ballot

         04-305r1    m168  Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000208

TITLE: nonadvancing output followed by list directed output

KEYWORDS: Nonadvancing, list directed

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:

    Section 10.8.2, last sentence.  If nonadvancing output is

    followed by list-directed output, is a blank required before

    the first character written?  (I assume that if the first

    character of the current record is not a blank, list-directed

    output is not required, though possibly permitted, to replace

    that character with a blank.)



ANSWER: No.



DISCUSSION:



Following the non-advancing output operation, the location for the

start of the next output operation is within the current record.  The

list-directed output operation begins at this location. List-directed

output is an advancing output operation. Following the list-directed

output the file position is after the just-written record.



If the location for the start of the list-directed output operation is

at the beginning of the record, a blank is written to the first

location.  Otherwise, no characters are inserted between the end of

the non-advancing output and the start of the list-directed output.



EDITS: None.



SUBMITTED BY: Robert Paul Corbett (robert.corbett@Eng.sun.com)



HISTORY: submitted Mar. 13, 1996      (first appeared in 96-006r2)

         WG5/N1404          Draft answer

         00-260      m154   Passed by J3 meeting

         00-329      m155   Failed J3 letter ballot

         04-314      M168   Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: F90/000210

TITLE: nonadvancing write followed by list directed write

KEYWORDS: Nonadvancing, list directed

DEFECT TYPE: Interpretation

STATUS: Passed by J3 meeting



QUESTION:

    If a program does a nonadvancing WRITE followed by a

    list-directed WRITE, must the list-directed WRITE write to the

    current record or may it start a new record?





ANSWER: The list-directed WRITE is not required to start a new record.



DISCUSSION:



Following the non-advancing output operation, the location for the

start of the next output operation is within the current record.  The

list-directed output operation begins at this location. New records

may be created during processing of the list-directed output

statement.



EDITS: None.



SUBMITTED BY: Robert Paul Corbett



HISTORY: submitted Mar. 13, 1996      (first appeared in 96-006r2)

         WG5/N1404          Draft answer

         00-260      m154   Passed by J3 meeting

         00-329      m155   Failed J3 letter ballot

         04-315      m168   Passed by J3 meeting vote



----------------------------------------------------------------------



NUMBER: JP-24

TITLE: The bnf term shared-term-do-construct

KEYWORDS: DO, BNF

DEFECT TYPE: Erratum

STATUS: Passed by J3 meeting



QUESTION:



JP-24)

  In 8.1.4.2, second constraint below R833 states that:



  "The do-term-shared-stmt shall be identified with a label

   and all of the label-do-stmts of the shared-term-do-construct

   shall refer to the same label."



  This implies a label-do-stmts of the outer-most outer-shared-

  do-construct will permit not to refer to the same label, because

  shared-term-do-construct does not include outer-most outer-

  shared-do-construct.



  So the term "shared-term-do-construct" should be changed to

  "inner-share-do-construct and outer-shared-do-construct."



DISCUSSION:



  There is a typographical error in the question - "8.1.4.2"

  should read "8.1.4.1.2".



  The following amplification of the question was provided at the

  August 2000 WG5 meeting:



  The present BNF does not preclude the following as a single

  construct:



    do 10 i=1,5     ! outer

     do 20 j=1,5    ! outer

      do 20 k=1,5   ! outer

       do 20 l=1,5  ! inner

         ...

    20 continue     ! shared



ANSWER:



  Agreed.



EDITS:



  [127:29.5] Replace "<shared-term-do-construct>" by

   "<inner-shared-do-construct> and <outer-shared-do-construct>".



  {The intention is to alter the second line of the second constraint

   following R833.  The line numbering is awry in the F95 copy being

   used.}



SUBMITTED BY: Japan



HISTORY: 99-208     m150      Submitted

         99-221     m150      Classified as Fortran 95 interpretation

         WG5-N1411  Aug-2000  Draft answer

         02-131r1   m160      Passed unanimously by J3 meeting

         03-197     m165      Passed by J3 letter ballot

         WG5-N1561            Request from WG5 to reconsider

         03-238     m165      Passed by J3 meeting
