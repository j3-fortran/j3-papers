
                                                      J3/04-312r1

Date:    6 May 2004
To:      J3
From:    Richard Maine
Subject: F95 interp 30

NUMBER: 000030
TITLE: Ordering requirements on definition of specification functions
KEYWORDS: Specification expressions, specification functions
DEFECT TYPE: Erratum
STATUS: J3 consideration in progress

QUESTION: Consider the following program unit.

      MODULE MOD
        INTERFACE INT
          MODULE PROCEDURE F1, F2
        END INTERFACE
      CONTAINS
        INTEGER PURE FUNCTION F1(I)
          INTEGER :: A(INT(1_4)), B(INT(1_2))    ! A(1), B(19)
          INTEGER, PARAMETER :: KIND = SIZE(A)   ! KIND == 1
          INTEGER(KIND), INTENT(IN) :: I

          F1 = 17
        END FUNCTION F1

        INTEGER PURE FUNCTION F2(J)
          INTEGER :: C(INT(2_4))                 ! C(2)
          INTEGER, PARAMETER :: KIND = SIZE(C)   ! KIND == 2
          INTEGER(KIND), INTENT(IN) :: J

          F2 = 19
        END FUNCTION F2
      END MODULE MOD

In processing the references to "INT(1_4)" and "INT(1_2)" in F1, the
processor needs to determine whether the references are to the
intrinsic function, INT, or to one of the specific procedures, F1 or
F2.  Determining that requires the processor to have determined the
kind type parameter of the dummy argument J, of F2.  In turn, that
requires the processor to determine whether the reference to
"INT(2_4)" is a reference to the intrinsic function, INT, or to one
of the specific procedures, F1 or F2.  Determining that requires the
processor to determine the kind type parameter of the dummy argument
I, which requires it to determine that "INT(1_4)" in F1 was a
reference to the intrinsic function INT.

After all this is determined, the processor can determine that the
reference to "INT(1_2)" in the declaration of B in F1 is a reference
to the specification function F2.

According to 7.1.6.1 [94:38-41],

     "If an initialization expression includes a reference to an
      inquiry function for a type parameter or an array bound of an
      object specified in the same <specification-part>, the type
      parameter or array bound shall be specified in a prior
      specification of the <specification-part>.  The prior
      specification may be to the left of the inquiry function in the
      same statement."

According to 7.1.6.2 [96:27-37],

     "A variable in a specification expression shall have its type and
      type parameters, if any, specified by a previous declaration in
      the same scoping unit, or by the implicit typing rules in effect
      for the scoping unit, or by host or use association.  If a
      variable in a specification expression is typed by the implicit
      typing rules, its appearance in any subsequent type declaration
      statement shall confirm the implied type and type parameters.

      If a specification expression includes a reference to an inquiry
      function for a type parameter or an array bound of an entity
      specified in the same <specification-part>, the type parameter
      or array bound shall be specified in a prior specification of
      the <specification-part>.  The prior specification may be to
      the left of the inquiry function reference in the same
      statement.  If a specification expression includes a reference
      to the value of an element of an array specified in the same
      <specification-part>, the array shall be completely specified
      in prior declarations."

The rules regarding references to variables in a specification
expressions and initialization expressions require a strict
left-to-right, top-to-bottom ordering between specification and
inquiry.  Specification functions appear to be unrestricted in this
respect.

Assuming that the processor supports integers with kind type
parameters of 1, 2 and 4, was it the intent of the committee that the
program unit above should be standard-conforming?

ANSWER:

No, it is not the intent that the above program unit be standard
conforming.  The required complexity of implementation is not
justified.  The standard has no prohibition against it, but the
lack of such a prohibition was an oversight.  The edits below
correct this oversight.

EDITS:

Add the following new paragraph immediately before Note 7.14:

  If an initialization expression in a module includes a reference to
  a generic, that generic shall have no specific procedures defined
  in the module subsequent to the initialization expression.

Add the following new paragraph immediately before Note 7.16:

  If a specification expression in a module includes a reference to
  a generic, that generic shall have no specific procedures defined
  in the module subsequent to the specification expression.

SUBMITTED BY: Henry Zongaro

HISTORY: 98-176   m146 Submitted
         04-312R1 m168 Answer proposed
