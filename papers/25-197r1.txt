To: J3                                                     J3/25-197r1
From: Malcolm Cohen
Subject: US15 Readonly pointers, edits
Date: 2025-October-27
Reference: 23-198, 24-167, 25-179r1, 25-182r1, 25-007r1.

1. Introduction

23-198 is the background paper for US15; meeting 230, unanimous consent.
24-167 is the estimate of effort involved (UK panel): level 4.
25-179r1 contains the formal requirements and specifications.
25-182r1 contains the formal syntax.


2. Edits for 25-007r1

[xv] Introduction, p2, Data declaration bullet, insert sentence:

   "The PROTECTED_TARGET attribute can be used to declare a data pointer
    whose target cannot be defined, or become undefined, via the pointer."

[45:22+] 5.1 High level syntax, R513 other-specification-stmt,
         after "or protected-stmt"
         insert "or protected-target-stmt".

[85:13+] 7.5.4.1 Component definition statement, R738 component-attr-spec,
         after "or POINTER"
         insert "or PROTECTED_TARGET".

[86:1+] Same subclause, after C756 (R737) If the CONTIGUOUS attribute...,
        insert new constraint:
   "C756a If the PROTECTED_TARGET attribute is specified in a
          component-attr-spec-list, the POINTER attribute shall also be
          specified in that list.".

[110:30+] 8.2 Type declaration statement, R802 attr-spec,
          insert new production in alphabetic order:
            "or PROTECTED_TARGET".

[126:8-] 8.5 Attributes, insert new subclause alphabetically:

   "8.5.15a PROTECTED_TARGET attribute

    The PROTECTED_TARGET attribute imposes limitations on the usage of a
    data pointer.

    C860a A pointer with the PROTECTED_TARGET attribute shall not appear
          in a variable definition context other than as an
           allocate-object in an ALLOCATE statement.

    C860b A pointer with the PROTECTED_TARGET attribute shall not be in a
          common block.

{Note to J3: That is obsolescent, but it's not worth noting here.}

    C860c A pointer with the PROTECTED_TARGET attribute shall not be an
          allocate-object in a DEALLOCATE statement.

    C860d If a pointer with the PROTECTED_TARGET attribute appears as an
          allocate-object in an ALLOCATE statement, that statement shall
          have a SOURCE= clause.

    C860e If a pointer with the PROTECTED_TARGET attribute, or a subobject
          thereof, appears as the data-target in a pointer assignment
          statement, the data-pointer-object in that statement shall have
          the PROTECTED_TARGET attribute.

    C860f If a pointer with the PROTECTED_TARGET attribute, or a subobject
          thereof, appears as the data-target in a structure-constructor,
          the corresponding component shall have the PROTECTED_TARGET
          attribute.

    C860g If a pointer with the PROTECTED_TARGET attribute, or a subobject
          thereof, appears as an actual argument and the corresponding
          dummy argument is a pointer, that dummy argument shall have the
          PROTECTED_TARGET attribute.

    C860h A pointer with the PROTECTED_TARGET attribute, or a subobject
          thereof, shall not appear as an actual argument to a procedure
          that has an implicit interface.

{Note to J3: This is for specification S7, so should be removed if that
             specification was not adopted.}

    C860i If a pointer with the PROTECTED_TARGET attribute, or a subobject
          thereof, appears as an actual argument and the corresponding
          dummy argument is not a pointer, that dummy argument shall have
          the INTENT (IN) attribute.

{Note to J3: This is for specification S8, so should be removed if that
             specification was not adopted.}

    The target of a data pointer with the PROTECTED_TARGET attribute is
    not definable via that pointer.

    NOTE 1
    The PROTECT_TARGET attribute provides a means of having a pointer to a
    protected target (e.g. with the PROTECTED or INTENT (IN) attribute),
    without losing compile-time diagnosis of accidental modification of the
    target via that pointer.

    For example, given
        MODULE m
            REAL, PROTECTED, TARGET :: x
            REAL, POINTER, PROTECTED_TARGET :: p
        END MODULE
    then outside the module,
        p => x
    can validly associate the pointer p with the target x, but
        p = 999
    is invalid, preventing accidental modification of protected data.

    NOTE 2
    If a PROTECTED_TARGET pointer is allocated, the resulting target cannot
    later be manually deallocated. That means that such an allocation is
    only suitable for a target whose value is intended to last for the
    whole duration of the program execution without being changed, but
    which could be allocated with a different value in a later execution.

    The processor could issue a diagnostic message if a local unsaved
    variable is a PROTECTED_TARGET pointer that is allocated in the
    procedure without being pointer-assigned to a more long-lived pointer,
    as on return from the procedure the memory will likely be leaked."

{I put "likely" here, as there are strategies for a processor to recover
 the memory itself, if the leakage is blatant enough.}

{Note to J3: we could add some more examples if that is thought useful.
 For that matter, we could put the entire example content from the syntax
 paper into Annex C and provide a link to it from here.}

[135:2-] 8.6 Attribute specification statements,
         insert subclause alphabetically:

   "8.6.13a PROTECTED_TARGET statement

    R859a protected-target-stmt is PROTECTED_TARGET [ :: ]
                                   variable-name-list

    C892a A variable-name in a protected-target-stmt shall have the POINTER
          attribute.

    The PROTECTED_TARGET statement specifies the PROTECTED_TARGET attribute
    for a list of variables."

===END===
